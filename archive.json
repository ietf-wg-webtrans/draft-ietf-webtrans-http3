{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2021-04-29T00:53:18.700934+00:00",
  "repo": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "pooling",
      "description": "Issues related to pooling multiple WebTransports together",
      "color": "7C45A1"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "MDU6SXNzdWU1MDIyNTA1ODY=",
      "title": "Consider using a stream prefix in QuicTransport",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/2",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In QuicTransport, instead of having the client send the origin on stream 2, we could have all unidirectional streams carry a prefix and use that. This would map closely with HTTP/3 and HttpTransport, and would therefore allow code reuse",
      "createdAt": "2019-10-03T19:22:49Z",
      "updatedAt": "2021-01-27T20:15:19Z",
      "closedAt": "2021-01-27T20:15:19Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:15:19Z",
          "updatedAt": "2021-01-27T20:15:19Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU1MDIyNTEwNjU=",
      "title": "QuicTransport client indication could use varints",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/3",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "QuicTransport client indication could use varints instead of 16bit integers, that'll map closer to QUIC and give us more future-proof flexibility",
      "createdAt": "2019-10-03T19:23:49Z",
      "updatedAt": "2021-01-27T20:15:10Z",
      "closedAt": "2021-01-27T20:15:10Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:15:10Z",
          "updatedAt": "2021-01-27T20:15:10Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU1MTIxOTgxNDA=",
      "title": "Add WEBTRANS WG Charter and Agenda files",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/4",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It'll be easier to iterate on the WEBTRANS WG Charter proposal as well as the BOF Agenda if we store these in github. \r\n\r\nCurrent BOF Agenda is as follows: \r\n\r\nWEBTRANS BOF Agenda\r\nApplications and Real-Time Area (ART)\r\nWednesday, November 20, 2019\r\n13:30 - 15:00\r\nRoom: Canning\r\nMailing list: webtransport@ietf.org\r\n\r\n13:30 - 13:35 PM Preliminaries (5 minutes)\r\n   Agenda Bash\r\n   Bluesheets\r\n   Minute takers\r\n   Jabber scribe\r\n\r\n13:35 - 13:55 PM Use Cases and Requirements (20 minutes)\r\nhttps://tools.ietf.org/html/draft-vvv-webtransport-overview\r\n\r\n   Machine Learning APIs\r\n   Communications Platform APIs\r\n   Web Gaming\r\n   Requirements/Summary\r\n\r\n13:55 - 14:35 Relevant Drafts (40 minutes)\r\n\r\nAn Unreliable Datagram Extension to QUIC (Tommy Pauly, 10 minutes)\r\nhttps://tools.ietf.org/html/draft-pauly-quic-datagram\r\n\r\nUsing QUIC Datagrams with HTTP/3 (David Schinazi, 5 minutes)\r\nhttps://tools.ietf.org/html/draft-schinazi-quic-h3-datagram\r\n\r\nWebTransport over QUIC (Victor, Vailiev, 5 minutes)\r\nhttps://tools.ietf.org/html/draft-vvv-webtransport-quic\r\n\r\nHTTP/2 as a Transport for Arbitrary Bytestreams (Eric Kinnear & Tommy Pauly, 10 minutes)\r\nhttps://tools.ietf.org/html/draft-kinnear-httpbis-http2-transport\r\n\r\nWebTransport over HTTP/3 (Victor Vasiliev, 10 minutes)\r\nhttps://tools.ietf.org/html/draft-vvv-webtransport-http3\r\n\r\n14:35 - 14:45 Potential Charter (10 minutes)\r\n\r\n14:45 PM - 15:00 PM Wrapup and Summary (15 minutes)\r\n\r\nThe current WEBTRANS charter proposal is as follows: \r\n\r\nWebTransport (WEBTRANS)\r\n---------------------------------------------\r\nCharter\r\n\r\nChairs:\r\n     TBD\r\n\r\nApplications and Real-Time Area Directors:\r\n     Barry Leiba <barryleiba@computer.org>;\r\n     Alexey Melnikov <aamelnikov@fastmail.fm>;\r\n     Adam Roach <adam@nostrum.com>;\r\n\r\nApplications and Real-Time Area Advisor:\r\n     Barry Leiba <barryleiba@computer.org>;\r\n\r\nMailing Lists:\r\n     General Discussion: webtransport@ietf.org\r\n     To Subscribe:       https://www.ietf.org/mailman/listinfo/webtransport\r\n     Archive:\r\nhttps://mailarchive.ietf.org/arch/browse/webtransport/\r\n\r\nDescription of Working Group:\r\n\r\nThe WebTransport working group will define new protocols or\r\nprotocol extensions in order to support the development of the\r\nW3C WebTransport API <https://wicg.github.io/web-transport>;.\r\n\r\nThese protocols will support:\r\n  * Reliable bidirectional and unidirectional communication\r\n    that provides greater efficiency than Websockets\r\n    (e.g. removal of head-of-line blocking).\r\n  * Unreliable datagram communication, functionality not\r\n    available in Websockets.\r\n  * Origin checks to allow supporting the Web's origin-based\r\n    security model.\r\n\r\nThe WebTransport working group will define three variants:\r\n  * A protocol directly running over QUIC with its own ALPN.\r\n  * A protocol that runs multiplexed with HTTP/3.\r\n  * Fallback protocols that can be used when QUIC or UDP\r\n    are not available.\r\n\r\nThe group will pay attention to security issues arising from\r\nthe above scenarios so as to ensure against creation of new\r\nmodes of attack, as well as to ensure that security issues\r\naddressed in the design of Websockets remain addressed\r\nin the new work.\r\n\r\nTo assist in the coordination with W3C, the group will\r\ninitially develop an overview document containing use cases\r\nand requirements in order to clarify the goals of the effort.\r\nFeedback will also be solicited at various points along the way\r\nin order to ensure the best possible match between the protocol\r\nextensions and the needs of the W3C WebTransport API. The clarity\r\nand interoperability of specifications will be confirmed via test\r\nevents and hackathons.\r\n\r\nThe group will also coordinate with other working groups within\r\nthe IETF (e.g. QUIC, HTTPBIS) as appropriate.\r\n\r\nGoals and Milestones:\r\n\r\n  March 2020     - Adopt a WebTransport Overview draft as a WG work item\r\n  March 2020     - Adopt a draft on WebTransport over QUIC as a WG work item\r\n  March 2020     - Adopt a draft on WebTransport over HTTP/3 as a WG work\r\nitem\r\n  March 2020     - Adopt a draft on HTTP/2 fallback mechanism as a WG work\r\nitem\r\n  March 2020     - Adopt a draft on a QUIC fallback mechanism as a WG work\r\nitem\r\n  August 2020      - Issue WG last call of the WebTransport Overview\r\ndocument.\r\n  November 2020  - Issue WG last call on WebTransport over QUIC\r\n  November 2020  - Issue WG last call on QUIC fallback mechanism\r\n  February 2021  - Issue WG last call on WebTransport over HTTP/3\r\n  February 2021  - Issue WG last call on HTTP/2 fallback mechanism",
      "createdAt": "2019-10-24T21:48:24Z",
      "updatedAt": "2019-10-29T18:18:40Z",
      "closedAt": "2019-10-29T18:18:40Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "This is now at https://github.com/DavidSchinazi/webtrans-wg-materials",
          "createdAt": "2019-10-29T18:18:40Z",
          "updatedAt": "2019-10-29T18:18:40Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWU1MTkwMzY2NzE=",
      "title": "Http3Transport does not have a consistent stream ID view if proxies are involved",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/10",
      "state": "OPEN",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In -overview, we require that \"The client and the server have to agree on the numbering, so it can be referenced in the application payload.\".  However, if an Http3Transport session is relayed through a proxy, it is not feasible to make the stream IDs to match on client-to-proxy and proxy-to-server, so we would have to encode a separate ID inside the stream ourselves or come up with a scheme for numbering those.",
      "createdAt": "2019-11-07T04:42:03Z",
      "updatedAt": "2021-01-14T18:31:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Also, since Http3Transport is pooled, exposing actual stream IDs would provide information about other traffic on the same connection, which is potentially from different origin.  So using those directly would be a security issue.",
          "createdAt": "2019-11-07T05:05:19Z",
          "updatedAt": "2019-11-07T05:05:19Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I've thought about trying to make a clever mapping scheme, but the problem is, the stream IDs can get reordered across proxy hops (otherwise there would be HOLB).  So it sounds like generating and encoding our own \"global\" (i.e. preserved across hops) numbers would be the only way.",
          "createdAt": "2019-11-07T05:13:24Z",
          "updatedAt": "2019-11-07T05:13:24Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "H3 makes an effort to not expose QUIC stream IDs directly, partially for this reason, and I believe it was a good design choice.\r\n\r\nAre we certain stream IDs need to be referenced in the application payload?  It seems a bit like a layering violation.",
          "createdAt": "2021-01-14T18:31:31Z",
          "updatedAt": "2021-01-14T18:31:31Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWU1MjEzMDMwNjU=",
      "title": "Confirm the URL scheme name",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/11",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The draft currently says `quic-transport:`, however, we'd still need to confirm this with the working group once we actually have one.",
      "createdAt": "2019-11-12T03:15:28Z",
      "updatedAt": "2021-01-27T20:17:14Z",
      "closedAt": "2021-01-27T20:17:14Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:17:14Z",
          "updatedAt": "2021-01-27T20:17:14Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU1MjU2MDEzMDY=",
      "title": "QUIC Transport \"path\" seems underspecified",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/12",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As discussed in Singapore BoF, the \"path\" of the URI for QUIC transport needs further specification. It isn't clear if it's a location, an application indication, or something else.",
      "createdAt": "2019-11-20T06:24:00Z",
      "updatedAt": "2021-01-27T20:17:22Z",
      "closedAt": "2021-01-27T20:17:22Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:17:22Z",
          "updatedAt": "2021-01-27T20:17:22Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU1MjU2MDI2MDE=",
      "title": "QUIC transport URI is not equivalent to WebSocket fallback ",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/13",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "A QUIC transport URI negotiates WebTransport protocol first, then gives a path. WebSocket does path first, then gets into the support of WebSocket. That's not equivalent semantics if you fall back from one to the other.",
      "createdAt": "2019-11-20T06:27:57Z",
      "updatedAt": "2021-01-27T20:17:33Z",
      "closedAt": "2021-01-27T20:17:33Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:17:33Z",
          "updatedAt": "2021-01-27T20:17:33Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU1MjY5OTgxNzA=",
      "title": "Meaning of \"Fallback\"",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/14",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The term \"fallback\" is not well enough defined.  It might be helpful to define a list of requirements that \"fallback\" transport (and APIs) must satisfy. \r\n\r\nAs an example, if QUIC is not available,  but HTTP/2 over TCP is, it may be possible to utilize RFC 8441 and/or potential extensions to provide for multiple streams over TCP.  This would support a portion of the WebTransport API (e.g. reliable streams), but now loss on one stream will block other streams and some protocol functionality (e.g. datagrams) may not be available.  Does that mean that some WebTransport methods operate differently or are not available?  In some cases, developers might prefer to \"fallback\" to the existing WebSockets API with its message-orientation.",
      "createdAt": "2019-11-22T05:37:59Z",
      "updatedAt": "2021-01-27T20:17:57Z",
      "closedAt": "2021-01-27T20:17:56Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "I don't know where \"fallback\" is currently being used, but I agree, it's not a good idea to silently downgrade functionality.\r\n\r\nThe idea is that WebTransports implement one or more interfaces (mixins) based on capability. The only way to fallback to another transport is if it 1) supports the same interfaces required by the developer and 2) a fallback server is advertised.\r\n\r\nMy question is, does there even need to be a fallback mechanism? Would a developer be able to implement the fallback themselves, perhaps with a simple timeout on connect?",
          "createdAt": "2020-08-09T21:38:59Z",
          "updatedAt": "2020-08-09T21:38:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the fallback transport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:17:56Z",
          "updatedAt": "2021-01-27T20:17:56Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU1MzI2OTM1MTI=",
      "title": "Define Error Code of WebTransport over QUIC",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/15",
      "state": "CLOSED",
      "author": "flano-yuki",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In WebTransport over QUIC, when an invalid  Client Indication is received, the server\t treats the connection as an error([section 6](https://vasilvv.github.io/webtransport/draft-vvv-webtransport-quic.html#rfc.section.6)).\r\n\r\nThis is an error that occurred in a layer above the QUIC, so I think the connection should be closed with CONNECTION_CLOSE (0x1d) indicating an error in the application using the QUIC.\r\n\r\nI think it is valuable to define an error code for WebTransport over QUIC.\r\n( [draft-ietf-quic-transport-24 section 20.1](https://tools.ietf.org/html/draft-ietf-quic-transport-24#section-20.1) saids \"the management of application error codes is left to application protocols.\" )\r\n\r\nand, by specifying the error code that the endpoint uses when it close the connection, the specification becomes clear.\r\n\r\nfor example\r\n```\r\n- WQ_NO_ERROR \r\n- WQ_INVALID_CLIENT_INDICATION\r\n- WQ_NOT_AUTHORITATIVE_ORGIN\r\n- WQ_OTHER_ERROR\r\n...\r\n```",
      "createdAt": "2019-12-04T13:43:27Z",
      "updatedAt": "2021-01-27T20:18:07Z",
      "closedAt": "2021-01-27T20:18:07Z",
      "comments": [
        {
          "author": "flano-yuki",
          "authorAssociation": "NONE",
          "body": "I realized that using Error Code is related to the [WICG/web-transport](https://github.com/WICG/web-transport).\r\n\r\nDo not conflict with error codes used by applications above WebTransport.\r\n\r\nso, I createted https://github.com/WICG/web-transport/issues/80 .\r\nPlease point it out if there are any mistakes in my opinion.\r\n\r\nthanks",
          "createdAt": "2019-12-09T05:00:22Z",
          "updatedAt": "2019-12-09T16:28:29Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "I agree, CONNECTION_CLOSE should provide an error code indicating why the connection was refused.",
          "createdAt": "2020-08-09T21:16:59Z",
          "updatedAt": "2020-08-09T21:16:59Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "I seem to remember seeing non-zero error codes from other endpoints when interoperating. If so, I have no clue what those codes were supposed to mean. I think it would be useful to have some defined in the next draft version.",
          "createdAt": "2020-09-05T23:54:42Z",
          "updatedAt": "2020-09-05T23:54:42Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the non-zero error codes probably were random HTTP/3 error codes, because those are the only codes that Google's QUIC library supports (that's a known bug).\r\n\r\nI see three options for reporting handshake error:\r\n1) An application CONNECTION_CLOSE,\r\n2) A RESET_STREAM on the handshake stream,\r\n3) An error status code on the handshake stream.\r\n\r\nIf we go with 1, we would have to reserve some of the application error code space.  If we go with 2 or 3, we would have to describe how the server has to keep the connection open for some time in order to allow for retransmission of the RESET_STREAM/response error header.",
          "createdAt": "2020-09-23T20:21:59Z",
          "updatedAt": "2020-09-23T20:21:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:18:07Z",
          "updatedAt": "2021-01-27T20:18:07Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU2NzU3NjY5Mjg=",
      "title": "QuicTransport: 0-RTT and Origin Indication",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/16",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "[QuicTransport optionally supports 0-RTT](https://vasilvv.github.io/webtransport/draft-vvv-webtransport-quic.html#rfc.section.3.3) if there's a corresponding API for early data.\r\n\r\nThe WICG draft does not define any way to enable early data, and it probably shouldn't anyway. Early data complicates the API and exposes the user to potential security vulnerabilities if they misunderstand the risks.\r\n\r\nHowever, one thing worth clarifying in relation to 0-RTT is the origin indication message. It must be safe to send the origin indication in 0-RTT for any API to support early data. I don't fully understand if this is true but my impression is that it would be safe.\r\n\r\nAs for APIs that only send application data in 1-RTT space, sending the origin indication message in 0-RTT would be a slight improvement. The server must buffer all streams until the origin indication has been processed, so sending the origin indication early would reduce that initial head-of-line blocking.\r\n\r\nCould we clarify that origin indication CAN or SHOULD be sent in 0-RTT?",
      "createdAt": "2020-08-09T20:31:32Z",
      "updatedAt": "2021-01-27T20:18:21Z",
      "closedAt": "2021-01-27T20:18:21Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "The word that I'm missing is idempotent. If we make the origin/path handshake idempotent, then QuicTransport can support 0-RTT.",
          "createdAt": "2020-11-17T01:48:45Z",
          "updatedAt": "2020-11-17T01:48:45Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:18:21Z",
          "updatedAt": "2021-01-27T20:18:21Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWU2NzU3NzM0Mjk=",
      "title": "QuicTransport: origin indication via transport parameters",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/17",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "QuicTransport identifies itself using an ALPN and both peers agree to transfer additional configuration via a client-initiated stream (ID 2).\r\n\r\nI think it would be an improvement if this origin indication was moved into the QUIC transport parameters and exchanged via the TLS ClientHello.\r\n\r\nThere would be a few benefits (in no particular order):\r\n1. A server can terminate an invalid origin/path prior to performing the expensive TLS handshake.\r\n2. A server does not need to buffer stream data (inbound and outbound) waiting until stream 2 has arrived.\r\n3. A load balancer can route new connections to the correct server based on the path in the ClientHello. Currently, a load balancer must terminate TLS and buffer all streams until it can parse stream 2 prior to making a routing decision.\r\n4. QUIC stream IDs could be exposed to the application without the asterisks that stream 2 has already been used. \r\n5. The first client packet (ClientHello) must already be padded to 1200 bytes. The origin and path parameters would replace some of that padding and overall reduce the bandwidth for a new connection.\r\n\r\nThere would be a few downsides:\r\n1. Long paths and origins could cause fragment the ClientHello message into multiple packets.\r\n2. Requires [registering](https://tools.ietf.org/html/draft-ietf-quic-transport-29#section-22.2) `webtransport_path` and `webtransport_origin`.\r\n3. QUIC libraries need to expose or support the new transport parameters.",
      "createdAt": "2020-08-09T21:15:23Z",
      "updatedAt": "2020-09-08T20:55:30Z",
      "closedAt": "2020-09-08T20:55:30Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "One more downside:\r\n4. The path and origin won't be encrypted. This leaks more information than SNI alone and would especially be a problem if ESNI is the future.\r\n\r\nYeah, unfortunately I think this alone is a reason to stick with the stream 2 approach. Thanks for letting me think out loud!",
          "createdAt": "2020-08-10T00:26:43Z",
          "updatedAt": "2020-08-10T00:27:00Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, that's pretty much the reason why stream 2 exists (we tried a few ways to limit ourselves to transport params, but those didn't work out).  It's possible that we could use [ALPS](https://tools.ietf.org/html/draft-vvv-tls-alps-00) for this, but ALPS is still in very early stage, so it's hard to tell if it will be useful.",
          "createdAt": "2020-08-10T14:21:33Z",
          "updatedAt": "2020-08-10T14:21:33Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU2OTYxODY1NTM=",
      "title": "QuicTransport: Rejecting a path",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/19",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The spec defines a way to reject an unsupported origin with a CONNECTION_CLOSE (which has its own problems) but it does not define a way to reject an unsupported path. It's left up to the application, presumably to send a custom message or custom CONNECTION_CLOSE error code.\r\n\r\nI think that origin and path rejection should use the same rejection mechanism. Consistency will be important as new fields are added, potentially including user-defined fields. There are a few options:\r\n\r\n1. Path and origin rejection uses CONNECTION_CLOSE with reserved codes.\r\n2. Path and origin rejection uses a custom message containing an error code/message, sending CONNECTION_CLOSE upon receipt.\r\n3. Path and origin rejection is handled by the application. \r\n4. Path and origin rejection use RESET_STREAM, sending CONNECTION_CLOSE upon receipt.\r\n\r\nI'm actually in favor of 3. \r\n\r\nThe browser still needs to populate the origin for security reasons. However, the server can terminate the connection however it sees fit; the reason why does not need to be communicated to QuicTransport or the browser. It's much simpler than defining error codes and is the minimal work to allow QUIC in a web environment.",
      "createdAt": "2020-09-08T21:22:38Z",
      "updatedAt": "2021-01-27T20:18:52Z",
      "closedAt": "2021-01-27T20:18:52Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "As mentioned on the PR, I think RESET_STREAM could also be effective.",
          "createdAt": "2020-09-08T21:30:20Z",
          "updatedAt": "2020-09-08T21:30:20Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "Added option 4! I like it more than option 1 and 2.",
          "createdAt": "2020-09-08T22:05:31Z",
          "updatedAt": "2020-09-08T22:05:31Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:18:52Z",
          "updatedAt": "2021-01-27T20:18:52Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU3MDY3NTAxMDE=",
      "title": "Reconsider the design around header block size limit",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/20",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Reviewing #18, @LPardue wrote:\r\n\r\n> It seems unfortunate if a client can force a server to buffer up to 1,048,576 bytes. Yes the server can hangup, but it would have to wait until the application-imposed limit was reached. It might be healthier for the block to begin with a total length field. That allows a server to early abort.\r\n\r\nI do agree that this is annoying, but at the same time adding a field that's redundant 90% of the time feels... weird?  We should think more seriously about how to make header size limits work at some point (maybe using ALPS or something like that).",
      "createdAt": "2020-09-22T23:16:57Z",
      "updatedAt": "2021-01-27T20:19:02Z",
      "closedAt": "2021-01-27T20:19:01Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:19:01Z",
          "updatedAt": "2021-01-27T20:19:01Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU3NDQyMzc1NTU=",
      "title": "Http3Transport connection flow control",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/22",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "pooling"
      ],
      "body": "Note that all of the below works when you swap \"server\" and \"client\". I wanted to focus on a poor Javascript client implementation, but it's equally possible to run into these cases with a poor server implementation.\r\n\r\nLet's say that you have a Http3Transport session that shares a connection with HTTP/3 or another Http3Transport session.\u00a0\r\n\r\n\r\n### MAX_DATA\r\nThe client has limited buffer space and hypothetically advertises MAX_DATA of 1MB for the connection. If the server pushes 1MB of unprocessed data over a Http3Transport session, then it will prevent the server from sending data over the connection,\u00a0including HTTP/3 responses and other Http3Transport sessions.\r\n\r\nThis can occur if the application does not accept all remote-created streams or does not fully read every stream. This will be VERY easy for a developer to mess up. It can also occur if the application can not process data faster than it is received.\r\n\r\nIn my case, the server creates unidirectional streams and pushes a large amount of media over them. The flow control limit would be hit if the Javascript application:\r\n\r\n- Only accepts bidirectional streams (ex. initialization)\r\n- Does not accept a unidirectional stream (ex. error or teardown)\r\n- Does not fully read or abort every stream (ex. parsing error)\r\n- Is not able to parse the media fast enough (ex. underpowered).\r\n\r\nThis is mostly intended behavior, otherwise these \"bugs\" would cause unbounded memory usage. However, the blast radius is bigger when sharing a connection.\u00a0\r\n\r\nIn my use-case, hitting the flow control limit would also block any HTTP/3 RPC calls or unrelated traffic on the connection. This introduces more scenarios for the connection to\u00a0become deadlocked or generally stalled.\r\n\r\n### MAX_STREAMS\r\nHTTP/3 implementations use MAX_STREAMS to limit the number of simultaneous requests. This use-case no longer works when sharing a connection with a Http3Transport session, and HTTP/3 implementations must instead return explicit error status codes when this threshold\u00a0is reached.\r\n\r\nThe same issues with MAX_DATA also apply to MAX_STREAMS. A Javascript application that fails to accept or read/abort every stream will consume flow control resources. This can manifest itself in strange ways, such as HTTP/3 being unable to create control streams, or simply being unable to create new request streams.",
      "createdAt": "2020-11-16T22:25:19Z",
      "updatedAt": "2021-03-05T15:43:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Thanks for the salient overview, it makes it easier to understand your concerns.\r\n\r\nMy first comment would be that some of these points apply to QuicTransport too. Its just that their made worse by Http3Transport pooling allowing the mashing together of orthogonal protocols with no application-layer oversight. Just as you might interfere with a page load, a browser could easily interfere with your finely crafted application protocol. I would anticipate that, due to different browsers having different HTTP usage patterns, and different pages being composed differently by time, region, etc, one might find that Http3Transport apps subject to pooling would experience inconsistencies and transient issues. \r\n\r\nYou rightly point out that the connection flow control is a shared resource. But the problems described seem to relate to stream flow control and overlooks the different flow control setting afforded by the Transport Parameters. A possible mitigation is to more tightly constrain the initial flow windows of server-initiated streams so that they can't interfere with requests. However, I still think that the notion of pooling together WebTransports in an uncoordinated fashion is going to manifest undesirable properties.\r\n\r\nThe MAX_STREAMS observation is a good one. I think the competition between request streams and client bidirectional streams is going to be hard to resolve.",
          "createdAt": "2020-11-16T23:18:56Z",
          "updatedAt": "2020-11-16T23:18:56Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "Yeah, and enforcing any per sort of per-session flow control might get difficult because you can only identify the protocol and session after you receive the first few bytes of each stream.\r\n\r\nFor example, assume a brand new connection (for simplicity only) and you receive a STREAM frame with id=100, offset=16, and size=1000. You don't know yet which protocol or session created this stream or the 25 preceding it. And hopefully you eventually get those first few bytes for each stream...",
          "createdAt": "2020-11-16T23:56:16Z",
          "updatedAt": "2020-11-16T23:57:17Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU3NDQyNTExMjk=",
      "title": "Http3Transport server-initiated bidirectional stream future proofing",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/23",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Http3Transport currently assumes that server-initiated bidirectional streams and datagrams can only be used for WebTransport. \r\n\r\nI suggest we prefix each server-initiated bidirectional stream and datagram with a new HTTP/3 frame type for WebTransport. This way, a future standard could define it's own frame type to run alongside WebTransport.",
      "createdAt": "2020-11-16T22:38:28Z",
      "updatedAt": "2021-03-08T23:57:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Using an H3 frame type for server initiated bidi streams would also make the design more consistent, instead of the asymmetric design there is today.  It costs a byte per bidi stream, but it seems worth it for consistency and flexibility.\r\n\r\nFor datagrams, I believe that we'd want to be able to coexist with other H3 extensions, such as MASQUE, and I believe that's possible without any extra overhead by adding a Session -> Datagram flow ID mapping when a WebTransport session is created.\r\n\r\n",
          "createdAt": "2021-01-14T21:50:52Z",
          "updatedAt": "2021-01-14T21:50:52Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "If it's a single byte, it's more of a stream type (like the unidirectional stream-type) than a frame type, right?\r\n\r\n> For datagrams, I believe that we'd want to be able to coexist with other H3 extensions, such as MASQUE, and I believe that's possible without any extra overhead by adding a Session -> Datagram flow ID mapping when a WebTransport session is created.\r\n\r\nThere's a discussion Victor pointed me to in #21, where it's suggested that datagrams belonging to a WebTransport session use the Flow ID = to the Session ID.  It would be nice to avoid the extra state and lookup.",
          "createdAt": "2021-01-15T00:38:13Z",
          "updatedAt": "2021-01-15T00:38:13Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah yes, it's more of a stream type.  In that case, I'm unsure of whether there's a good way of eliminating the asymmetry.  The only option I can think of is to not use a stream type for server bidi streams and only use the frame, like for the client initiated bidi streams?\r\n\r\nThanks for the pointer to #21, it looks like there are a few potential designs for datagrams flow IDs.  If in doubt, simpler is probably better.  I'll think more about this one.",
          "createdAt": "2021-01-15T07:37:44Z",
          "updatedAt": "2021-01-15T07:37:44Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "I agree we should use the same mechanics for client and server bidi streams.",
          "createdAt": "2021-01-15T17:04:11Z",
          "updatedAt": "2021-01-15T17:04:11Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After thinking about this more, not having a stream type doesn't seem so bad to me and it does provide symmetry.\r\n\r\nStream types seem like an obvious design choice, but I believe HTTP/3 is sufficiently constrained that one could infer the stream type based on the first frame on the stream.  For example, the control stream MUST start with SETTINGS.  In retrospect, having both stream types and frame types is a bit awkward, and it likely would have been cleaner to only have frame types, but that ship has sailed.",
          "createdAt": "2021-01-15T17:19:16Z",
          "updatedAt": "2021-01-15T17:19:16Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "After having implemented this for hackathon, I can confirm that the lack of stream preface on server-bidi streams is annoying and requires special casing (I actually simulate receiving one).  Let's please add one.\r\n\r\nI took a bit of a shortcut and treated the stream preface as both a stream type AND a frame type.  After peeking at the unidirectional stream input to discover that it's WT, I let the parser run on that and treat it as a frame type, making it symmetric with the bidi case.  Is it possible to define a reserved frame type with the same value as the stream type?",
          "createdAt": "2021-03-03T14:56:00Z",
          "updatedAt": "2021-03-03T14:56:00Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Given HTTP/3 does not have a stream type varint for bidi streams, I think a potential way forward is to say that the first frame on the bidi stream can indicate the 'type' of the stream, but that there is no explicit type identifier on the wire.\r\n\r\n   _Feel free to ignore the below comment, as it's apparently unchanged from January_\r\nLooking back, SETTINGS is required to be the first frame on the control stream, so the control stream type is a bit redundant and the same is true for QPACK and I believe could be true for server push?  Obviously we're not going to redesign HTTP/3 stream and frame types at this stage in the process, but making bidi streams consistent for both perspectives seems preferable to me.",
          "createdAt": "2021-03-05T22:20:46Z",
          "updatedAt": "2021-03-05T22:22:16Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 110.  There seems to be a general agreement that we should make server-initiated bidi streams use the same encoding as client-initiated ones (that is to say, frames).  There was some interest expressed in splitting definition of server-initiated bidi streams into their own draft; @aboba and @DavidSchinazi are to reach out to httpbis about the appropriate venue for that.",
          "createdAt": "2021-03-08T23:57:37Z",
          "updatedAt": "2021-03-08T23:57:37Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "MDU6SXNzdWU3ODYzNjg1Mzc=",
      "title": "Http3Transport Unidirectional Streams section is unclear",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/24",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It talks about the HTTP/3 control stream, which doesn't seem very relevant to establishing new unidirectional streams for WebTransport.\r\n\r\nAlso, I'm unclear on why the HTTP/3 frame type is 54, instead of 41 like the client initiated bidi streams.  Could all WebTransport streams not use a single HTTP/3 frame type?\r\n\r\nhttps://github.com/vasilvv/webtransport/blob/master/draft-vvv-webtransport-http3.md#unidirectional-streams",
      "createdAt": "2021-01-14T21:55:06Z",
      "updatedAt": "2021-03-05T16:04:45Z",
      "closedAt": "2021-03-05T16:04:45Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "I think the text says \"control stream type\" but I think it should just read \"stream type\", per HTTP/3 section 6.2:\r\n\r\n> The purpose is indicated by a stream type, which is sent as a variable-length integer at the start of the stream.\r\n\r\nI agree with Ian that there could be a single uni stream type used for both client and server side streams, since the only difference is their direction, and that's encoded in the stream ID.",
          "createdAt": "2021-01-15T00:41:46Z",
          "updatedAt": "2021-01-15T00:41:46Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Ah, I re-read the spec and now I understand.\r\n\r\n41 is the unidirectional stream type, which is used as a prefix at the beginning of any WebTransport uni stream in either direction.\r\n\r\n54 is a frame type that appears at the beginning of a client-initiated bidi stream, since the H3 spec says the server treats all client-bidi streams as request/response.  I think the new frame is underspecified in the document.  It should be required to have zero length.\r\n\r\nThere's a potential hazard with using a frame to identify the client-initiated bidi WT streams, which is that unknown frame types are allowed to be ignored.  Hopefully no implementation would set the WT SETTINGS field without also having a parser that understands these.",
          "createdAt": "2021-01-15T00:54:57Z",
          "updatedAt": "2021-01-15T00:54:57Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Agh still reading too quickly!\r\n\r\nI see the definition of the frame has no length, which is odd because it is not a proper HTTP/3 frame, per H3 Section 7.1:\r\n\r\n```\r\n7.1. Frame Layout\r\nAll frames have the following format:\r\n\r\nHTTP/3 Frame Format {\r\n  Type (i),\r\n  Length (i),\r\n  Frame Payload (..),\r\n}\r\n```\r\n\r\nOf course this is an extension so we can override this, but it's probably easier on everyone's parser if all frames have both type and length.  We can just state the frame length 0 means \"to the end of the stream\" in this case?\r\n\r\nAlso, the section specifying how uni and bidi streams work have the 54 and 41 opposite from how they appear in the registration sections.",
          "createdAt": "2021-01-15T01:03:45Z",
          "updatedAt": "2021-01-15T01:03:45Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe the QUIC WG decided that TV frames were fine in extensions, but that we weren't going to use them in the core spec?  That being said, maybe the HTTP/3 draft should be updated to note this fact.\r\n\r\nGiven an unknown type is an immediate error condition and a length of 0 is a valid length for frames in general, I think TV is preferable.  Given this is not described in the core spec, it should be called out no matter how it's encoded on the wire.\r\n\r\nThanks for reminding me of stream types vs frame types.  The way the draft is written it's very easy to miss this distinction, so I think it's worth making that a bit clearer.",
          "createdAt": "2021-01-15T07:20:31Z",
          "updatedAt": "2021-01-15T07:24:35Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "You can't omit the length field, but we did discuss that 0-length would be fine on a per-frame definition basis.\r\n\r\nIn H3, unknown frames types are simply ignored. Nrgoyiation is not required to negotiate extensions that do not change H3 semantic.",
          "createdAt": "2021-01-15T11:34:28Z",
          "updatedAt": "2021-01-15T11:34:28Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The length issue was discussed at length on the issue: https://github.com/quicwg/base-drafts/issues/1885 and in Tokyo: https://github.com/quicwg/wg-materials/blob/master/interim-19-01/minutes.md#issue-1885data-frame-encoding-is-inefficient-for-long-dynamically-generated-bodies\r\n\r\nI thought the conclusion from Tokyo was that you could do this in an extension, but that's not particularly clear from the issue or minutes.  The discussion both on the issue and in person was fairly all over the place, so it's difficult to summarize.\r\n\r\nWe did make 0 a valid DATA length as part of this series of changes, which makes declaring it a special value now quite odd.",
          "createdAt": "2021-01-15T16:10:19Z",
          "updatedAt": "2021-01-15T16:10:19Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "I view it slightly differently, which is that the WebTransport Frame *is* zero length (has no payload), but it's effect is that it declares the remainder of the stream to be unframed.",
          "createdAt": "2021-01-15T17:05:25Z",
          "updatedAt": "2021-01-15T17:05:38Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can't say that I find that intuitive, so it definitely needs to be written up, but that accomplishes what I want, so it WFM.",
          "createdAt": "2021-01-15T17:13:13Z",
          "updatedAt": "2021-01-15T17:13:13Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I split off the TV vs TLV with 0 length question into https://github.com/vasilvv/webtransport/issues/26",
          "createdAt": "2021-01-27T20:01:33Z",
          "updatedAt": "2021-01-27T20:01:33Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Stream types were referred to as control stream types in older versions of HTTP/3 draft, hence the name.  I fixed this a while ago, so closing this.",
          "createdAt": "2021-03-05T16:04:45Z",
          "updatedAt": "2021-03-05T16:04:45Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU3OTUzOTkyMzE=",
      "title": "Are Type-Value frames usable in WebTransport",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/26",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I believe the QUIC WG decided that TV frames were fine in extensions, but that we weren't going to use them in the core spec?  Others disagreed with my recollection/understanding.\r\n\r\nSubsequent discussion from Lucas and Alan indicated that TV frames are not allowed in HTTP/3, but it is allowed to have a 0 length frame which indicated the rest of the stream was WebTransport data.  I'm not sure it matters, since either way a peer which doesn't understand the frame is going to parse the stream.  Those that skip the frame will start parsing another frame after it and the parser will enter an unknown state.  Similarly, the behavior for TV is going to be unexpected/unknown.\r\n\r\n_Originally posted by @ianswett in https://github.com/vasilvv/webtransport/issues/24#issuecomment-760704522_\r\n\r\n",
      "createdAt": "2021-01-27T19:55:20Z",
      "updatedAt": "2021-03-08T23:59:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "I had forgotten that at some point H3 removed the restriction on zero-length DATA frames.  That doesn't prevent an extension from frame using length 0 to indicate the remainder of the stream is unframed however.  I think my implementation would be  easier if we used 0 length, but I've made it work with TV frames and can live with it.\r\n\r\nAnother argument for having a length here is if this extension were to allow an optional header block or other variable length field at the beginning of a WT stream, there's currently no way to know how long it is.",
          "createdAt": "2021-03-03T15:03:31Z",
          "updatedAt": "2021-03-03T15:03:31Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 110.  General agreement in the room was that we don't need length at all, as any parser unaware of WebTransport frames would not be able to parse those streams correctly anyways.",
          "createdAt": "2021-03-08T23:59:10Z",
          "updatedAt": "2021-03-08T23:59:10Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU4MDA5ODc3NTc=",
      "title": "Draining WebTransport Sessions",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/27",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "An HTTP/3 server needs the ability to gracefully drain existing connections. For HTTP/3, this involves sending a GOAWAY frame indicating that future requests should use a new HTTP/3 connection. However, the behavior of GOAWAY is partially undefined with WebTransport sessions. \r\n\r\nAfter receiving a GOAWAY, the client is no longer able to make new CONNECT requests. This means that any new WebTransport sessions will need to use a new HTTP/3 connection. This is great.\r\n\r\nHowever, it's not clear how existing sessions should behave after receiving a GOAWAY frame. Are they prohibited from creating new streams? How does this interact with the stream ID sent in the GOAWAY frame? Should the application expose the receipt of a GOAWAY to start a shutdown process?",
      "createdAt": "2021-02-04T06:47:49Z",
      "updatedAt": "2021-03-05T15:32:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Thanks for opening this issue -- it's been on my mind as well. \r\n\r\nI think it's important that we think through all the graceful draining scenarios, including when there are multiple proxies between the WT client and server, and one of the proxies initiates the drain.\r\n\r\nWe already have a use-case which requires a session to be able to create new streams after the receipt of a connection level GOAWAY.  We've been exploring using a GOAWAY with MAXINT to signal the peer to stop creating new sessions, but continuing to all new streams within existing sessions.  I don't think this totally jives with the definition of GOAWAY in the H3 spec, and I don't think it would work if there were 3 or more intermediaries.\r\n\r\nWhat would happen if WebTransport defined a GOAWAY frame that could be sent on the CONNECT stream to signal the intent to drain a session, but not the connection?",
          "createdAt": "2021-02-04T17:16:03Z",
          "updatedAt": "2021-02-04T17:16:03Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should inform application of GOAWAY signal, and possibly add a GOAWAY on the CONNECT stream for intermediation between proxies.",
          "createdAt": "2021-03-05T15:32:13Z",
          "updatedAt": "2021-03-05T15:32:13Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWU4MDE3MDAzMDU=",
      "title": "Session Establishment Race",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/28",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> From the client's perspective, a WebTransport session is established when the client receives a 200 response. From the server's perspective, a session is established once it sends a 200 response. Both endpoints MUST NOT open any streams or send any datagrams on a given session before that session is established.\r\n\r\nAfter the client initiates the WebTransport session by sending a CONNECT request, the server sends a 200 response and is free to create streams. This means that a server-initiated stream may arrive prior to the CONNECT response. Is the client able to infer that the session was successfully established, or does the client need to buffer this stream until it receives a proper response?",
      "createdAt": "2021-02-04T23:01:59Z",
      "updatedAt": "2021-03-09T00:00:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Since there are no ordering guarantees across streams on the receiver side, I'd say you have to buffer until the 200 is processed.",
          "createdAt": "2021-02-04T23:18:23Z",
          "updatedAt": "2021-02-04T23:18:23Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with Lucas here.  We also had a similar problem in QuicTransport (server has to buffer streams before checking the origin), and we handled it by buffering.",
          "createdAt": "2021-03-05T15:36:49Z",
          "updatedAt": "2021-03-05T15:36:49Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 110.  There were no objections to buffering (with some limits), so I think we should go ahead and add it.",
          "createdAt": "2021-03-09T00:00:48Z",
          "updatedAt": "2021-03-09T00:00:48Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWU4MDE3MTAxMDE=",
      "title": "Session Establishment Round Trips",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/29",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "For a simple application that wants to send \"hello world\" over a WebTransport stream, it would take a minimum of 2.5 round trips for the data to arrive on the server. This is still an improvement over WebSockets but I'm wondering if we could do better.\r\n\r\n> From the client's perspective, a WebTransport session is established when the client receives a 200 response. From the server's perspective, a session is established once it sends a 200 response. Both endpoints MUST NOT open any streams or send any datagrams on a given session before that session is established.\r\n\r\nIf the client is able to create streams prior to receiving the CONNECT response, then it would remove a round trip. The server would need to buffer any data received on streams associated with an unknown WebTransport session. If the server responds with a non-200 status code, then these streams are discarded.\r\n\r\n> WebTransport over HTTP/3 does not support 0-RTT.\r\n\r\nI believe 0-RTT is disabled for WebTransport because CONNECT is not idempotent and would be subject to replay attacks. An idempotent CONNECT would remove a round trip when 0-RTT is used... although I'm not sure this is a good idea.",
      "createdAt": "2021-02-04T23:21:57Z",
      "updatedAt": "2021-03-09T00:00:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "> If the client is able to create streams prior to receiving the CONNECT response, then it would remove a round trip. The server would need to buffer any data received on streams associated with an unknown WebTransport session. If the server responds with a non-200 status code, then these streams are discarded.\r\n\r\nI think this is a reasonable optimization",
          "createdAt": "2021-02-04T23:25:58Z",
          "updatedAt": "2021-02-04T23:25:58Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "The client requirement is odd in comparison to MASQUE / CONNECT-UDP which says \"client can risk sending datagrams before getting a 200 response, a different response means that datagrams will be discarded\". \r\n\r\nWhat is the motivation for the requirement in WebTransport? If you need some kind of ordering guarantees, then stream IDs provide that.",
          "createdAt": "2021-02-04T23:28:01Z",
          "updatedAt": "2021-02-04T23:28:01Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 110.  There were no objections to buffering (with some limits), so I think we should go ahead and add it.",
          "createdAt": "2021-03-09T00:00:55Z",
          "updatedAt": "2021-03-09T00:00:55Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWU4MTI1MDYzNTc=",
      "title": "Section 4.4: Path MTU computation",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/30",
      "state": "OPEN",
      "author": "aboba",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "From Section 4.4: \r\n\r\n\"TODO: Describe how the path MTU can be computed, specifically propagation across HTTP proxies.\"",
      "createdAt": "2021-02-20T03:54:47Z",
      "updatedAt": "2021-02-20T03:54:47Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 31,
      "id": "MDU6SXNzdWU4MTQwNzM0Mjg=",
      "title": "Ambiguous RESET_STREAM",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/31",
      "state": "OPEN",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "If a peer receives a RESET_STREAM message before it receives the first few bytes of the stream, then it is unable associate the RESET_STREAM with a protocol or session. This can occur if the STREAM packet is lost but the RESET_STREAM is not.\r\n\r\nAs a consequence, if a WebTransport client closes a stream with an error code, then it's not guaranteed to be received by the server. Worse yet, a reset client-initiated bidirectional stream may be confused for a HTTP/3 request and cause intended consequences.",
      "createdAt": "2021-02-23T03:49:41Z",
      "updatedAt": "2021-02-24T18:16:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Can you give a more concrete example of when this is a problem?\r\n\r\nYou are saying the client opened a unidirectional or bidirectional WT stream, sent some data, then reset it.  The server receives only the reset, or some fraction of the data but not enough to figure out which session the stream belongs to.  I think this is fine and the server just discards any partial data on this stream.\r\n\r\nIf the application needs to receive the data (even just an error code) in the stream, then the client shouldn't reset it, but instead, send some application level close signal that is delivered reliably on the stream.\r\n\r\nI don't see how an H3 server could act on any stream data from the client without seeing the beginning of the stream, so I don't think there's much concern about this being served as an H3 request.",
          "createdAt": "2021-02-23T16:37:50Z",
          "updatedAt": "2021-02-23T16:37:50Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "Sure. I suppose the problem is the reliable delivery of error codes. \r\n\r\nIf the application closes a stream with an integer code via the [WebTransport API](https://w3c.github.io/webtransport/#dom-outgoingstream-abortwriting), then I would expect that code to be reliably delivered to the other peer. This ambiguous RESET_STREAM case opens the possibility of the code not being associated with a WebTransport session, and thus not delivered, depending on packet loss.",
          "createdAt": "2021-02-23T19:14:15Z",
          "updatedAt": "2021-02-23T19:14:15Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Iiuc the problem is if the stream is reset before the Web Transport frame is processed (as far the *current* spec says). That frame associates the stream to the web transport session. A peer that receives the RESET_STREAM know something was cancelled but not whether it was a normal request or a webtransport stream. \r\n\r\nThis highlights a challenge with retconning what bidirectional streams mean for a H3 stack. ",
          "createdAt": "2021-02-23T19:23:23Z",
          "updatedAt": "2021-02-23T19:23:23Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "I can construct an application where it's important that the peer knows about every stream that gets created, even if it is reset before anything interesting happens, but it strikes me as a bit fringy.  Can you give a concrete example where the WT endpoint missing the reset stream entirely is problematic?",
          "createdAt": "2021-02-23T19:30:07Z",
          "updatedAt": "2021-02-23T19:30:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "The only example I can think of relates to session pooling and wanting different concurrency limits in sessions. Since we decided to focus on single sessions for now, my example I'd moot. I'd be interested to know Luke's example ",
          "createdAt": "2021-02-23T19:38:44Z",
          "updatedAt": "2021-02-23T19:38:44Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "> I can construct an application where it's important that the peer knows about every stream that gets created, even if it is reset before anything interesting happens, but it strikes me as a bit fringy. Can you give a concrete example where the WT endpoint missing the reset stream entirely is problematic?\r\n\r\nIronically, the best example is an application implementing a replacement for MAX_STREAMS. Peers can't set a cumulative limit if they disagree on the number of streams created. ex. peer A creates and resets a stream, so it thinks 10 have been created in total, but packet loss could cause peer B to think only 9 have been created in total. This can eventually cause a deadlock.\r\n\r\nAnd yeah, it's pretty easy to imagine an application that uses stream resets. The WebTransport API makes stream closure seem reliable, when really there's a small chance that it gets silently dropped.",
          "createdAt": "2021-02-23T23:15:01Z",
          "updatedAt": "2021-02-23T23:16:03Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "This seems like another case of where a \"session layer\" over QUIC would assist. The trouble is, in my limited understanding of the W3C WebTransport API, that it wants to use a QUIC transport feature to manage WebTransport sessions. It is going to be let down by the fact the transport behaves differently than it wishes. \r\n\r\ndraft-ietf-webtrans-http3-00 defines the WEBTRANSPORT_STREAM HTTP/3 frame for initiating WebTransport streams. So it probably needs an equivalent frame for closing WebTransport streams. This could be sent on the stream itself, on a new \"webtransport session control stream\", or on the global control stream.",
          "createdAt": "2021-02-24T00:15:52Z",
          "updatedAt": "2021-02-24T00:15:52Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "> This could be sent on the stream itself, on a new \"webtransport session control stream\", or on the global control stream.\r\n\r\nBy 'on the stream itself', do you mean on the CONNECT stream that established the session?  The current draft disables framing on WT streams.  It could be a message like QPACK, where streams that are cancelled have an application level signal.",
          "createdAt": "2021-02-24T17:00:32Z",
          "updatedAt": "2021-02-24T17:00:32Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "> By 'on the stream itself', do you mean on the CONNECT stream that established the session?\r\n\r\nNo. If I understand (and that's a big if) the design of draft-ietf-webtrans-http3-00 requires\r\n\r\nstep 1) use extended  CONNECT on client bidi stream to create a WebTransport session\r\n\r\nstep 2) create WebTransport stream on different client bidi stream using WEBTRANSPORT_STREAM frame https://tools.ietf.org/html/draft-ietf-webtrans-http3-00#section-4.2\r\n\r\nMy suggestion wasn't about retiring WebTransport sessions, but retiring streams robustly at the application layer. If you created a stream using an H3 frame, retire it with an H3 frame.\r\n\r\nAlthough we adopted draft-ietf-webtrans-http3-00, I;m not sure how much of the design is appropriate/relevant to the non-pooling constraints we have added. So i guess my current understanding could be subject to change.",
          "createdAt": "2021-02-24T17:07:53Z",
          "updatedAt": "2021-02-24T17:07:53Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "The current draft uses a 'TV' frame on streams created in step 2) that makes sending additional frames on those streams impossible.  I'm suggesting we could use the stream created in step 1) as a \"webtransport session control stream\", if needed.",
          "createdAt": "2021-02-24T18:11:58Z",
          "updatedAt": "2021-02-24T18:11:58Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Ah yes, I overlooked that. In that case I agree",
          "createdAt": "2021-02-24T18:16:09Z",
          "updatedAt": "2021-02-24T18:16:09Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWU4MjEzMjUzNjc=",
      "title": "Specify behavior when receiving a bad session ID",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/32",
      "state": "OPEN",
      "author": "afrind",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The H3 draft is light on error handling guidance.  There are number of cases for bad session IDs:\r\n\r\n1. The session ID is not a client initiated bidirectional stream ID\r\n2. The session ID refers to a stream that did not perform a WebTransport handshake\r\n3. The session ID refers to a stream that has been closed or reset\r\n\r\nPresumably there is no error when a DATAGRAM arrives with a bad session id -- you just drop it?\r\n\r\nFor streams, perhaps HTTP_ID_ERROR is appropriate?\r\n\r\nIssues #28 and #29 both refer to cases where you receive a session ID that has not been created yet.  Best to keep the discussion there, but it's likely we want to allow clients/servers to buffer some of these at their own discretion rather than require an error.",
      "createdAt": "2021-03-03T17:29:06Z",
      "updatedAt": "2021-03-03T17:29:06Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWU4MjIyMjk3MzU=",
      "title": "Should WT streams be reset when the CONNECT stream terminates",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/33",
      "state": "OPEN",
      "author": "afrind",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft currently states:\r\n\r\n> Upon learning about the session being terminated, the endpoint MUST stop sending new datagrams and reset all of the streams associated with the session.\r\n\r\nIt's clear that without a CONNECT stream that new streams cannot be created and datagrams cannot be sent, but WT streams that were opened for that session could continue operating normally.  This is how push streams are handled in H2 and H3 -- the push stream continues even if the associated stream is terminated.\r\n\r\nAn endpoint always has the option to reset/stop sending WT streams when the session terminates.\r\n\r\nThis is somewhat related to the graceful drain issue (#27)",
      "createdAt": "2021-03-04T15:17:59Z",
      "updatedAt": "2021-03-09T00:02:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 110.  We should keep the current behavior for now, and revisit once we have more implementation experience.",
          "createdAt": "2021-03-09T00:02:08Z",
          "updatedAt": "2021-03-09T00:02:08Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWU4MjIzMzYwMjk=",
      "title": "Negotiation of pooling support",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/34",
      "state": "OPEN",
      "author": "afrind",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The H3 draft by its nature allows for the parallel processing of multiple WT sessions and also the intermixing of normal H3 request with WT.  Server endpoints may wish to negotiate or disable this behavior.  Clients can simply choose not to do either kind of pooling if they don't want to.\r\n\r\nThere's already a PR open (#25) with a design idea.",
      "createdAt": "2021-03-04T17:16:48Z",
      "updatedAt": "2021-03-23T11:46:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "I'd like to propose a different model than the one in #25:\r\n\r\nThe server sends the maximum WebTransport Session ID, or since 0 is a valid value, it's really the minimum invalid WebTransport Session ID.\r\n\r\nTo indicate WT is not supported, server sends 0.\r\nTo allow for only 1 session ever, server sends 4, and never updates it.\r\nTo allow for only 1 session *at a time*, server sends 4, and updates it by 4 as each session closes/resets.\r\nTo allow for N parallel sessions, server sends 4 * N. and updates as sessions close/reset.\r\n\r\nThis mirrors H3 PUSH, and requires at least one more frame (MAX_WT_SESSION_ID).  Perhaps it would also require CANCEL_WT_SESSION?\r\n\r\nA client need only declare that it supports webtransport, and even that could be optional.  The server will know if it receives a CONNECT with :protocol=webtransport.",
          "createdAt": "2021-03-04T17:18:30Z",
          "updatedAt": "2021-03-04T17:18:30Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I wanted to have a negotiation mechanism in #25, but my conclusion after talking with @DavidSchinazi about it was that we should not do negotiation, and servers should just reject extra streams with a 400 (or maybe even a RESET_STREAM) if they ever see more sessions than they expect; meaning it's on the clients to know if they can pool or not.",
          "createdAt": "2021-03-05T17:03:25Z",
          "updatedAt": "2021-03-05T17:03:25Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Though we may want a more specific 4XX error code so the client knows it should retry in a non-pooled connection",
          "createdAt": "2021-03-05T17:35:23Z",
          "updatedAt": "2021-03-05T17:35:23Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "That's certainly a lot simpler than session credits ;)  The cost of at least an RTT for a client that tries to pool against a server that can't handle it seems somewhat high.  I guess it depends what the common client pooling strategies are and how many servers don't support pooling.",
          "createdAt": "2021-03-05T17:42:02Z",
          "updatedAt": "2021-03-05T17:42:02Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind since it's looking like the JavaScript API will provide a way to disable pooling, I expect that the scenario of pooling-attempted-but-rejected will be quite rare, so a round trip cost should be acceptable",
          "createdAt": "2021-03-05T18:33:56Z",
          "updatedAt": "2021-03-05T18:33:56Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "I'm also considering use cases for WT which are not tied to the JS API.",
          "createdAt": "2021-03-05T18:36:47Z",
          "updatedAt": "2021-03-05T18:36:47Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind that's interesting - and those use-cases won't have a similar mechanism to disable pooling? I suspect they'll need a way to get the WT server's hostname somehow, and having config properties attached to that (such as disable_pooling) could be useful?",
          "createdAt": "2021-03-05T20:47:02Z",
          "updatedAt": "2021-03-05T20:47:02Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "@DavidSchinazi : the opposite -- the clients may attempt pooling to servers that might or might not support it.  You can't tell from a hostname if it supports pooling.",
          "createdAt": "2021-03-06T00:26:18Z",
          "updatedAt": "2021-03-06T00:26:18Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind how did the client get the hostname in the first place? I'm suggesting to carry pooling_support next to that.",
          "createdAt": "2021-03-06T00:36:49Z",
          "updatedAt": "2021-03-06T00:36:49Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Actually, let's go back to JS for a second.  The people who write JS at Facebook are very unlikely to know if the edge server terminating their connection supports pooling, or that configuration could change over time.",
          "createdAt": "2021-03-06T00:47:25Z",
          "updatedAt": "2021-03-06T00:47:25Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "(I appreciate the irony of me saying this as a Googler, but) should the JS people talk to the edge people? I agree that this shouldn't fail, but it being inefficient seems reasonable - these teams should talk if they're trying to reach good performance.",
          "createdAt": "2021-03-06T01:33:08Z",
          "updatedAt": "2021-03-06T01:33:08Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I think my main problem with `MAX_WT_SESSION_ID` is that most people who want to disallow pooling want to exclude not only other WebTransport sessions, but also general HTTP traffic.  #25 was written with that assumption in mind.",
          "createdAt": "2021-03-06T20:15:45Z",
          "updatedAt": "2021-03-06T20:15:45Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "Ok, MAX_WT_SESSION_ID doesn't handle that case, so it may be an over-engineered solution to the wrong problem.\r\n",
          "createdAt": "2021-03-08T15:32:01Z",
          "updatedAt": "2021-03-08T15:32:01Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "As I said in the meeting, I don't think that we should have any signals for dedicated connections from either client or server.\r\n\r\nYutaka made the point that the client can decide to make a connection dedicated after seeing the server settings.  It doesn't need to signal its intent (and signaling would have negative privacy consequences potentially).  I agree with this observation.\r\n\r\nA server needs to support HTTP if we're using HTTP.  So pooling with h3 is already a settled matter.  If the server doesn't want to answer requests, it can use 406 or 421 or other HTTP mechanisms to tell the client to go away.  More generally, the server can just not provide links to that server, such that it might have to respond to GET/OPTIONS/POST/etc.  The question then becomes managing resource limits on the server.  Having a way to limit the number of WebTransport sessions is a good thing and I believe that will be sufficient for this.\r\n\r\nThus, I'm a supporter of option 3: MAX_WT_SESSIONS or similar.",
          "createdAt": "2021-03-08T17:47:15Z",
          "updatedAt": "2021-03-09T11:19:24Z"
        },
        {
          "author": "ddragana",
          "authorAssociation": "NONE",
          "body": "I agree that we should have limits of how many WT can be active at the same time on a connection. It should also define what happens if the limit is exceeded. Should a client open another QUIC connection to the same server or should it fail? Probably it should be former, but that should also have limits defined (6 parallel QUIC connection, may be too much? HTTP/1.1 have the 6 parallel connection limit). ",
          "createdAt": "2021-03-23T11:46:06Z",
          "updatedAt": "2021-03-23T11:46:06Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWU4MjIzNjEyMzg=",
      "title": "Alignment with MASQUE/CONNECT-UDP",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/35",
      "state": "OPEN",
      "author": "afrind",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "If you ignore WebTransport streams, then the base functionality of WebTransport and CONNECT-UDP+H3 DATAGRAM is virtually identical:\r\n\r\n1. Client sends a HTTP/3 CONNECT(-UDP) request to establish a session, with a unique identifier\r\n2. The lifetime of that stream establishes the lifetime of the session\r\n3. The endpoints can exchange DATAGRAMS using the session ID as the flow ID\r\n\r\nGranted there are important differences -- CONNECT-UDP has particular semantics for the receiver, and needs mechanisms for transport level extensions.  I don't think they can be completely consolidated or factored out.\r\n\r\nNegotiation and pooling support look different at this point -- there doesn't seem to be active discussion that a server endpoint should limit the number of open CONNECT-UDP sessions, or how they can be multiplexed with standard H3, but in WT it's more controversial.\r\n\r\nAre there any opportunities for better alignment here?",
      "createdAt": "2021-03-04T17:49:56Z",
      "updatedAt": "2021-03-04T19:01:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind what do you mean by better alignment? In what way are CONNECT_UDP and WT3 not aligned?",
          "createdAt": "2021-03-04T18:16:09Z",
          "updatedAt": "2021-03-04T18:16:09Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "@DavidSchinazi : Mostly around feature negotiation and pooling support.",
          "createdAt": "2021-03-04T18:17:30Z",
          "updatedAt": "2021-03-04T18:17:30Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "The Session ID/Flow ID assignment is also different.  The MASQUE approach strikes me overkill in WT, so I'm not sure we'd want to use the same mechanism for both.",
          "createdAt": "2021-03-04T18:19:26Z",
          "updatedAt": "2021-03-04T18:19:26Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding pooling, I think that is completely specific to WT3. I don't see value in controlling the ability to pool CONNECT-UDP more than we have the ability to control pooling of CONNECT or even GET. Do you have a use-case for this?\r\n\r\nRegarding feature negotiation, don't they both use HTTP headers?",
          "createdAt": "2021-03-04T18:19:46Z",
          "updatedAt": "2021-03-04T18:19:46Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding Session ID, since WT3 needs a Datagram Flow ID regardless, I'd suggest using that as the Session ID for simplicity.",
          "createdAt": "2021-03-04T18:20:38Z",
          "updatedAt": "2021-03-04T18:20:38Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "@DavidSchinazi : \r\n\r\nre: pooling: it's just a bit strange to have the divergence between MASQUE (no need to limit pooling) and WT (must have strict limits on pooling).  Why is this?\r\n\r\nre: feature negotiation: I was referring to different SETTINGs/negotiation strategy up front rather than the session establishment.  CONNECT+headers is fine.\r\n\r\nre: session ID: why does WT3 need a flow-id?  It would only need one if it uses \"H3 DATAGRAM\" but right now it's using QUIC DATAGRAM.  I'm not sure H3 DATAGRAM brings much value to WT right now, but this is a good example of where we should either align, or perhaps document why we are not aligned.",
          "createdAt": "2021-03-04T18:26:32Z",
          "updatedAt": "2021-03-04T18:26:32Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding pooling, I think WT3 is diverging from all other HTTP semantics here, not just CONNECT-UDP. I don't see why CONNECT-UDP should diverge from GET because WT3 is diverging from GET.\r\n\r\nRegarding negotiation, WT3 needs a SETTING because it changes HTTP/3 semantics (e.g., the semantics of server-initiated bidirectional streams) whereas CONNECT-UDP doesn't change HTTP/3 semantics. Note that H3-DGRAM has a SETTING because it changes the semantics of the DATAGRAM frame in h3 connections.\r\n\r\nRegarding datagram flow ID, WT3 needs a datagram flow ID in order to support multiplexing with other h3 datagram traffic, such as CONNECT-UDP. If we want WT3 to support pooling with other HTTP/3 methods (even if that's optional and disabled by default), we'll need a datagram flow ID.",
          "createdAt": "2021-03-04T18:37:08Z",
          "updatedAt": "2021-03-04T18:37:08Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "> Regarding datagram flow ID, WT3 needs a datagram flow ID in order to support multiplexing with other h3 datagram traffic, such as CONNECT-UDP. If we want WT3 to support pooling with other HTTP/3 methods (even if that's optional and disabled by default), we'll need a datagram flow ID.\r\n\r\nAh - if you want to multiplex WT with any *other* HTTP/3 traffic that uses H3 DATAGRAMs, then you could have collisions with Flow-IDs.  We should open a separate issue for this.",
          "createdAt": "2021-03-04T19:01:41Z",
          "updatedAt": "2021-03-04T19:01:41Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "MDU6SXNzdWU4MjIzNzA1OTU=",
      "title": "Session layer resource management",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/36",
      "state": "OPEN",
      "author": "afrind",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "pooling"
      ],
      "body": "QUIC manages resources, specifically streams and flow control, at the transport layer.  Since the H3 draft allows pooling, those mechanisms may be inadequate in cases where WT sessions are multiplexed with each other or standard H3.\r\n\r\nThere are two issues open tracking some different bits of this (#22/Flow Control) and (#31/~Streams), this issue is tracking whether we need to solve that by adding functionality at the WT session layer.   #27 tracks the interpretation of GOAWAY and this could also be a session level concept.\r\n\r\nThis might look like a set of frames for granting stream and flow control credit, which would presumably be a subset of the QUIC transport credit.\r\n\r\nSome arguments against this:\r\n\r\n1. Endpoints that require the resource management features of the transport can disable pooling and fall back to the transport for these.\r\n2. These problems already exist in clients that pool HTTP connections to the same server between different applications (eg: browser tabs) that are generally unaware of each other.\r\n3. \"complexity\"",
      "createdAt": "2021-03-04T18:02:26Z",
      "updatedAt": "2021-03-05T17:22:16Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU4MjI0MTU2Njk=",
      "title": "QUIC DATAGRAM vs H3 DATAGRAM",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/37",
      "state": "OPEN",
      "author": "afrind",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "WT currently uses QUIC DATAGRAMS (eg: no Flow-Id), and does it's own demultiplexing via the session ID.  This is incompatible with multiplexing other applications that use H3 DATAGRAMs, since the Flow-ID could collide with the session ID, depending on how it is chosen.\r\n\r\nThere was some discussion of this already in a PR on victor's repo: https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/21#discussion_r520160334",
      "createdAt": "2021-03-04T19:05:23Z",
      "updatedAt": "2021-03-05T17:24:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "We should use whatever H3 DATAGRAM draft decides in order to be able to coexist with MASQUE.  I've mostly not updated the draft because I don't think there is an exact consensus for H3 DATAGRAM on the exact approach.",
          "createdAt": "2021-03-05T17:24:37Z",
          "updatedAt": "2021-03-05T17:24:37Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWU4MjM3MzA4MTU=",
      "title": "URI scheme identifying WebTransport over HTTP",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/38",
      "state": "OPEN",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We need to pick one.  The main two options are `https:` and `wt:`.\r\n\r\nWe've discussed this separately within W3C (see w3c/webtransport#198), and the conclusion there was that it would make more sense to just use `https:` URIs.  We should discuss this at the upcoming IETF meeting.",
      "createdAt": "2021-03-06T19:40:57Z",
      "updatedAt": "2021-03-09T00:02:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "(No hats) I think using https would be the simplest option here, so I'd be inclined to go with that",
          "createdAt": "2021-03-06T21:57:08Z",
          "updatedAt": "2021-03-06T21:57:08Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 110.  Consensus in the room was for using `https:`.",
          "createdAt": "2021-03-09T00:02:37Z",
          "updatedAt": "2021-03-09T00:02:37Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWU4NDI1MDI3MTY=",
      "title": "SETTINGS_ENABLE_WEBTRANSPORT from the client",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/39",
      "state": "OPEN",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "How necessary is to wait for SETTINGS_ENABLE_WEBTRANSPORT from the client?  If we are a server, and we receive a request with `:protocol` set to `webtransport`, this seems like a pretty solid indication of support.  From the current language in the draft, though, the server has to pause the processing of the request in question until the SETTINGS are there (which is really annoying to implement).\r\n\r\nOne counterpoint I can see is that we could use settings to negotiate a specific version of WebTransport over HTTP/3, and in that case we *do* need to wait for settings from both parties.",
      "createdAt": "2021-03-27T13:18:06Z",
      "updatedAt": "2021-03-27T18:19:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I really do not like the idea of delaying the processing of requests on the server side, as it seems bug/attack prone.\r\n\r\nGiven the client has to initiate the webtransport session, and there's no guarantee the client's SETTINGs will arrive before the servers(without something like ALPS), why not only have the server send the setting?  For example, websockets in H2 only requires a setting from server to client.",
          "createdAt": "2021-03-27T15:08:33Z",
          "updatedAt": "2021-03-27T15:08:33Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "One tricky thing here is that whatever we do here, it has to also work with the H3_DATAGRAM setting.",
          "createdAt": "2021-03-27T16:40:20Z",
          "updatedAt": "2021-03-27T16:40:20Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd suggest adding some requirements like:\r\n1) The server MUST indicate support for both WebTransport and H3 datagram, or the connection MUST be closed.\r\n2) The server MUST assume that if the client uses protocol \"webtransport\", that it supports both WebTransport and H3 datagram, and sending the SETTING is optional.\r\n\r\nBut you make a good point that this could crop up in CONNECT-UDP and a few other uses of H3-Datagram.  If the client is always responsible for initiating the datagram flow(s), then the SETTING for h3-datagram only needs to be sent server to client.",
          "createdAt": "2021-03-27T18:16:00Z",
          "updatedAt": "2021-03-27T18:19:10Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWU4NDQ4MDE3NDY=",
      "title": "RESET_STREAM error codes",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/40",
      "state": "OPEN",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If we are going to let the API users supply their own stream reset code, we should figure out how this is represented on the wire.  We could potentially use the error codes as-is and say they mean different things for WebTransport streams than what they mean for normal streams, but I am not sure this is sound as we don't always know that a stream is a WebTransport stream at the time we process the reset (also this sounds like a pain to implement).\r\n\r\nOne possibility would be to reserve a block within HTTP/3 error code space.  However, since HTTP/3 error codes contain GREASE code-points throughout, we might end up having to \"de-grease\" and \"re-grease\" them as the largest continuous block only has 255 codepoints available.\r\n\r\nAlternatively, if we decide to just send RESET_STREAM as a part of CONNECT stream due to issues in #31, we could just send the error code there, and keep one single code for user-initiated termination.\r\n\r\nWhatever we decide here should probably work for H/2 as well.\r\n\r\ncc @martinthomson",
      "createdAt": "2021-03-30T16:06:50Z",
      "updatedAt": "2021-03-31T00:50:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Are application developers asking for custom reset error codes? Making reset unreliable and non-customizable would be much easier if that's sufficient for everyone's needs.",
          "createdAt": "2021-03-30T16:09:20Z",
          "updatedAt": "2021-03-30T16:09:20Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Reset error codes are special in the sense that they are reliably delivered by the transport (unlike the data, which all can be lost to a reset).  So I imagine an application would want to be able to tell apart a regular reset (e.g. due to stream TTL expiring), vs reset due to an error.\r\n\r\n@kixelated might have opinions on this, since he filed #31.",
          "createdAt": "2021-03-30T16:24:22Z",
          "updatedAt": "2021-03-30T16:24:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "We went through a concerted effort to reduce the number of H3 error codes. Partly because knowing when to use the right code (from an implementation persepctive) can be hard. \r\n\r\nH2's space is small, I don't know if the experts would allow one application to reserve a large block.\r\n\r\nAt a minimum we probably need a WEBTRANS_NO_ERROR. Maybe there are some error codes for \"Web transport wire protocol error\". Anticipating more specific error codes for apps using webtransport is hard. Some motivating use cases might help. ",
          "createdAt": "2021-03-30T16:58:48Z",
          "updatedAt": "2021-03-30T16:58:48Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> H2's space is small, I don't know if the experts would allow one application to reserve a large block.\r\n\r\nIt's 32-bit, so I think we could probably get 16 bits worth of error codes.",
          "createdAt": "2021-03-30T17:36:54Z",
          "updatedAt": "2021-03-30T17:36:54Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Ah quire right, I was getting mixed up with frame type which is 8 bits. But still, reserving half the code points for one usage of H2 seems overboard. \r\n\r\nGiven that H2 suffices with about a dozen error codes I really wonder what WebTransport thinks it can achieve by using so many. Maybe the ask is for a \"retire stream with a status\"? In which case an alternate design would be to add a control frame for webstransport that contains your own space or possibly a reason phrasr and then a generic error code such as WEBTRANS_STREAM_ABORT to disambiguate it from other H3 errors.",
          "createdAt": "2021-03-30T17:50:25Z",
          "updatedAt": "2021-03-30T17:50:25Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's 1/65536th of the error space, not 1/2.\r\n\r\nWebTransport *by itself* does not need that many error codes (I have so far three or four in the code that I will write a PR as soon as I'm done); the question here is what do applications running on top of it want.",
          "createdAt": "2021-03-30T17:59:59Z",
          "updatedAt": "2021-03-30T17:59:59Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "The [JS API](https://w3c.github.io/webtransport/#web-transport-close-info) exposes connection error codes, so it's something the transport would need to support. I think removing them would be a W3C conversation.\r\n\r\nActually for my application, we wanted to signal when the connection was terminated gracefully versus an unexpected error. We tried using CONNECTION_CLOSE with application error codes but the QuicTransport implementation in Chrome always raised \"Connection Lost\" regardless of the code. We had to resort to making a new stream and our own, high priority message when the connection was closed. This also meant waiting for the message to be acknowledged before actually closing the connection, otherwise the message would be lost.\r\n\r\nSo yeah, I think immediately closing a connection with an error code is useful functionality, hence why it's in QUIC as well.",
          "createdAt": "2021-03-30T18:22:01Z",
          "updatedAt": "2021-03-30T18:22:01Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Would it work to just defer that the registration to applications over WebTransport? I appreciate it's nice to have a contiguous block but there's hardly much churn in that registry and I don't know what practical benefit a contiguous range adds for distinct uses of WebTransport. I'm confused if you're attempting to reserve a block that is then allocated via some sub-protocol negotiation, or if you intend to run a registration scheme inside your reserved block. Or something else.",
          "createdAt": "2021-03-30T18:23:09Z",
          "updatedAt": "2021-03-30T18:23:09Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Are you suggesting that we should let WebTransport applications send arbitrary HTTP/3 error codes?  That could work, but I am not sure what are the security consequences of that.  If we only reserve a block, the error codes outside of that block are \"privileged\", i.e. only the browser (but not the untrusted web application) can send them.",
          "createdAt": "2021-03-30T18:26:27Z",
          "updatedAt": "2021-03-30T18:26:27Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "That's a good point and puts more weight behind reserving a block that can only be used by the WebTransport API. ",
          "createdAt": "2021-03-30T18:39:46Z",
          "updatedAt": "2021-03-30T18:39:46Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@kixelated could you elaborate on how your application reacts differently to graceful termination of a stream vs unexpected error? I'm just curious to know what you use this for.",
          "createdAt": "2021-03-30T20:49:02Z",
          "updatedAt": "2021-03-30T20:49:02Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "> @kixelated could you elaborate on how your application reacts differently to graceful termination of a stream vs unexpected error? I'm just curious to know what you use this for.\r\n\r\nSure, we're doing live video streaming. We want to distinguish when the connection is closed because the live stream has ended (show an \"thanks for watching\" screen), versus an unexpected error (show an error screen with debug code).",
          "createdAt": "2021-03-30T21:04:39Z",
          "updatedAt": "2021-03-30T21:04:39Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Makes sense, though this is for an entire session (see #41).  Here we're discussing individual streams.",
          "createdAt": "2021-03-30T21:16:30Z",
          "updatedAt": "2021-03-30T21:16:30Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "I'm finding the mention of CONNECTION_CLOSE slightly confusing since this thread is about stream resets. \r\n\r\nThe JS API doesn't mention if CONNECTION_CLOSE is a transport-level or application-level close, it really should. \r\n\r\nThe HTTP-based WebTransports support graceful connection close via GOAWAY.\r\n\r\nApplications built on WebTransport might be able to harness these properties, or they might need to create a control channel per session that could then behave exactly how they want, without the overhead of IETF registries.\r\n\r\n",
          "createdAt": "2021-03-30T21:19:38Z",
          "updatedAt": "2021-03-30T21:19:38Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "Oh sorry, for some reason I thought this was for the entire connection.\r\n\r\nResetting a stream with an error code is less useful, but again it's in the [JS API](https://w3c.github.io/webtransport/#dom-outgoingstream-abortwriting). RESET_STREAM is useful for my application because the streams transfer a large amount of data, which may be blocked on the network, but I don't have a use-case for application error codes at the moment.",
          "createdAt": "2021-03-30T21:38:43Z",
          "updatedAt": "2021-03-30T21:39:38Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "Just to close the loop here.  We talked about this in the context of W3C and decided that we'd like to have some number of error code points just for web transport.  256 was the initial suggestion; 100 might work; 31 was considered too small.  @DavidSchinazi pointed out that we can play FizzBuzz and step carefully around the reserved greasing points so that a contiguous block is presented to applications even if the underlying code points are not contiguous.",
          "createdAt": "2021-03-31T00:34:45Z",
          "updatedAt": "2021-03-31T00:34:45Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "FWIW, where I said\r\n\r\n> The JS API doesn't mention if CONNECTION_CLOSE is a transport-level or application-level close, it really should.\r\n\r\nthere is already an issue for it https://github.com/w3c/webtransport/issues/80",
          "createdAt": "2021-03-31T00:50:51Z",
          "updatedAt": "2021-03-31T00:50:51Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWU4NDUyODA1MjY=",
      "title": "Error codes for closing the session",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/41",
      "state": "OPEN",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Since the API was based off QuicTransport, the API document currently has a method to close the session, with both an error code and a reason string (modeled off QUIC CONNECTION_CLOSE): <https://w3c.github.io/webtransport/#web-transport-close-info>.\r\n\r\nWe could attempt to reset the CONNECT stream, but that would imply that it's always reset, and will not let us supply a reason string.  I think the easiest way would be to send trailers on the CONNECT stream.",
      "createdAt": "2021-03-30T21:15:26Z",
      "updatedAt": "2021-04-01T16:39:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "If we want to allow trailers (or any non DATA frames) on the CONNECT stream, we need to add text allowing that.\r\n\r\nFrom the H3 spec:\r\n\r\nOnce the CONNECT method has completed, only DATA frames are permitted to be sent on the stream.  Extension frames MAY be used if specifically permitted by the definition of the extension.\r\n\r\n\r\nFrom: Victor Vasiliev ***@***.***>\r\nReply-To: ietf-wg-webtrans/draft-ietf-webtrans-http3 ***@***.***>\r\nDate: Tuesday, March 30, 2021 at 2:15 PM\r\nTo: ietf-wg-webtrans/draft-ietf-webtrans-http3 ***@***.***>\r\nCc: Subscribed ***@***.***>\r\nSubject: [ietf-wg-webtrans/draft-ietf-webtrans-http3] Error codes for closing the session (#41)\r\n\r\n\r\nSince the API was based off QuicTransport, the API document currently has a method to close the session, with both an error code and a reason string (modeled off QUIC CONNECTION_CLOSE): https://w3c.github.io/webtransport/#web-transport-close-info<https://w3c.github.io/webtransport/#web-transport-close-info>.\r\n\r\nWe could attempt to reset the CONNECT stream, but that would imply that it's always reset, and will not let us supply a reason string. I think the easiest way would be to send trailers on the CONNECT stream.\r\n\r\n\u2014\r\nYou are receiving this because you are subscribed to this thread.\r\nReply to this email directly, view it on GitHub<https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/41>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AB7AQ2L7XYEL7XSW5Y6TSS3TGI5P5ANCNFSM42C7NFIQ>.\r\n",
          "createdAt": "2021-04-01T16:39:16Z",
          "updatedAt": "2021-04-01T16:39:16Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU4NDY5Njc5NjQ=",
      "title": "What status code should lead to creation of WebTransport session?",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/42",
      "state": "OPEN",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The spec currently explicitly requires `200`.  <https://tools.ietf.org/id/draft-ietf-quic-http-34.html#name-the-connect-method> suggests that any 2xx code should work.  Should we change the text accordingly?",
      "createdAt": "2021-03-31T16:58:48Z",
      "updatedAt": "2021-04-06T06:50:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd suggest server MUST send 200 and client MUST accept any 2XX. That way future extensions can apply meaning to other 2XX codes.",
          "createdAt": "2021-03-31T17:29:24Z",
          "updatedAt": "2021-03-31T17:29:24Z"
        },
        {
          "author": "yutakahirano",
          "authorAssociation": "NONE",
          "body": "What would happen if we require client to reject 2xx other than 200?",
          "createdAt": "2021-04-06T06:50:36Z",
          "updatedAt": "2021-04-06T06:50:36Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU4Njg0ODI1Nzg=",
      "title": "[Editorial] `Code` interchanged in Section 7.3 and 7.4",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/43",
      "state": "OPEN",
      "author": "bashi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It seems that Section 7.3 should mention `Code: 0x41` and Section 7.4 should mention `Code: 0x54`.",
      "createdAt": "2021-04-27T05:51:43Z",
      "updatedAt": "2021-04-27T05:51:43Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI0MzQ3MDEz",
      "title": "Refactor the spec to actually send the origin to the server",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/1",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-10-03T18:24:20Z",
      "updatedAt": "2019-10-05T14:09:47Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "master",
      "baseRefOid": "b63401f4fb1571a5ba86257f9500ddcb04dba967",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "stream2",
      "headRefOid": "eeaac8c28b34cfb71fa59dbccdc4ada5eb856d45",
      "closedAt": "2019-10-04T20:00:30Z",
      "mergedAt": "2019-10-04T20:00:30Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "463cd5c2a6adc48ea89b577d898922a127d7ce0a"
      },
      "comments": [
        {
          "author": "flano-yuki",
          "authorAssociation": "NONE",
          "body": "What is the uri-scheme used in an origin?\r\n( It may be discussed as a separate issue.\r\n",
          "createdAt": "2019-10-04T05:40:56Z",
          "updatedAt": "2019-10-04T05:40:56Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> What is the uri-scheme used in an origin?\r\n> ( It may be discussed as a separate issue.\r\n\r\nWell, the origin sent here is the origin of the webpage that created QuicTransport; so, for instance, if `https://website.example/webapp` connects using QuicTransport to `quic-server.example:443`, the origin  send would be `https://website.example`.\r\n\r\nI don't think a QuicTransport connection can be an origin by itself.  We are currently considering giving it its own URL scheme, but a URL can only act as an origin if a user can [navigate](https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigate) to it, or if the URL has storage attached to it (which QuicTransport doesn't, since it doesn't support HTTP cookies).",
          "createdAt": "2019-10-04T19:21:11Z",
          "updatedAt": "2019-10-04T19:21:11Z"
        },
        {
          "author": "flano-yuki",
          "authorAssociation": "NONE",
          "body": "I misunderstood the URI schema as that of QuicTransport itself \ud83d\ude47 \r\nYour kind explanation made me understand.\r\n\r\nthanks ",
          "createdAt": "2019-10-05T14:09:47Z",
          "updatedAt": "2019-10-05T14:09:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDY2Mzkx",
          "commit": {
            "abbreviatedOid": "c22d4b2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I like the new concept, comments are mostly minor",
          "createdAt": "2019-10-03T18:29:13Z",
          "updatedAt": "2019-10-03T18:37:30Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "To get this to turn into a link, I think you want `{{QUIC-TRANSPORT}}` with a definition similar to what's in draft-ietf-quic-tls.",
              "createdAt": "2019-10-03T18:29:13Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            },
            {
              "originalPosition": 19,
              "body": "Is endpoint a defined term in IETF land?",
              "createdAt": "2019-10-03T18:29:49Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            },
            {
              "originalPosition": 32,
              "body": "I'd personally prefer `wq-01` to match the QUIC docs",
              "createdAt": "2019-10-03T18:30:21Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            },
            {
              "originalPosition": 32,
              "body": "I'm confused by this MUST NOT establish - if the server rejects the value it fails the handshake and closes the connection right?",
              "createdAt": "2019-10-03T18:31:09Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            },
            {
              "originalPosition": 39,
              "body": "I wouldn't call this a handshake message because it could be interpreted as meaning QUIC/TLS handshake",
              "createdAt": "2019-10-03T18:31:40Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            },
            {
              "originalPosition": 50,
              "body": "QUIC notation is in bits, not bytes. Also, can't we make these varints?",
              "createdAt": "2019-10-03T18:32:25Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            },
            {
              "originalPosition": 43,
              "body": "We probably need a way to convey the end of the sequence. For example\r\n- number of pairs up front\r\n- total length up front\r\n- FIN sent after the last one",
              "createdAt": "2019-10-03T18:33:44Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            },
            {
              "originalPosition": 73,
              "body": "It's probably simplest to ban duplicate keys like QUIC transport parameters, as this flexibility adds risk",
              "createdAt": "2019-10-03T18:34:25Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            },
            {
              "originalPosition": 93,
              "body": "How is the origin encoded? (see RFC6454 section 6)",
              "createdAt": "2019-10-03T18:36:08Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDcxOTMw",
          "commit": {
            "abbreviatedOid": "c22d4b2"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T18:39:06Z",
          "updatedAt": "2019-10-03T18:39:06Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "It's already a link, though.",
              "createdAt": "2019-10-03T18:39:06Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDcyMjg5",
          "commit": {
            "abbreviatedOid": "c22d4b2"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T18:39:44Z",
          "updatedAt": "2019-10-03T18:39:45Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Well, quic-transport-23 defines it and uses it 460 times.",
              "createdAt": "2019-10-03T18:39:45Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg0NjQ4",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:01:30Z",
          "updatedAt": "2019-10-03T19:01:30Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I actually changed it to `wq-vvv-01`, since this is not a WG draft.",
              "createdAt": "2019-10-03T19:01:30Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg0ODY5",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:01:55Z",
          "updatedAt": "2019-10-03T19:01:55Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I changed it to \"MUST close\".  FWIW, this is just a restatement of quic-transport requirement.",
              "createdAt": "2019-10-03T19:01:55Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg0OTc0",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:02:06Z",
          "updatedAt": "2019-10-03T19:02:06Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Removed word \"handshake\".",
              "createdAt": "2019-10-03T19:02:06Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg1NTkw",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:03:07Z",
          "updatedAt": "2019-10-03T19:03:07Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Fixed the bytes one.  I've considered making those varints, but my concern was that not all QUIC libraries expose the varint parser to the applications, thus making this potentially harder to implement.",
              "createdAt": "2019-10-03T19:03:07Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg1ODM4",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:03:33Z",
          "updatedAt": "2019-10-03T19:03:33Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "It's meant to be FIN.  Spelled this out more clearly.",
              "createdAt": "2019-10-03T19:03:33Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg1OTAy",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:03:39Z",
          "updatedAt": "2019-10-03T19:03:40Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Done.",
              "createdAt": "2019-10-03T19:03:39Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg1OTc5",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:03:49Z",
          "updatedAt": "2019-10-03T19:03:49Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "I already say that below.",
              "createdAt": "2019-10-03T19:03:49Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg4OTkz",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:09:28Z",
          "updatedAt": "2019-10-03T19:09:28Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Huh, weird",
              "createdAt": "2019-10-03T19:09:28Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg5MjQy",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:09:52Z",
          "updatedAt": "2019-10-03T19:09:53Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "SGTM",
              "createdAt": "2019-10-03T19:09:53Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg5NjU1",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:10:40Z",
          "updatedAt": "2019-10-03T19:10:40Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Varints take about 10 lines of code to implement, I think they're worth the flexibility",
              "createdAt": "2019-10-03T19:10:40Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDkzMTA2",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:17:12Z",
          "updatedAt": "2019-10-03T19:17:13Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Where? Section 6 of RFC6454 proposes multiple different encodings",
              "createdAt": "2019-10-03T19:17:12Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MTAyMzk3",
          "commit": {
            "abbreviatedOid": "4f8edd5"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:35:01Z",
          "updatedAt": "2019-10-03T19:35:02Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Ah, good point.  Clarified that.",
              "createdAt": "2019-10-03T19:35:01Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MjY5NDU3",
          "commit": {
            "abbreviatedOid": "4f8edd5"
          },
          "author": "flano-yuki",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-04T05:31:41Z",
          "updatedAt": "2019-10-04T05:31:41Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I think variable length fields are indicated by an asterisk\r\n(as https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#notational-conventions",
              "createdAt": "2019-10-04T05:31:41Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3NjY2MDc4",
          "commit": {
            "abbreviatedOid": "eeaac8c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-04T19:08:30Z",
          "updatedAt": "2019-10-04T19:08:31Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Indeed.  Thanks for pointing this out.",
              "createdAt": "2019-10-04T19:08:30Z",
              "updatedAt": "2019-10-04T19:08:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyMjc2ODQ4",
      "title": "Add a URL scheme requirement",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/5",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This defines a new URL scheme for QuicTransport, and clarifies the use\r\nof \"https\" for Http3Transport.",
      "createdAt": "2019-10-24T23:08:21Z",
      "updatedAt": "2019-10-25T22:24:47Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "master",
      "baseRefOid": "cddcd8a7f206065b01ceb4951927fb3cda72fa43",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "url-scheme",
      "headRefOid": "ff7276c3d55df0593e65eae5e2a3dac5ae615ce8",
      "closedAt": "2019-10-25T22:24:47Z",
      "mergedAt": "2019-10-25T22:24:47Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "7506e4c3ea2ffa4819286b9b404d67773ff55dfe"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTExODMw",
          "commit": {
            "abbreviatedOid": "e004b71"
          },
          "author": "pthatcherg",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T23:09:58Z",
          "updatedAt": "2019-10-24T23:12:39Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "transprot => transport",
              "createdAt": "2019-10-24T23:09:58Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 22,
              "body": "path-abempty is never used in the ABNF below.",
              "createdAt": "2019-10-24T23:10:57Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 45,
              "body": "This note would be a little more clear if moved up 1 paragraph.",
              "createdAt": "2019-10-24T23:12:29Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTE0MDEw",
          "commit": {
            "abbreviatedOid": "e004b71"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T23:18:01Z",
          "updatedAt": "2019-10-24T23:18:20Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Fixed here and in another place I made the same typo.",
              "createdAt": "2019-10-24T23:18:01Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 22,
              "body": "Fixed.",
              "createdAt": "2019-10-24T23:18:09Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 45,
              "body": "Done.",
              "createdAt": "2019-10-24T23:18:14Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTEyMTQ4",
          "commit": {
            "abbreviatedOid": "e004b71"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-10-24T23:11:04Z",
          "updatedAt": "2019-10-24T23:18:44Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "nit: I'd say HTTP/3 because not all versions of HTTP require TLS",
              "createdAt": "2019-10-24T23:11:04Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 19,
              "body": "typo: transprot",
              "createdAt": "2019-10-24T23:11:23Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 22,
              "body": "I think you want `{{CSP}}` to make sure the links work in all output formats",
              "createdAt": "2019-10-24T23:12:08Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 5,
              "body": "nit: extra space before {",
              "createdAt": "2019-10-24T23:12:27Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 18,
              "body": "uses *the* ...",
              "createdAt": "2019-10-24T23:12:53Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 22,
              "body": "`path-abempty` is defined but not used",
              "createdAt": "2019-10-24T23:13:28Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 32,
              "body": "typo abemtpy ?",
              "createdAt": "2019-10-24T23:14:14Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 35,
              "body": "add: and MUST NOT send non-empty values",
              "createdAt": "2019-10-24T23:14:59Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 42,
              "body": "I don't think we've defined what a user is. Perhaps replace this with `If the port value is 0, the user agent MUST fail the connection attempt immediately.`",
              "createdAt": "2019-10-24T23:17:20Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 47,
              "body": "Remove this sentence, as IANA won't allocate one until we ask.",
              "createdAt": "2019-10-24T23:18:04Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTIzMzk1",
          "commit": {
            "abbreviatedOid": "ff7276c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T23:55:15Z",
          "updatedAt": "2019-10-24T23:55:15Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "I'm not sure what you mean here.  We do not provide any way to send those in the protocol.",
              "createdAt": "2019-10-24T23:55:15Z",
              "updatedAt": "2019-10-24T23:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTIzNTM3",
          "commit": {
            "abbreviatedOid": "ff7276c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T23:55:48Z",
          "updatedAt": "2019-10-24T23:55:48Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I think I've defined `client` to mean what I meant here, so I just replaced it with that.",
              "createdAt": "2019-10-24T23:55:48Z",
              "updatedAt": "2019-10-24T23:55:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTIzNjc2",
          "commit": {
            "abbreviatedOid": "ff7276c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T23:56:27Z",
          "updatedAt": "2019-10-24T23:56:27Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I'm not entirely sure what the difference here is, but it seems to work either way.",
              "createdAt": "2019-10-24T23:56:27Z",
              "updatedAt": "2019-10-24T23:56:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTI0MjQ4",
          "commit": {
            "abbreviatedOid": "ff7276c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T23:58:54Z",
          "updatedAt": "2019-10-24T23:58:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Apparently I've not been consistent about those.  Changed to two spaces everywhere for consistency.",
              "createdAt": "2019-10-24T23:58:54Z",
              "updatedAt": "2019-10-24T23:58:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTU2ODIz",
          "commit": {
            "abbreviatedOid": "ff7276c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T02:39:53Z",
          "updatedAt": "2019-10-25T02:39:53Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Good point.",
              "createdAt": "2019-10-25T02:39:53Z",
              "updatedAt": "2019-10-25T02:39:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTY5MDg1",
          "commit": {
            "abbreviatedOid": "ff7276c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-25T03:41:09Z",
          "updatedAt": "2019-10-25T03:43:54Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Might as well be consistent and use `{{`",
              "createdAt": "2019-10-25T03:41:56Z",
              "updatedAt": "2019-10-25T03:43:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3MzY1NDcw",
          "commit": {
            "abbreviatedOid": "ff7276c"
          },
          "author": "pthatcherg",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-25T18:02:14Z",
          "updatedAt": "2019-10-25T18:02:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM0NDczNzIz",
      "title": "Add support for path and query in QuicTransport URIs.",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/6",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-10-30T19:35:55Z",
      "updatedAt": "2019-10-31T18:22:45Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "master",
      "baseRefOid": "7506e4c3ea2ffa4819286b9b404d67773ff55dfe",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "uri-path",
      "headRefOid": "09cd2b18275ad3afc091a9938f678e9038d74c78",
      "closedAt": "2019-10-31T18:22:45Z",
      "mergedAt": "2019-10-31T18:22:45Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "950282754dde74032945d42fa913fb62c325589d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NDk3NjEz",
          "commit": {
            "abbreviatedOid": "8161cdf"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-30T20:25:25Z",
          "updatedAt": "2019-10-30T20:26:25Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "typo: followed by",
              "createdAt": "2019-10-30T20:25:25Z",
              "updatedAt": "2019-10-31T18:21:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 7,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1NjI0Mzc0",
      "title": "dschinazi editorial pass on overview",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/7",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-01T21:29:39Z",
      "updatedAt": "2019-11-03T22:22:31Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "master",
      "baseRefOid": "f0cc5755b330b3a18720bea5084b3cb1653f3f28",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "ds_editorial_overview",
      "headRefOid": "55a0b1303183e5bb2cbfd7a2d92d5eefd3d6af26",
      "closedAt": "2019-11-03T22:16:49Z",
      "mergedAt": "2019-11-03T22:16:49Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "8df84701de43933fcf3735310fba37ecf3a57cb4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzA3MDUy",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T21:35:13Z",
          "updatedAt": "2019-11-01T21:42:08Z",
          "comments": [
            {
              "originalPosition": 330,
              "body": "I think \"HTTP-based authentication\" does not actually include all of the things that we want to not support (e.g. prompt-based client auth).",
              "createdAt": "2019-11-01T21:35:13Z",
              "updatedAt": "2019-11-01T21:42:08Z"
            },
            {
              "originalPosition": 281,
              "body": "I was actually mostly worried about stream data.",
              "createdAt": "2019-11-01T21:35:38Z",
              "updatedAt": "2019-11-01T21:42:08Z"
            },
            {
              "originalPosition": 145,
              "body": "That's a transport property.  The feature I was trying to define here are \"supports streams\" and \"support datagrams\".",
              "createdAt": "2019-11-01T21:40:55Z",
              "updatedAt": "2019-11-01T21:42:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzUxMTI0",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-02T02:11:23Z",
          "updatedAt": "2019-11-02T02:11:24Z",
          "comments": [
            {
              "originalPosition": 330,
              "body": "What do you mean by \"prompt-based client auth\" ? What non-HTTP-based authentications are there?",
              "createdAt": "2019-11-02T02:11:24Z",
              "updatedAt": "2019-11-02T02:11:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzUxMTU5",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-02T02:12:01Z",
          "updatedAt": "2019-11-02T02:12:02Z",
          "comments": [
            {
              "originalPosition": 281,
              "body": "Nagle has value, I don't think we should argue against Nagle without a more detailed explanation",
              "createdAt": "2019-11-02T02:12:02Z",
              "updatedAt": "2019-11-02T02:12:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzUxMjYx",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-02T02:14:10Z",
          "updatedAt": "2019-11-02T02:14:11Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "I don't understand the difference",
              "createdAt": "2019-11-02T02:14:11Z",
              "updatedAt": "2019-11-02T02:14:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODQyOTg4",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-03T22:06:51Z",
          "updatedAt": "2019-11-03T22:06:51Z",
          "comments": [
            {
              "originalPosition": 330,
              "body": "TLS client auth (the one where user gets a prompt).",
              "createdAt": "2019-11-03T22:06:51Z",
              "updatedAt": "2019-11-03T22:06:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODQzMzc5",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-03T22:13:54Z",
          "updatedAt": "2019-11-03T22:13:55Z",
          "comments": [
            {
              "originalPosition": 281,
              "body": "Nagle does have value, and I'm pretty sure it's negative for ~all latency-sensitive applications we're targeting with this, at least without explicit controls.",
              "createdAt": "2019-11-03T22:13:55Z",
              "updatedAt": "2019-11-03T22:13:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODQzNzgz",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-03T22:21:06Z",
          "updatedAt": "2019-11-03T22:21:06Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "It's a difference between \"what you can do with transport\" and \"how the transport will do it\".  I agree it's not clear, so I just deleted that definition from the list.",
              "createdAt": "2019-11-03T22:21:06Z",
              "updatedAt": "2019-11-03T22:21:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODQzODA5",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-03T22:21:36Z",
          "updatedAt": "2019-11-03T22:21:37Z",
          "comments": [
            {
              "originalPosition": 281,
              "body": "Not all streams are latency-sensitive in a latency-sensitive application though",
              "createdAt": "2019-11-03T22:21:36Z",
              "updatedAt": "2019-11-03T22:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODQzODY0",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-03T22:22:30Z",
          "updatedAt": "2019-11-03T22:22:31Z",
          "comments": [
            {
              "originalPosition": 330,
              "body": "WebTransport runs over TLS or QUIC so it has no reason not to support TLS client auth?",
              "createdAt": "2019-11-03T22:22:30Z",
              "updatedAt": "2019-11-03T22:22:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 8,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1NjMzNTUz",
      "title": "dschinazi editorial pass on QuicTransport",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/8",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-01T21:56:59Z",
      "updatedAt": "2019-11-03T22:35:17Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "master",
      "baseRefOid": "f0cc5755b330b3a18720bea5084b3cb1653f3f28",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "ds_editorial_quic",
      "headRefOid": "d98124f2a293b6ae22fee4f6b74a36116f830ff2",
      "closedAt": "2019-11-03T22:35:17Z",
      "mergedAt": "2019-11-03T22:35:17Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "8304e2c0d84735d33bb37bc03e7d9e65a7b96c23"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzE5OTQ3",
          "commit": {
            "abbreviatedOid": "77e4e63"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Please bring the backticks back.",
          "createdAt": "2019-11-01T22:17:21Z",
          "updatedAt": "2019-11-01T22:21:43Z",
          "comments": [
            {
              "originalPosition": 296,
              "body": "QuicTransport ALPN value",
              "createdAt": "2019-11-01T22:17:21Z",
              "updatedAt": "2019-11-03T00:51:05Z"
            },
            {
              "originalPosition": 21,
              "body": "I actually have trouble understanding this sentence now.",
              "createdAt": "2019-11-01T22:21:05Z",
              "updatedAt": "2019-11-03T00:51:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzk1MDEy",
          "commit": {
            "abbreviatedOid": "d98124f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-03T00:51:23Z",
          "updatedAt": "2019-11-03T00:51:24Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Fixed",
              "createdAt": "2019-11-03T00:51:23Z",
              "updatedAt": "2019-11-03T00:51:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzk1MDEz",
          "commit": {
            "abbreviatedOid": "d98124f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-03T00:51:30Z",
          "updatedAt": "2019-11-03T00:51:30Z",
          "comments": [
            {
              "originalPosition": 296,
              "body": "Fixed",
              "createdAt": "2019-11-03T00:51:30Z",
              "updatedAt": "2019-11-03T00:51:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1OTgzNzg1",
      "title": "dschinazi editorial pass on Http3Transport",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/9",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-03T01:48:54Z",
      "updatedAt": "2019-11-03T22:40:49Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "master",
      "baseRefOid": "f0cc5755b330b3a18720bea5084b3cb1653f3f28",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "ds_editorial_h3",
      "headRefOid": "ca177b74cfc969e47665410a2a2888ff7cf87840",
      "closedAt": "2019-11-03T22:40:49Z",
      "mergedAt": "2019-11-03T22:40:49Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "41cdacc0b477c2f43d761538327720660c60097f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc5Njg1NTIy",
      "title": "Refactor client indication into a full header exchange",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/18",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We currently use 16-bit integers for header names.  There probably won't\r\never be more than 65,000 headers, but this does not let users add their\r\nown custom headers easily.  Thus, this commit changes uint16 to string.\r\n\r\nWe currently provide a way for a server to explicitly reject client's\r\norigin, but no way to explicitly accept it.  This commit solves this by\r\nturning the client indication stream into a bidirectional handshake\r\nstream.  Server confirms the handshake by sending a FIN on its end of\r\nthe handshake stream.",
      "createdAt": "2020-09-04T13:26:39Z",
      "updatedAt": "2020-09-23T20:22:43Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "master",
      "baseRefOid": "77936a2df618dfa4d10c8f73d05acf7dfb40ba14",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "bidi-headers",
      "headRefOid": "2c92455b066d42767a554f87b998adb46ba1e2ea",
      "closedAt": "2020-09-23T20:22:43Z",
      "mergedAt": "2020-09-23T20:22:43Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "f36ba9e4a8de56f2fc418eca9416c9828325e41a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNzY0MjYz",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-04T15:45:21Z",
          "updatedAt": "2020-09-04T16:16:47Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "The QuicTransport Header is very similar to HTTP/3 SETTINGS because it is an object that can contain a sequence of key-value pairs. I think it would help to present the QuicTransport Header in a similar way as in https://tools.ietf.org/html/draft-ietf-quic-http-29#section-7.2.4\r\n\r\nFor instance\r\n\r\n```\r\nHeader {\r\n     Header Name Length (16),\r\n     Header Name (..),\r\n     Header Value Length (16),\r\n     Header Value (..),\r\n}\r\n\r\nQuicTransport Headers {\r\n     Header (..) ...,\r\n   }\r\n```",
              "createdAt": "2020-09-04T15:48:49Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            },
            {
              "originalPosition": 115,
              "body": "Given the bulleted description of the handshake and this section, it is a little unclear what you expect the server to do. For instance, consider a client cannot send the complete block because the server's initial bidi flow control window is too small. Is the expectation that a Server Application will read data from the QUIC stream (giving flow control credit back to client) and buffer the block in the application layer until the client completes? \r\n\r\nIt seems unfortunate if a client can force a server to buffer up to 1,048,576 bytes. Yes the server can hangup, but it would have to wait until the application-imposed limit was reached. It might be healthier for the block to begin with a total length field. That allows a server to early abort.",
              "createdAt": "2020-09-04T16:13:48Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            },
            {
              "originalPosition": 145,
              "body": "With the current format and defined fields, this means just sending an empty STREAM frame with FIN?",
              "createdAt": "2020-09-04T16:16:33Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDc5OTUw",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "kixelated",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T20:44:58Z",
          "updatedAt": "2020-09-08T20:54:57Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "How does the client know that a connection close was due to an unaccepted origin? If it receives a CONNECTION_CLOSE prior to receiving a FIN on stream 0?\r\n\r\nThe problem is that there are many sources of CONNECTION_CLOSE errors. The server could close the connection due to an invalid path or it just decided to immediately terminate the connection. In either case, the client will receive a QUIC application close and will incorrectly assume that it was due to an invalid origin.\r\n\r\nTo correctly identify invalid origins, there should be an explicit and retransmitted signal. Either an \"invalid origin\" response message (on stream 0)  or CONNECTION_CLOSE error code.",
              "createdAt": "2020-09-08T20:44:59Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NTA0NjQ1",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T21:27:22Z",
          "updatedAt": "2020-09-08T21:27:22Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "You could also abort the stream with a RESET_STREAM in this case. That way you wouldn't even need an error code (although it would help) in order to detect the case where the origin exchange is pass/fail.",
              "createdAt": "2020-09-08T21:27:22Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NTE3MzY4",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "kixelated",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T21:52:19Z",
          "updatedAt": "2020-09-08T21:52:19Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Yeah, `RESET_STREAM` would be nice with or without error codes. It's better than CONNECTION_CLOSE because it can be reliable and does not infringe upon the application error code space.",
              "createdAt": "2020-09-08T21:52:19Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NDY0Njgy",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I think that we should stay as close to HTTP headers as possible here, to simplify the relationship between QuicTransport and HttpTransport. We could then say that JavaScript MUST NOT be able to set headers that start with a colon to enforce a separation in the namespace.",
          "createdAt": "2020-09-09T23:17:23Z",
          "updatedAt": "2020-09-09T23:22:12Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Why is this more restrictive than HTTP headers? Couldn't we use the same rules as HTTP/2 headers for simplicity?",
              "createdAt": "2020-09-09T23:17:23Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            },
            {
              "originalPosition": 105,
              "body": "Additional implementation-specific limits can lead to interop issues. Could we instead say that servers MUST accept headers up to that length?",
              "createdAt": "2020-09-09T23:18:42Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            },
            {
              "originalPosition": 210,
              "body": "Could we instead use the HTTP headers registry?",
              "createdAt": "2020-09-09T23:20:53Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5NjI1MDU3",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "yutakahirano",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T13:28:48Z",
          "updatedAt": "2020-09-16T13:29:50Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Shouldn't this be lower-cased?",
              "createdAt": "2020-09-16T13:28:49Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            },
            {
              "originalPosition": 157,
              "body": "Shouldn't this be lower-cased?",
              "createdAt": "2020-09-16T13:29:04Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDUzMTk0",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:06:49Z",
          "updatedAt": "2020-09-16T22:06:50Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "I don't believe anything in the current text of the PR precludes the server from processing headers as they come in, and, say, rejecting based on incorrect origin as soon as it parses the origin.  The requirement is to not _accept_ the headers until they're complete.\r\n\r\nWe could add a size in front, but this would have a downside of forcing the client to buffer all of the headers to compute the size in advance.",
              "createdAt": "2020-09-16T22:06:49Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDUzMjM3",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:06:56Z",
          "updatedAt": "2020-09-16T22:06:57Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Correct.",
              "createdAt": "2020-09-16T22:06:56Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDU1MTYx",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:11:07Z",
          "updatedAt": "2020-09-16T22:11:08Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "This is actually based on [the most restrictive interpretation of HTTP header name restrictions](https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#rfc.section.5.3.p.6).",
              "createdAt": "2020-09-16T22:11:07Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDU1NTc5",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:12:08Z",
          "updatedAt": "2020-09-16T22:12:09Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "We could, but in practice implementations will inevitable impose their own limit, and we can't preemptively enforce this, so I don't think it makes sense.",
              "createdAt": "2020-09-16T22:12:08Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDYxNzY4",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:26:25Z",
          "updatedAt": "2020-09-16T22:26:26Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "The ambiguity here is \" MUST NOT process any application data before receiving the entirety of the headers\". Its ambiguous because this is an application mapping and its all application data. I think what you mean is that the server MUST not process any received data on streams other than 0, or process any datagrams.\r\n\r\nBased on the defined fields so far, I don't see needing a length upfront as a real problem for clients. HTTP/2 and HTTP/3 require a length in HEADERS. What use case really needs such client behaviour?",
              "createdAt": "2020-09-16T22:26:26Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDYyNDEz",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:27:52Z",
          "updatedAt": "2020-09-16T22:27:52Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "I'm a bit weary of that because the \"Internet Message Header\" registry is currently already overloaded, and from what I understand it's currently being reorganized, so I would wait here.",
              "createdAt": "2020-09-16T22:27:52Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDYyOTAy",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:29:02Z",
          "updatedAt": "2020-09-16T22:29:03Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "I'm following the HTTP convention here where headers look like \"Content-Type\", even though on the wire, HTTP/2 and HTTP/3 encode those as all-lowercase.",
              "createdAt": "2020-09-16T22:29:02Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDYyOTM5",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:29:06Z",
          "updatedAt": "2020-09-16T22:29:07Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "I'm following the HTTP convention here where headers look like \"Content-Type\", even though on the wire, HTTP/2 and HTTP/3 encode those as all-lowercase.",
              "createdAt": "2020-09-16T22:29:07Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDY0MTYz",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:32:06Z",
          "updatedAt": "2020-09-16T22:32:06Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "This seems just like the setting for MAX_HEADER_LIST size. Unfortunately that setting has legacy baggage from decades of HTTP deployment. It seems with a new application protocol, the server could defe a limit thats enforceable. That helps cut down the memory commitment and is interoperable. Exchanging such a setting might require something ALPS-like though.",
              "createdAt": "2020-09-16T22:32:06Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDY4MzAy",
          "commit": {
            "abbreviatedOid": "4cb570f"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:42:42Z",
          "updatedAt": "2020-09-16T22:42:42Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Oooh, that's an interesting syntax. Done.",
              "createdAt": "2020-09-16T22:42:42Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMTM0NDY5",
          "commit": {
            "abbreviatedOid": "4cb570f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-17T00:26:48Z",
          "updatedAt": "2020-09-17T00:26:48Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "I do think that we should resolve those potential interop issues - and we can enforce this by using padding right?",
              "createdAt": "2020-09-17T00:26:48Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMTM2NTY5",
          "commit": {
            "abbreviatedOid": "4cb570f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-17T00:28:13Z",
          "updatedAt": "2020-09-17T00:28:14Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "I'm not sure if I understand why the reorganization of [the registry](https://www.iana.org/assignments/message-headers/message-headers.xhtml) would cause us to not use it",
              "createdAt": "2020-09-17T00:28:13Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMTM4Mjkw",
          "commit": {
            "abbreviatedOid": "4cb570f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-17T00:29:20Z",
          "updatedAt": "2020-09-17T00:29:21Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "I think sticking to HTTP semantics would be best. Adding a reference to that link SGTM as a way to suggest folks use this subset.",
              "createdAt": "2020-09-17T00:29:21Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzOTEzNDA5",
          "commit": {
            "abbreviatedOid": "2c92455"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T23:30:26Z",
          "updatedAt": "2020-09-22T23:30:26Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Re ambiguity, thanks for pointing this out! This should be fixed.\r\n\r\nRe header size, I agree we should do something about this, but not sure I like explicit size, given that it's redundant otherwise.  HTTP/2 and HTTP/3 do always have size, but that's because neither sends headers on a dedicated stream, so they need header block size for delineation.  I've filed #20 to track this.",
              "createdAt": "2020-09-22T23:30:26Z",
              "updatedAt": "2020-09-22T23:30:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzOTEzNTk3",
          "commit": {
            "abbreviatedOid": "2c92455"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T23:30:55Z",
          "updatedAt": "2020-09-22T23:30:56Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "I don't think we want to send one megabyte worth of padding.  I've filed #20 to track this.",
              "createdAt": "2020-09-22T23:30:55Z",
              "updatedAt": "2020-09-22T23:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MDE4OTAz",
          "commit": {
            "abbreviatedOid": "2c92455"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T20:22:21Z",
          "updatedAt": "2020-09-23T20:22:21Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Those are good points.  I wrote my thoughts on them in #15 ",
              "createdAt": "2020-09-23T20:22:21Z",
              "updatedAt": "2020-09-23T20:22:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE4MDc0NDE1",
      "title": "Update WebTransport over HTTP/3 to be more in sync with HTTP/2",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/21",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This replaces a distinct Session ID mechanism with using stream ID of\r\nthe CONNECT stream as a Session ID.\r\n\r\nThe transport parameter used to opt into WebTransport is replaced with\r\na SETTINGS value.",
      "createdAt": "2020-11-09T22:20:53Z",
      "updatedAt": "2021-01-20T19:52:20Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "master",
      "baseRefOid": "79723d48c9a955dcf5a450c29d0bfe9bc35dbd1b",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "h3-update",
      "headRefOid": "0935b9843c73d58566a01b695198d47ae2165ff8",
      "closedAt": "2021-01-20T19:52:20Z",
      "mergedAt": "2021-01-20T19:52:20Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "7ed396b083c090b310c253b6d784746ab048172a"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "NONE",
          "body": "I was reviewing the H2 WT draft, and I now wonder if \"connect stream\" is really the best terminology.  Is \"session stream\" more representative of what it is -- a stream that represents the WebTransport Session?  CONNECT just happens to be the method used to open the stream.",
          "createdAt": "2020-11-11T00:12:39Z",
          "updatedAt": "2020-11-11T00:12:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzAzODQ3",
          "commit": {
            "abbreviatedOid": "b63defd"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-09T22:24:08Z",
          "updatedAt": "2020-11-09T22:26:29Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "The text mentions QUIC DATAGRAMs but this reference is h3 DATAGRAMS - I think the distinction is important",
              "createdAt": "2020-11-09T22:24:09Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            },
            {
              "originalPosition": 146,
              "body": "This goes against the design of draft-schinazi-quic-h3-datagram. Should we use the same mechanism as CONNECT-UDP to allow multiplexing CONNECT-UDP and WebTransport over the same h3 connection?",
              "createdAt": "2020-11-09T22:25:52Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            },
            {
              "originalPosition": 178,
              "body": "Can we pick a value in the 4-byte encoding range to allow folks to test interop?",
              "createdAt": "2020-11-09T22:26:25Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzMzODky",
          "commit": {
            "abbreviatedOid": "8f49cbd"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-09T23:22:31Z",
          "updatedAt": "2020-11-09T23:22:32Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "We should!  Wanna update CONNECT-UDP draft to use stream IDs?",
              "createdAt": "2020-11-09T23:22:32Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzM0MDIz",
          "commit": {
            "abbreviatedOid": "8f49cbd"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-09T23:22:49Z",
          "updatedAt": "2020-11-09T23:22:49Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "note that this is the 8-byte encoding not 4-byte :) Also please add the value to the [registry](https://github.com/quicwg/base-drafts/wiki/Temporary-IANA-Registry)",
              "createdAt": "2020-11-09T23:22:49Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzM0NDkz",
          "commit": {
            "abbreviatedOid": "8f49cbd"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-09T23:23:55Z",
          "updatedAt": "2020-11-09T23:23:55Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "No, CONNECT-UDP relies on having separate namespaces for streams and DATAGRAM flow IDs. This feature is used by [the quic-proxy extension](https://tools.ietf.org/html/draft-pauly-masque-quic-proxy-00)",
              "createdAt": "2020-11-09T23:23:55Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzM4NzAz",
          "commit": {
            "abbreviatedOid": "8f49cbd"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-09T23:33:10Z",
          "updatedAt": "2020-11-09T23:33:10Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "I think it would be ok to have the same flow ID vendor work independent of the semantic usage of the connected stream right?",
              "createdAt": "2020-11-09T23:33:10Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzQ3Mzk5",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-09T23:53:04Z",
          "updatedAt": "2020-11-09T23:53:05Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "I am not convinced CONNECT-UDP actually relies on this property, at least the draft you link does not seem to explicitly discuss why that is required.",
              "createdAt": "2020-11-09T23:53:04Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzUxMjEy",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "LPardue",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-10T00:02:34Z",
          "updatedAt": "2020-11-10T00:02:35Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "@vasilvv I think you're asking a similar question to the one I posed on https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/16",
              "createdAt": "2020-11-10T00:02:34Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2Nzc1MDg5",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-10T01:04:14Z",
          "updatedAt": "2020-11-10T01:04:15Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "@vasilvv if you look at the [Example section](https://tools.ietf.org/html/draft-pauly-masque-quic-proxy-00#section-6) you'll see that multiple CONNECT-UDP requests with this extension can share a flow ID",
              "createdAt": "2020-11-10T01:04:14Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2Nzk0NDY2",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-10T01:55:17Z",
          "updatedAt": "2020-11-10T01:55:18Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "I read that, I just don't see why they need to share it.",
              "createdAt": "2020-11-10T01:55:17Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2ODAwODgy",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-10T02:14:05Z",
          "updatedAt": "2020-11-10T02:14:05Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "It's about shared lifetimes - it allows multiple requests to come and go and the underlying flow ID to remain valid - otherwise as the older flow IDs get removed you could end up with dropped datagrams. This also allows using smaller encodings for flow ID varints which adds up over time",
              "createdAt": "2020-11-10T02:14:05Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2ODkzMzM1",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-10T06:31:09Z",
          "updatedAt": "2020-11-10T06:31:09Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "I'm confused.  You have to keep the stream up for the duration of associated connection ID's lifetime anyways, since once the stream is gone, so are the mappings.\r\n\r\nDoes the varint thing matter?  I thought the entire point of draft-pauly-masque-quic-proxy is to bring 99% of the traffic outside the DATAGRAMs.",
              "createdAt": "2020-11-10T06:31:09Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NTM1Mzgw",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-10T19:24:32Z",
          "updatedAt": "2020-11-10T19:24:33Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "You keep the stream open for its part of the mapping, but you can think of the flow ID as being reference counted by all the streams that use it.\r\n\r\nConceptually, HTTP/3 DATAGRAM Flow IDs have their own namespace similar to how HTTP/3 Push IDs have their own namespace distinct from the Stream ID namespace.",
              "createdAt": "2020-11-10T19:24:33Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjU0OTYz",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-10T22:20:36Z",
          "updatedAt": "2020-11-10T22:20:37Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "This all sounds like unnecessary complexity to me.  If you don't keep separate flow IDs, you don't need to reference-count them in first place.",
              "createdAt": "2020-11-10T22:20:36Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5MDEzNDg3",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks Victor, switching to SETTINGs definitely makes sense.  Let's all talk about flow Ids sometime as well.",
          "createdAt": "2021-01-15T07:42:45Z",
          "updatedAt": "2021-01-15T07:48:46Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nsend a SETTINGS_ENABLE_WEBTRANSPORT setting in order to indicate that they\r\n```\r\n\r\nI'd argue H3 settings aren't really negotiated.",
              "createdAt": "2021-01-15T07:42:45Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            },
            {
              "originalPosition": 146,
              "body": "Let's talk about this on VC sometime, since I'd like to walk through all the pros and cons here.",
              "createdAt": "2021-01-15T07:48:15Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNTcwMTAz",
          "commit": {
            "abbreviatedOid": "0935b98"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-20T19:44:33Z",
          "updatedAt": "2021-01-20T19:44:33Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Let's merge this as-is for now, and update when with have consensus in the h3datagram draft.",
              "createdAt": "2021-01-20T19:44:33Z",
              "updatedAt": "2021-01-20T19:44:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU5Nzc4MTA2",
      "title": "Add negotiation for pooling support",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/25",
      "state": "OPEN",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-22T07:36:55Z",
      "updatedAt": "2021-02-17T10:39:59Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "1410f0de42c905511f3a6e91119b1d59ee01619e",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "negotiation",
      "headRefOid": "806411919eb82c199854e6fc69ffad8a92cd5abf",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "A different way to design this would be to say that the setting advertises the maximum number of Http3Transport sessions that the endpoint is willing to support. The maximum number in any session is then the minimum of the client and server value. E.g. if either side sends 0, its off. If either side sends > 0 its on but pooling only works if both send > 1. ",
          "createdAt": "2021-01-26T01:36:09Z",
          "updatedAt": "2021-01-26T01:36:56Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@LPardue your design wouldn't allow a server to say \"I'd like either HTTP or WT, but not both on the same connection\" though, right?",
          "createdAt": "2021-01-26T01:49:04Z",
          "updatedAt": "2021-01-26T01:49:04Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "NONE",
          "body": "Sorry, I might have enterd on the wrong axis of thinking about pooling as sharing one connection for WebTransport only, not mixing with conventional HTTP/3. Although, I'm not sure I follow how the proposal here satisfies the \"\"I'd like either HTTP or WT, but not both on the same connection\" either.",
          "createdAt": "2021-01-26T02:07:31Z",
          "updatedAt": "2021-01-26T02:07:31Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@LPardue In my understanding, this PR doesn't handle the \"I'd like either HTTP or WT, but not both on the same connection\" use-case. And I think that's what some folks were asking for.",
          "createdAt": "2021-01-26T02:38:07Z",
          "updatedAt": "2021-01-26T02:38:07Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "It sounds like calling C=2 \"exclusive\" was a mistake.  Renamed it.",
          "createdAt": "2021-01-27T18:59:17Z",
          "updatedAt": "2021-01-27T18:59:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1OTI5MTMy",
          "commit": {
            "abbreviatedOid": "3737f37"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I don't think this proposal works when the server sends its SETTINGS first",
          "createdAt": "2021-01-26T01:05:25Z",
          "updatedAt": "2021-01-26T01:15:08Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "```suggestion\r\n* Supported (\"1\") indicates that the server supports WebTransport over HTTP/3.\r\n```",
              "createdAt": "2021-01-26T01:05:25Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n* Supported (\"1\") indicates that the client supports WebTransport over HTTP/3\r\n```",
              "createdAt": "2021-01-26T01:05:41Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            },
            {
              "originalPosition": 12,
              "body": "We need to state somewhere that if SETTINGS_ENABLE_WEBTRANSPORT is not sent, its value is implicitly set to the default of 0.",
              "createdAt": "2021-01-26T01:10:16Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            },
            {
              "originalPosition": 37,
              "body": "This doesn't handle the case where client sends 0 and server sends 2. Why not simply say: if any endpoint sent 0 then WebTransport is not supported on this connection - which means clients MUST NOT send the special CONNECT request, and servers MUST fail it with a certain error.",
              "createdAt": "2021-01-26T01:12:08Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            },
            {
              "originalPosition": 56,
              "body": "What's the point of having the client tell the server whether it wants to be exclusive or not?",
              "createdAt": "2021-01-26T01:14:42Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NjU5NjEy",
          "commit": {
            "abbreviatedOid": "5e2d5ff"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T18:52:25Z",
          "updatedAt": "2021-01-26T18:52:26Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "No, it handles it with a connection error (third bullet point).",
              "createdAt": "2021-01-26T18:52:25Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NjYwMDM0",
          "commit": {
            "abbreviatedOid": "5e2d5ff"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T18:52:53Z",
          "updatedAt": "2021-01-26T18:52:53Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "It's not about whether it's exclusive or not, it's about whether the client intends to send a WebTransport request or not.",
              "createdAt": "2021-01-26T18:52:53Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NjYxMzYz",
          "commit": {
            "abbreviatedOid": "b53003a"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T18:54:32Z",
          "updatedAt": "2021-01-26T18:54:33Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Fixed.",
              "createdAt": "2021-01-26T18:54:32Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2Nzc0NjM4",
          "commit": {
            "abbreviatedOid": "b53003a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I still don't understand how this works. How does the server know what value to send?",
          "createdAt": "2021-01-26T21:25:57Z",
          "updatedAt": "2021-01-26T21:28:00Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\ndepends on which endpoint is sending the setting.\r\n```",
              "createdAt": "2021-01-26T21:25:57Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NzgxOTM4",
          "commit": {
            "abbreviatedOid": "b53003a"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T21:36:19Z",
          "updatedAt": "2021-01-26T21:47:37Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Does this mean the client has to have a request in mind before sending the SETTING?  Is pre-connecting allowed?",
              "createdAt": "2021-01-26T21:36:19Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            },
            {
              "originalPosition": 42,
              "body": "Echoing @DavidSchinazi's earlier point -- this makes it challenging to run a web server and an exclusive-only web transport server on the same address/port.  The server can send SETTINGS in 0.5-RTT, and it won't know if the client is going to send 0 (HTTP) or 2 (WT).  Alternately, the server can wait to receive the client SETTINGS before sending its own, but that's suboptimal for other reasons.",
              "createdAt": "2021-01-26T21:43:42Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            },
            {
              "originalPosition": 42,
              "body": "Somewhat related is that there is a completely incompatible set of modes here -- C=1, S=2.  These clients can't talk at all, even if the client would prefer pooled connections but would settle for exclusive ones.",
              "createdAt": "2021-01-26T21:46:45Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NjUxOTQx",
          "commit": {
            "abbreviatedOid": "8064119"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T18:46:24Z",
          "updatedAt": "2021-01-27T18:46:24Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Sure, as long as you're fine with the resulting connection being usable for a single WebTransport.",
              "createdAt": "2021-01-27T18:46:24Z",
              "updatedAt": "2021-01-27T18:46:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NjU2ODY4",
          "commit": {
            "abbreviatedOid": "8064119"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T18:52:25Z",
          "updatedAt": "2021-01-27T18:52:26Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I'm confused.  I don't think you can run a non-exclusive server and and exclusive server on the same port without multiplexing by something like ALPN.\r\n\r\nIf the client prefers pooled version, it can send C=1.  C=1, S=1 results in pooled WebTransport, C=1, S=2 results in exclusive WebTransport.",
              "createdAt": "2021-01-27T18:52:26Z",
              "updatedAt": "2021-01-27T18:52:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NjYyOTUw",
          "commit": {
            "abbreviatedOid": "8064119"
          },
          "author": "afrind",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T18:59:56Z",
          "updatedAt": "2021-01-27T18:59:57Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Per the text and the table, C=1, S=2 is an error.",
              "createdAt": "2021-01-27T18:59:56Z",
              "updatedAt": "2021-01-27T18:59:57Z"
            }
          ]
        }
      ]
    }
  ]
}