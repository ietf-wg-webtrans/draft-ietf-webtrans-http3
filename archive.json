{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-12-01T00:59:07.061581+00:00",
  "repo": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "pooling",
      "description": "Issues related to pooling multiple WebTransports together",
      "color": "7C45A1"
    },
    {
      "name": "ready for PR",
      "description": "",
      "color": "67E997"
    },
    {
      "name": "next meeting",
      "description": "",
      "color": "fef2c0"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "22D35E"
    },
    {
      "name": "capsule-dt",
      "description": "",
      "color": "006b75"
    },
    {
      "name": "ietf-114",
      "description": "Issues discussed at IETF 114",
      "color": "d4c5f9"
    },
    {
      "name": "ietf-115",
      "description": "Issues discussed at IETF 115",
      "color": "609F9E"
    },
    {
      "name": "ietf-113",
      "description": "Issues discussed at IETF 113",
      "color": "B9E3A9"
    },
    {
      "name": "ietf-112",
      "description": "Issues discussed at IETF 112",
      "color": "978FE0"
    },
    {
      "name": "ietf-116",
      "description": "Issues discussed at IETF 116",
      "color": "629173"
    },
    {
      "name": "has pull request",
      "description": "Issues for which a pull request exists",
      "color": "14C303"
    },
    {
      "name": "blocked on other WG",
      "description": "Blocked on a new draft being adopted in another WG",
      "color": "B60205"
    },
    {
      "name": "ietf-117",
      "description": "Issues discussed at IETF 117",
      "color": "8775BA"
    },
    {
      "name": "ietf-118",
      "description": "Issues discussed at IETF 118",
      "color": "5319E7"
    },
    {
      "name": "held for wglc",
      "description": "Issues held for Working Group Last Call",
      "color": "9D6338"
    },
    {
      "name": "flow-control",
      "description": "Issues blocked on flow control discussions",
      "color": "B60205"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "MDU6SXNzdWU1MDIyNTA1ODY=",
      "title": "Consider using a stream prefix in QuicTransport",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/2",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In QuicTransport, instead of having the client send the origin on stream 2, we could have all unidirectional streams carry a prefix and use that. This would map closely with HTTP/3 and HttpTransport, and would therefore allow code reuse",
      "createdAt": "2019-10-03T19:22:49Z",
      "updatedAt": "2021-01-27T20:15:19Z",
      "closedAt": "2021-01-27T20:15:19Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:15:19Z",
          "updatedAt": "2021-01-27T20:15:19Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU1MDIyNTEwNjU=",
      "title": "QuicTransport client indication could use varints",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/3",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "QuicTransport client indication could use varints instead of 16bit integers, that'll map closer to QUIC and give us more future-proof flexibility",
      "createdAt": "2019-10-03T19:23:49Z",
      "updatedAt": "2021-01-27T20:15:10Z",
      "closedAt": "2021-01-27T20:15:10Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:15:10Z",
          "updatedAt": "2021-01-27T20:15:10Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU1MTIxOTgxNDA=",
      "title": "Add WEBTRANS WG Charter and Agenda files",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/4",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It'll be easier to iterate on the WEBTRANS WG Charter proposal as well as the BOF Agenda if we store these in github. \r\n\r\nCurrent BOF Agenda is as follows: \r\n\r\nWEBTRANS BOF Agenda\r\nApplications and Real-Time Area (ART)\r\nWednesday, November 20, 2019\r\n13:30 - 15:00\r\nRoom: Canning\r\nMailing list: webtransport@ietf.org\r\n\r\n13:30 - 13:35 PM Preliminaries (5 minutes)\r\n   Agenda Bash\r\n   Bluesheets\r\n   Minute takers\r\n   Jabber scribe\r\n\r\n13:35 - 13:55 PM Use Cases and Requirements (20 minutes)\r\nhttps://tools.ietf.org/html/draft-vvv-webtransport-overview\r\n\r\n   Machine Learning APIs\r\n   Communications Platform APIs\r\n   Web Gaming\r\n   Requirements/Summary\r\n\r\n13:55 - 14:35 Relevant Drafts (40 minutes)\r\n\r\nAn Unreliable Datagram Extension to QUIC (Tommy Pauly, 10 minutes)\r\nhttps://tools.ietf.org/html/draft-pauly-quic-datagram\r\n\r\nUsing QUIC Datagrams with HTTP/3 (David Schinazi, 5 minutes)\r\nhttps://tools.ietf.org/html/draft-schinazi-quic-h3-datagram\r\n\r\nWebTransport over QUIC (Victor, Vailiev, 5 minutes)\r\nhttps://tools.ietf.org/html/draft-vvv-webtransport-quic\r\n\r\nHTTP/2 as a Transport for Arbitrary Bytestreams (Eric Kinnear & Tommy Pauly, 10 minutes)\r\nhttps://tools.ietf.org/html/draft-kinnear-httpbis-http2-transport\r\n\r\nWebTransport over HTTP/3 (Victor Vasiliev, 10 minutes)\r\nhttps://tools.ietf.org/html/draft-vvv-webtransport-http3\r\n\r\n14:35 - 14:45 Potential Charter (10 minutes)\r\n\r\n14:45 PM - 15:00 PM Wrapup and Summary (15 minutes)\r\n\r\nThe current WEBTRANS charter proposal is as follows: \r\n\r\nWebTransport (WEBTRANS)\r\n---------------------------------------------\r\nCharter\r\n\r\nChairs:\r\n     TBD\r\n\r\nApplications and Real-Time Area Directors:\r\n     Barry Leiba <barryleiba@computer.org>;\r\n     Alexey Melnikov <aamelnikov@fastmail.fm>;\r\n     Adam Roach <adam@nostrum.com>;\r\n\r\nApplications and Real-Time Area Advisor:\r\n     Barry Leiba <barryleiba@computer.org>;\r\n\r\nMailing Lists:\r\n     General Discussion: webtransport@ietf.org\r\n     To Subscribe:       https://www.ietf.org/mailman/listinfo/webtransport\r\n     Archive:\r\nhttps://mailarchive.ietf.org/arch/browse/webtransport/\r\n\r\nDescription of Working Group:\r\n\r\nThe WebTransport working group will define new protocols or\r\nprotocol extensions in order to support the development of the\r\nW3C WebTransport API <https://wicg.github.io/web-transport>;.\r\n\r\nThese protocols will support:\r\n  * Reliable bidirectional and unidirectional communication\r\n    that provides greater efficiency than Websockets\r\n    (e.g. removal of head-of-line blocking).\r\n  * Unreliable datagram communication, functionality not\r\n    available in Websockets.\r\n  * Origin checks to allow supporting the Web's origin-based\r\n    security model.\r\n\r\nThe WebTransport working group will define three variants:\r\n  * A protocol directly running over QUIC with its own ALPN.\r\n  * A protocol that runs multiplexed with HTTP/3.\r\n  * Fallback protocols that can be used when QUIC or UDP\r\n    are not available.\r\n\r\nThe group will pay attention to security issues arising from\r\nthe above scenarios so as to ensure against creation of new\r\nmodes of attack, as well as to ensure that security issues\r\naddressed in the design of Websockets remain addressed\r\nin the new work.\r\n\r\nTo assist in the coordination with W3C, the group will\r\ninitially develop an overview document containing use cases\r\nand requirements in order to clarify the goals of the effort.\r\nFeedback will also be solicited at various points along the way\r\nin order to ensure the best possible match between the protocol\r\nextensions and the needs of the W3C WebTransport API. The clarity\r\nand interoperability of specifications will be confirmed via test\r\nevents and hackathons.\r\n\r\nThe group will also coordinate with other working groups within\r\nthe IETF (e.g. QUIC, HTTPBIS) as appropriate.\r\n\r\nGoals and Milestones:\r\n\r\n  March 2020     - Adopt a WebTransport Overview draft as a WG work item\r\n  March 2020     - Adopt a draft on WebTransport over QUIC as a WG work item\r\n  March 2020     - Adopt a draft on WebTransport over HTTP/3 as a WG work\r\nitem\r\n  March 2020     - Adopt a draft on HTTP/2 fallback mechanism as a WG work\r\nitem\r\n  March 2020     - Adopt a draft on a QUIC fallback mechanism as a WG work\r\nitem\r\n  August 2020      - Issue WG last call of the WebTransport Overview\r\ndocument.\r\n  November 2020  - Issue WG last call on WebTransport over QUIC\r\n  November 2020  - Issue WG last call on QUIC fallback mechanism\r\n  February 2021  - Issue WG last call on WebTransport over HTTP/3\r\n  February 2021  - Issue WG last call on HTTP/2 fallback mechanism",
      "createdAt": "2019-10-24T21:48:24Z",
      "updatedAt": "2019-10-29T18:18:40Z",
      "closedAt": "2019-10-29T18:18:40Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "This is now at https://github.com/DavidSchinazi/webtrans-wg-materials",
          "createdAt": "2019-10-29T18:18:40Z",
          "updatedAt": "2019-10-29T18:18:40Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWU1MTkwMzY2NzE=",
      "title": "Http3Transport does not have a consistent stream ID view if proxies are involved",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/10",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In -overview, we require that \"The client and the server have to agree on the numbering, so it can be referenced in the application payload.\".  However, if an Http3Transport session is relayed through a proxy, it is not feasible to make the stream IDs to match on client-to-proxy and proxy-to-server, so we would have to encode a separate ID inside the stream ourselves or come up with a scheme for numbering those.",
      "createdAt": "2019-11-07T04:42:03Z",
      "updatedAt": "2021-08-24T08:06:45Z",
      "closedAt": "2021-08-24T08:06:45Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Also, since Http3Transport is pooled, exposing actual stream IDs would provide information about other traffic on the same connection, which is potentially from different origin.  So using those directly would be a security issue.",
          "createdAt": "2019-11-07T05:05:19Z",
          "updatedAt": "2019-11-07T05:05:19Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I've thought about trying to make a clever mapping scheme, but the problem is, the stream IDs can get reordered across proxy hops (otherwise there would be HOLB).  So it sounds like generating and encoding our own \"global\" (i.e. preserved across hops) numbers would be the only way.",
          "createdAt": "2019-11-07T05:13:24Z",
          "updatedAt": "2019-11-07T05:13:24Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "H3 makes an effort to not expose QUIC stream IDs directly, partially for this reason, and I believe it was a good design choice.\r\n\r\nAre we certain stream IDs need to be referenced in the application payload?  It seems a bit like a layering violation.",
          "createdAt": "2021-01-14T18:31:31Z",
          "updatedAt": "2021-01-14T18:31:31Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I seem to recall us reaching a consensus at some point that we don't actually need this; can we just close this issue?",
          "createdAt": "2021-07-22T22:24:15Z",
          "updatedAt": "2021-07-22T22:24:15Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 111.  The answer appears to be \"we do not have stream IDs\".  ",
          "createdAt": "2021-07-30T19:19:39Z",
          "updatedAt": "2021-07-30T19:19:39Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWU1MjEzMDMwNjU=",
      "title": "Confirm the URL scheme name",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/11",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The draft currently says `quic-transport:`, however, we'd still need to confirm this with the working group once we actually have one.",
      "createdAt": "2019-11-12T03:15:28Z",
      "updatedAt": "2021-01-27T20:17:14Z",
      "closedAt": "2021-01-27T20:17:14Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:17:14Z",
          "updatedAt": "2021-01-27T20:17:14Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU1MjU2MDEzMDY=",
      "title": "QUIC Transport \"path\" seems underspecified",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/12",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As discussed in Singapore BoF, the \"path\" of the URI for QUIC transport needs further specification. It isn't clear if it's a location, an application indication, or something else.",
      "createdAt": "2019-11-20T06:24:00Z",
      "updatedAt": "2021-01-27T20:17:22Z",
      "closedAt": "2021-01-27T20:17:22Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:17:22Z",
          "updatedAt": "2021-01-27T20:17:22Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU1MjU2MDI2MDE=",
      "title": "QUIC transport URI is not equivalent to WebSocket fallback ",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/13",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "A QUIC transport URI negotiates WebTransport protocol first, then gives a path. WebSocket does path first, then gets into the support of WebSocket. That's not equivalent semantics if you fall back from one to the other.",
      "createdAt": "2019-11-20T06:27:57Z",
      "updatedAt": "2021-01-27T20:17:33Z",
      "closedAt": "2021-01-27T20:17:33Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:17:33Z",
          "updatedAt": "2021-01-27T20:17:33Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU1MjY5OTgxNzA=",
      "title": "Meaning of \"Fallback\"",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/14",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The term \"fallback\" is not well enough defined.  It might be helpful to define a list of requirements that \"fallback\" transport (and APIs) must satisfy. \r\n\r\nAs an example, if QUIC is not available,  but HTTP/2 over TCP is, it may be possible to utilize RFC 8441 and/or potential extensions to provide for multiple streams over TCP.  This would support a portion of the WebTransport API (e.g. reliable streams), but now loss on one stream will block other streams and some protocol functionality (e.g. datagrams) may not be available.  Does that mean that some WebTransport methods operate differently or are not available?  In some cases, developers might prefer to \"fallback\" to the existing WebSockets API with its message-orientation.",
      "createdAt": "2019-11-22T05:37:59Z",
      "updatedAt": "2021-01-27T20:17:57Z",
      "closedAt": "2021-01-27T20:17:56Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "I don't know where \"fallback\" is currently being used, but I agree, it's not a good idea to silently downgrade functionality.\r\n\r\nThe idea is that WebTransports implement one or more interfaces (mixins) based on capability. The only way to fallback to another transport is if it 1) supports the same interfaces required by the developer and 2) a fallback server is advertised.\r\n\r\nMy question is, does there even need to be a fallback mechanism? Would a developer be able to implement the fallback themselves, perhaps with a simple timeout on connect?",
          "createdAt": "2020-08-09T21:38:59Z",
          "updatedAt": "2020-08-09T21:38:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the fallback transport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:17:56Z",
          "updatedAt": "2021-01-27T20:17:56Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU1MzI2OTM1MTI=",
      "title": "Define Error Code of WebTransport over QUIC",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/15",
      "state": "CLOSED",
      "author": "flano-yuki",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In WebTransport over QUIC, when an invalid  Client Indication is received, the server\t treats the connection as an error([section 6](https://vasilvv.github.io/webtransport/draft-vvv-webtransport-quic.html#rfc.section.6)).\r\n\r\nThis is an error that occurred in a layer above the QUIC, so I think the connection should be closed with CONNECTION_CLOSE (0x1d) indicating an error in the application using the QUIC.\r\n\r\nI think it is valuable to define an error code for WebTransport over QUIC.\r\n( [draft-ietf-quic-transport-24 section 20.1](https://tools.ietf.org/html/draft-ietf-quic-transport-24#section-20.1) saids \"the management of application error codes is left to application protocols.\" )\r\n\r\nand, by specifying the error code that the endpoint uses when it close the connection, the specification becomes clear.\r\n\r\nfor example\r\n```\r\n- WQ_NO_ERROR \r\n- WQ_INVALID_CLIENT_INDICATION\r\n- WQ_NOT_AUTHORITATIVE_ORGIN\r\n- WQ_OTHER_ERROR\r\n...\r\n```",
      "createdAt": "2019-12-04T13:43:27Z",
      "updatedAt": "2021-01-27T20:18:07Z",
      "closedAt": "2021-01-27T20:18:07Z",
      "comments": [
        {
          "author": "flano-yuki",
          "authorAssociation": "NONE",
          "body": "I realized that using Error Code is related to the [WICG/web-transport](https://github.com/WICG/web-transport).\r\n\r\nDo not conflict with error codes used by applications above WebTransport.\r\n\r\nso, I createted https://github.com/WICG/web-transport/issues/80 .\r\nPlease point it out if there are any mistakes in my opinion.\r\n\r\nthanks",
          "createdAt": "2019-12-09T05:00:22Z",
          "updatedAt": "2019-12-09T16:28:29Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "I agree, CONNECTION_CLOSE should provide an error code indicating why the connection was refused.",
          "createdAt": "2020-08-09T21:16:59Z",
          "updatedAt": "2020-08-09T21:16:59Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I seem to remember seeing non-zero error codes from other endpoints when interoperating. If so, I have no clue what those codes were supposed to mean. I think it would be useful to have some defined in the next draft version.",
          "createdAt": "2020-09-05T23:54:42Z",
          "updatedAt": "2020-09-05T23:54:42Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the non-zero error codes probably were random HTTP/3 error codes, because those are the only codes that Google's QUIC library supports (that's a known bug).\r\n\r\nI see three options for reporting handshake error:\r\n1) An application CONNECTION_CLOSE,\r\n2) A RESET_STREAM on the handshake stream,\r\n3) An error status code on the handshake stream.\r\n\r\nIf we go with 1, we would have to reserve some of the application error code space.  If we go with 2 or 3, we would have to describe how the server has to keep the connection open for some time in order to allow for retransmission of the RESET_STREAM/response error header.",
          "createdAt": "2020-09-23T20:21:59Z",
          "updatedAt": "2020-09-23T20:21:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:18:07Z",
          "updatedAt": "2021-01-27T20:18:07Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU2NzU3NjY5Mjg=",
      "title": "QuicTransport: 0-RTT and Origin Indication",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/16",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "[QuicTransport optionally supports 0-RTT](https://vasilvv.github.io/webtransport/draft-vvv-webtransport-quic.html#rfc.section.3.3) if there's a corresponding API for early data.\r\n\r\nThe WICG draft does not define any way to enable early data, and it probably shouldn't anyway. Early data complicates the API and exposes the user to potential security vulnerabilities if they misunderstand the risks.\r\n\r\nHowever, one thing worth clarifying in relation to 0-RTT is the origin indication message. It must be safe to send the origin indication in 0-RTT for any API to support early data. I don't fully understand if this is true but my impression is that it would be safe.\r\n\r\nAs for APIs that only send application data in 1-RTT space, sending the origin indication message in 0-RTT would be a slight improvement. The server must buffer all streams until the origin indication has been processed, so sending the origin indication early would reduce that initial head-of-line blocking.\r\n\r\nCould we clarify that origin indication CAN or SHOULD be sent in 0-RTT?",
      "createdAt": "2020-08-09T20:31:32Z",
      "updatedAt": "2021-01-27T20:18:21Z",
      "closedAt": "2021-01-27T20:18:21Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "The word that I'm missing is idempotent. If we make the origin/path handshake idempotent, then QuicTransport can support 0-RTT.",
          "createdAt": "2020-11-17T01:48:45Z",
          "updatedAt": "2020-11-17T01:48:45Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:18:21Z",
          "updatedAt": "2021-01-27T20:18:21Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWU2NzU3NzM0Mjk=",
      "title": "QuicTransport: origin indication via transport parameters",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/17",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "QuicTransport identifies itself using an ALPN and both peers agree to transfer additional configuration via a client-initiated stream (ID 2).\r\n\r\nI think it would be an improvement if this origin indication was moved into the QUIC transport parameters and exchanged via the TLS ClientHello.\r\n\r\nThere would be a few benefits (in no particular order):\r\n1. A server can terminate an invalid origin/path prior to performing the expensive TLS handshake.\r\n2. A server does not need to buffer stream data (inbound and outbound) waiting until stream 2 has arrived.\r\n3. A load balancer can route new connections to the correct server based on the path in the ClientHello. Currently, a load balancer must terminate TLS and buffer all streams until it can parse stream 2 prior to making a routing decision.\r\n4. QUIC stream IDs could be exposed to the application without the asterisks that stream 2 has already been used. \r\n5. The first client packet (ClientHello) must already be padded to 1200 bytes. The origin and path parameters would replace some of that padding and overall reduce the bandwidth for a new connection.\r\n\r\nThere would be a few downsides:\r\n1. Long paths and origins could cause fragment the ClientHello message into multiple packets.\r\n2. Requires [registering](https://tools.ietf.org/html/draft-ietf-quic-transport-29#section-22.2) `webtransport_path` and `webtransport_origin`.\r\n3. QUIC libraries need to expose or support the new transport parameters.",
      "createdAt": "2020-08-09T21:15:23Z",
      "updatedAt": "2020-09-08T20:55:30Z",
      "closedAt": "2020-09-08T20:55:30Z",
      "comments": [
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "One more downside:\r\n4. The path and origin won't be encrypted. This leaks more information than SNI alone and would especially be a problem if ESNI is the future.\r\n\r\nYeah, unfortunately I think this alone is a reason to stick with the stream 2 approach. Thanks for letting me think out loud!",
          "createdAt": "2020-08-10T00:26:43Z",
          "updatedAt": "2020-08-10T00:27:00Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, that's pretty much the reason why stream 2 exists (we tried a few ways to limit ourselves to transport params, but those didn't work out).  It's possible that we could use [ALPS](https://tools.ietf.org/html/draft-vvv-tls-alps-00) for this, but ALPS is still in very early stage, so it's hard to tell if it will be useful.",
          "createdAt": "2020-08-10T14:21:33Z",
          "updatedAt": "2020-08-10T14:21:33Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU2OTYxODY1NTM=",
      "title": "QuicTransport: Rejecting a path",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/19",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The spec defines a way to reject an unsupported origin with a CONNECTION_CLOSE (which has its own problems) but it does not define a way to reject an unsupported path. It's left up to the application, presumably to send a custom message or custom CONNECTION_CLOSE error code.\r\n\r\nI think that origin and path rejection should use the same rejection mechanism. Consistency will be important as new fields are added, potentially including user-defined fields. There are a few options:\r\n\r\n1. Path and origin rejection uses CONNECTION_CLOSE with reserved codes.\r\n2. Path and origin rejection uses a custom message containing an error code/message, sending CONNECTION_CLOSE upon receipt.\r\n3. Path and origin rejection is handled by the application. \r\n4. Path and origin rejection use RESET_STREAM, sending CONNECTION_CLOSE upon receipt.\r\n\r\nI'm actually in favor of 3. \r\n\r\nThe browser still needs to populate the origin for security reasons. However, the server can terminate the connection however it sees fit; the reason why does not need to be communicated to QuicTransport or the browser. It's much simpler than defining error codes and is the minimal work to allow QUIC in a web environment.",
      "createdAt": "2020-09-08T21:22:38Z",
      "updatedAt": "2021-01-27T20:18:52Z",
      "closedAt": "2021-01-27T20:18:52Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As mentioned on the PR, I think RESET_STREAM could also be effective.",
          "createdAt": "2020-09-08T21:30:20Z",
          "updatedAt": "2020-09-08T21:30:20Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "Added option 4! I like it more than option 1 and 2.",
          "createdAt": "2020-09-08T22:05:31Z",
          "updatedAt": "2020-09-08T22:05:31Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:18:52Z",
          "updatedAt": "2021-01-27T20:18:52Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU3MDY3NTAxMDE=",
      "title": "Reconsider the design around header block size limit",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/20",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Reviewing #18, @LPardue wrote:\r\n\r\n> It seems unfortunate if a client can force a server to buffer up to 1,048,576 bytes. Yes the server can hangup, but it would have to wait until the application-imposed limit was reached. It might be healthier for the block to begin with a total length field. That allows a server to early abort.\r\n\r\nI do agree that this is annoying, but at the same time adding a field that's redundant 90% of the time feels... weird?  We should think more seriously about how to make header size limits work at some point (maybe using ALPS or something like that).",
      "createdAt": "2020-09-22T23:16:57Z",
      "updatedAt": "2021-01-27T20:19:02Z",
      "closedAt": "2021-01-27T20:19:01Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this issue because the QuicTransport draft has been removed from this repository.",
          "createdAt": "2021-01-27T20:19:01Z",
          "updatedAt": "2021-01-27T20:19:01Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU3NDQyMzc1NTU=",
      "title": "Http3Transport connection flow control",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/22",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [
        "ekinnear"
      ],
      "labels": [
        "pooling",
        "capsule-dt",
        "ietf-112"
      ],
      "body": "Note that all of the below works when you swap \"server\" and \"client\". I wanted to focus on a poor Javascript client implementation, but it's equally possible to run into these cases with a poor server implementation.\r\n\r\nLet's say that you have a Http3Transport session that shares a connection with HTTP/3 or another Http3Transport session.\u00a0\r\n\r\n\r\n### MAX_DATA\r\nThe client has limited buffer space and hypothetically advertises MAX_DATA of 1MB for the connection. If the server pushes 1MB of unprocessed data over a Http3Transport session, then it will prevent the server from sending data over the connection,\u00a0including HTTP/3 responses and other Http3Transport sessions.\r\n\r\nThis can occur if the application does not accept all remote-created streams or does not fully read every stream. This will be VERY easy for a developer to mess up. It can also occur if the application can not process data faster than it is received.\r\n\r\nIn my case, the server creates unidirectional streams and pushes a large amount of media over them. The flow control limit would be hit if the Javascript application:\r\n\r\n- Only accepts bidirectional streams (ex. initialization)\r\n- Does not accept a unidirectional stream (ex. error or teardown)\r\n- Does not fully read or abort every stream (ex. parsing error)\r\n- Is not able to parse the media fast enough (ex. underpowered).\r\n\r\nThis is mostly intended behavior, otherwise these \"bugs\" would cause unbounded memory usage. However, the blast radius is bigger when sharing a connection.\u00a0\r\n\r\nIn my use-case, hitting the flow control limit would also block any HTTP/3 RPC calls or unrelated traffic on the connection. This introduces more scenarios for the connection to\u00a0become deadlocked or generally stalled.\r\n\r\n### MAX_STREAMS\r\nHTTP/3 implementations use MAX_STREAMS to limit the number of simultaneous requests. This use-case no longer works when sharing a connection with a Http3Transport session, and HTTP/3 implementations must instead return explicit error status codes when this threshold\u00a0is reached.\r\n\r\nThe same issues with MAX_DATA also apply to MAX_STREAMS. A Javascript application that fails to accept or read/abort every stream will consume flow control resources. This can manifest itself in strange ways, such as HTTP/3 being unable to create control streams, or simply being unable to create new request streams.",
      "createdAt": "2020-11-16T22:25:19Z",
      "updatedAt": "2022-12-16T19:10:12Z",
      "closedAt": "2022-12-16T19:10:12Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the salient overview, it makes it easier to understand your concerns.\r\n\r\nMy first comment would be that some of these points apply to QuicTransport too. Its just that their made worse by Http3Transport pooling allowing the mashing together of orthogonal protocols with no application-layer oversight. Just as you might interfere with a page load, a browser could easily interfere with your finely crafted application protocol. I would anticipate that, due to different browsers having different HTTP usage patterns, and different pages being composed differently by time, region, etc, one might find that Http3Transport apps subject to pooling would experience inconsistencies and transient issues. \r\n\r\nYou rightly point out that the connection flow control is a shared resource. But the problems described seem to relate to stream flow control and overlooks the different flow control setting afforded by the Transport Parameters. A possible mitigation is to more tightly constrain the initial flow windows of server-initiated streams so that they can't interfere with requests. However, I still think that the notion of pooling together WebTransports in an uncoordinated fashion is going to manifest undesirable properties.\r\n\r\nThe MAX_STREAMS observation is a good one. I think the competition between request streams and client bidirectional streams is going to be hard to resolve.",
          "createdAt": "2020-11-16T23:18:56Z",
          "updatedAt": "2020-11-16T23:18:56Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "Yeah, and enforcing any per sort of per-session flow control might get difficult because you can only identify the protocol and session after you receive the first few bytes of each stream.\r\n\r\nFor example, assume a brand new connection (for simplicity only) and you receive a STREAM frame with id=100, offset=16, and size=1000. You don't know yet which protocol or session created this stream or the 25 preceding it. And hopefully you eventually get those first few bytes for each stream...",
          "createdAt": "2020-11-16T23:56:16Z",
          "updatedAt": "2020-11-16T23:57:17Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair notes from IETF 112 meeting: this needs more discussion (on the issue or mailing list)",
          "createdAt": "2021-11-09T12:42:59Z",
          "updatedAt": "2021-11-09T12:42:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at 113, consensus in room to:\r\n* use a setting to limit number of WT sessions (see #34)\r\n* figure out MAX_STREAMS, a way to limit the number of streams within a session\r\n* abandon MAX_DATA as too hard, do not limit amount of data sent within a session (anyone can open a new issue to revisit this discussion if they have a concrete proposal on how to do this)\r\n* let QUIC take care of MAX_STREAM_DATA",
          "createdAt": "2022-03-24T14:37:21Z",
          "updatedAt": "2022-03-24T14:37:21Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Capsule DT is doing all of the above bullet points except the second one, for which I opened #85.\r\n",
          "createdAt": "2022-10-29T08:01:31Z",
          "updatedAt": "2022-10-29T08:01:31Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU3NDQyNTExMjk=",
      "title": "Http3Transport server-initiated bidirectional stream future proofing",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/23",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Http3Transport currently assumes that server-initiated bidirectional streams and datagrams can only be used for WebTransport. \r\n\r\nI suggest we prefix each server-initiated bidirectional stream and datagram with a new HTTP/3 frame type for WebTransport. This way, a future standard could define it's own frame type to run alongside WebTransport.",
      "createdAt": "2020-11-16T22:38:28Z",
      "updatedAt": "2021-07-22T22:41:51Z",
      "closedAt": "2021-07-22T22:41:51Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Using an H3 frame type for server initiated bidi streams would also make the design more consistent, instead of the asymmetric design there is today.  It costs a byte per bidi stream, but it seems worth it for consistency and flexibility.\r\n\r\nFor datagrams, I believe that we'd want to be able to coexist with other H3 extensions, such as MASQUE, and I believe that's possible without any extra overhead by adding a Session -> Datagram flow ID mapping when a WebTransport session is created.\r\n\r\n",
          "createdAt": "2021-01-14T21:50:52Z",
          "updatedAt": "2021-01-14T21:50:52Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "If it's a single byte, it's more of a stream type (like the unidirectional stream-type) than a frame type, right?\r\n\r\n> For datagrams, I believe that we'd want to be able to coexist with other H3 extensions, such as MASQUE, and I believe that's possible without any extra overhead by adding a Session -> Datagram flow ID mapping when a WebTransport session is created.\r\n\r\nThere's a discussion Victor pointed me to in #21, where it's suggested that datagrams belonging to a WebTransport session use the Flow ID = to the Session ID.  It would be nice to avoid the extra state and lookup.",
          "createdAt": "2021-01-15T00:38:13Z",
          "updatedAt": "2021-01-15T00:38:13Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah yes, it's more of a stream type.  In that case, I'm unsure of whether there's a good way of eliminating the asymmetry.  The only option I can think of is to not use a stream type for server bidi streams and only use the frame, like for the client initiated bidi streams?\r\n\r\nThanks for the pointer to #21, it looks like there are a few potential designs for datagrams flow IDs.  If in doubt, simpler is probably better.  I'll think more about this one.",
          "createdAt": "2021-01-15T07:37:44Z",
          "updatedAt": "2021-01-15T07:37:44Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree we should use the same mechanics for client and server bidi streams.",
          "createdAt": "2021-01-15T17:04:11Z",
          "updatedAt": "2021-01-15T17:04:11Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After thinking about this more, not having a stream type doesn't seem so bad to me and it does provide symmetry.\r\n\r\nStream types seem like an obvious design choice, but I believe HTTP/3 is sufficiently constrained that one could infer the stream type based on the first frame on the stream.  For example, the control stream MUST start with SETTINGS.  In retrospect, having both stream types and frame types is a bit awkward, and it likely would have been cleaner to only have frame types, but that ship has sailed.",
          "createdAt": "2021-01-15T17:19:16Z",
          "updatedAt": "2021-01-15T17:19:16Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "After having implemented this for hackathon, I can confirm that the lack of stream preface on server-bidi streams is annoying and requires special casing (I actually simulate receiving one).  Let's please add one.\r\n\r\nI took a bit of a shortcut and treated the stream preface as both a stream type AND a frame type.  After peeking at the unidirectional stream input to discover that it's WT, I let the parser run on that and treat it as a frame type, making it symmetric with the bidi case.  Is it possible to define a reserved frame type with the same value as the stream type?",
          "createdAt": "2021-03-03T14:56:00Z",
          "updatedAt": "2021-03-03T14:56:00Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Given HTTP/3 does not have a stream type varint for bidi streams, I think a potential way forward is to say that the first frame on the bidi stream can indicate the 'type' of the stream, but that there is no explicit type identifier on the wire.\r\n\r\n   _Feel free to ignore the below comment, as it's apparently unchanged from January_\r\nLooking back, SETTINGS is required to be the first frame on the control stream, so the control stream type is a bit redundant and the same is true for QPACK and I believe could be true for server push?  Obviously we're not going to redesign HTTP/3 stream and frame types at this stage in the process, but making bidi streams consistent for both perspectives seems preferable to me.",
          "createdAt": "2021-03-05T22:20:46Z",
          "updatedAt": "2021-03-05T22:22:16Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 110.  There seems to be a general agreement that we should make server-initiated bidi streams use the same encoding as client-initiated ones (that is to say, frames).  There was some interest expressed in splitting definition of server-initiated bidi streams into their own draft; @aboba and @DavidSchinazi are to reach out to httpbis about the appropriate venue for that.",
          "createdAt": "2021-03-08T23:57:37Z",
          "updatedAt": "2021-03-08T23:57:37Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Just bringing some of the discussion from #46 here:\r\n\r\nHTTP should provide some consistent guidance for the format of HTTP/3 extension streams.\r\n\r\nClient-bidi extension streams have to start with a frame or series of frames, to be compatible for H3.  One of these frames has to identify the type of stream.  This is how WT is currently specified.\r\n\r\nUnidirectional streams all start with a Stream Type, but after that are inconsistent in H3\r\n* the control stream is: Stream Type + Frames\r\n* QPACK Streams are: Stream Type + QPACK instructions\r\n* Push streams are: Stream Type + Preface (Push ID) + Frames\r\n\r\nStream Type seems like a more general extension mechanism, since it can be used to completely decouple from HTTP/3 frame parsing.",
          "createdAt": "2021-05-14T18:37:48Z",
          "updatedAt": "2021-05-14T18:37:48Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I find stream types to be less extensible than frames: frames allow you to do anything that stream types do, while additionally providing more opportunity for extensibility. I would prefer server-initiated bidirectional streams to behave like client-initiated bidirectional streams instead of unidirectional streams, as that makes implementations simpler.",
          "createdAt": "2021-05-14T19:31:10Z",
          "updatedAt": "2021-05-14T19:31:10Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "January Me said: \r\n\r\n> I agree we should use the same mechanics for client and server bidi streams.\r\n\r\nSo I think I'm arguing against myself and I'm going to stop.\r\n\r\nMy other comments on this thread we that I didn't like was the asymmetry of WT uni streams, which currently are `Stream Type | Preface (Session ID) | Unframed `.  My past self seemed to be advocating that we change WT uni streams to `Stream Type | TV Frame` or perhaps `Stream Type | Preface | TV Frame`.  \r\n\r\nDo we want general guidance about how extensions should use Stream Type vs Frames on unidirectional streams --  specifically that there should be at least one frame?",
          "createdAt": "2021-05-14T20:00:01Z",
          "updatedAt": "2021-05-14T20:00:01Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "The place to put that guidance would have been draft-ietf-quic-http, and I think that ship has sailed.\r\nFor unidirectional streams, I like your framing proposal as that enables extension frames down the road.",
          "createdAt": "2021-05-14T20:15:57Z",
          "updatedAt": "2021-05-14T20:15:57Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, not too late to put out a BCP or something, especially if there's going to be some kind of formal guidance on server-initiated bidi streams.  I'll open a separate issue about changing the WT uni framing.",
          "createdAt": "2021-05-14T20:32:05Z",
          "updatedAt": "2021-05-14T20:32:05Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this specific issue was fixed by #46.  Please reopen if I'm wrong.",
          "createdAt": "2021-07-22T22:41:51Z",
          "updatedAt": "2021-07-22T22:41:51Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "MDU6SXNzdWU3ODYzNjg1Mzc=",
      "title": "Http3Transport Unidirectional Streams section is unclear",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/24",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It talks about the HTTP/3 control stream, which doesn't seem very relevant to establishing new unidirectional streams for WebTransport.\r\n\r\nAlso, I'm unclear on why the HTTP/3 frame type is 54, instead of 41 like the client initiated bidi streams.  Could all WebTransport streams not use a single HTTP/3 frame type?\r\n\r\nhttps://github.com/vasilvv/webtransport/blob/master/draft-vvv-webtransport-http3.md#unidirectional-streams",
      "createdAt": "2021-01-14T21:55:06Z",
      "updatedAt": "2021-03-05T16:04:45Z",
      "closedAt": "2021-03-05T16:04:45Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the text says \"control stream type\" but I think it should just read \"stream type\", per HTTP/3 section 6.2:\r\n\r\n> The purpose is indicated by a stream type, which is sent as a variable-length integer at the start of the stream.\r\n\r\nI agree with Ian that there could be a single uni stream type used for both client and server side streams, since the only difference is their direction, and that's encoded in the stream ID.",
          "createdAt": "2021-01-15T00:41:46Z",
          "updatedAt": "2021-01-15T00:41:46Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, I re-read the spec and now I understand.\r\n\r\n41 is the unidirectional stream type, which is used as a prefix at the beginning of any WebTransport uni stream in either direction.\r\n\r\n54 is a frame type that appears at the beginning of a client-initiated bidi stream, since the H3 spec says the server treats all client-bidi streams as request/response.  I think the new frame is underspecified in the document.  It should be required to have zero length.\r\n\r\nThere's a potential hazard with using a frame to identify the client-initiated bidi WT streams, which is that unknown frame types are allowed to be ignored.  Hopefully no implementation would set the WT SETTINGS field without also having a parser that understands these.",
          "createdAt": "2021-01-15T00:54:57Z",
          "updatedAt": "2021-01-15T00:54:57Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Agh still reading too quickly!\r\n\r\nI see the definition of the frame has no length, which is odd because it is not a proper HTTP/3 frame, per H3 Section 7.1:\r\n\r\n```\r\n7.1. Frame Layout\r\nAll frames have the following format:\r\n\r\nHTTP/3 Frame Format {\r\n  Type (i),\r\n  Length (i),\r\n  Frame Payload (..),\r\n}\r\n```\r\n\r\nOf course this is an extension so we can override this, but it's probably easier on everyone's parser if all frames have both type and length.  We can just state the frame length 0 means \"to the end of the stream\" in this case?\r\n\r\nAlso, the section specifying how uni and bidi streams work have the 54 and 41 opposite from how they appear in the registration sections.",
          "createdAt": "2021-01-15T01:03:45Z",
          "updatedAt": "2021-01-15T01:03:45Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe the QUIC WG decided that TV frames were fine in extensions, but that we weren't going to use them in the core spec?  That being said, maybe the HTTP/3 draft should be updated to note this fact.\r\n\r\nGiven an unknown type is an immediate error condition and a length of 0 is a valid length for frames in general, I think TV is preferable.  Given this is not described in the core spec, it should be called out no matter how it's encoded on the wire.\r\n\r\nThanks for reminding me of stream types vs frame types.  The way the draft is written it's very easy to miss this distinction, so I think it's worth making that a bit clearer.",
          "createdAt": "2021-01-15T07:20:31Z",
          "updatedAt": "2021-01-15T07:24:35Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You can't omit the length field, but we did discuss that 0-length would be fine on a per-frame definition basis.\r\n\r\nIn H3, unknown frames types are simply ignored. Nrgoyiation is not required to negotiate extensions that do not change H3 semantic.",
          "createdAt": "2021-01-15T11:34:28Z",
          "updatedAt": "2021-01-15T11:34:28Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The length issue was discussed at length on the issue: https://github.com/quicwg/base-drafts/issues/1885 and in Tokyo: https://github.com/quicwg/wg-materials/blob/master/interim-19-01/minutes.md#issue-1885data-frame-encoding-is-inefficient-for-long-dynamically-generated-bodies\r\n\r\nI thought the conclusion from Tokyo was that you could do this in an extension, but that's not particularly clear from the issue or minutes.  The discussion both on the issue and in person was fairly all over the place, so it's difficult to summarize.\r\n\r\nWe did make 0 a valid DATA length as part of this series of changes, which makes declaring it a special value now quite odd.",
          "createdAt": "2021-01-15T16:10:19Z",
          "updatedAt": "2021-01-15T16:10:19Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I view it slightly differently, which is that the WebTransport Frame *is* zero length (has no payload), but it's effect is that it declares the remainder of the stream to be unframed.",
          "createdAt": "2021-01-15T17:05:25Z",
          "updatedAt": "2021-01-15T17:05:38Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can't say that I find that intuitive, so it definitely needs to be written up, but that accomplishes what I want, so it WFM.",
          "createdAt": "2021-01-15T17:13:13Z",
          "updatedAt": "2021-01-15T17:13:13Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I split off the TV vs TLV with 0 length question into https://github.com/vasilvv/webtransport/issues/26",
          "createdAt": "2021-01-27T20:01:33Z",
          "updatedAt": "2021-01-27T20:01:33Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Stream types were referred to as control stream types in older versions of HTTP/3 draft, hence the name.  I fixed this a while ago, so closing this.",
          "createdAt": "2021-03-05T16:04:45Z",
          "updatedAt": "2021-03-05T16:04:45Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU3OTUzOTkyMzE=",
      "title": "Are Type-Value frames usable in WebTransport",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/26",
      "state": "CLOSED",
      "author": "ianswett",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I believe the QUIC WG decided that TV frames were fine in extensions, but that we weren't going to use them in the core spec?  Others disagreed with my recollection/understanding.\r\n\r\nSubsequent discussion from Lucas and Alan indicated that TV frames are not allowed in HTTP/3, but it is allowed to have a 0 length frame which indicated the rest of the stream was WebTransport data.  I'm not sure it matters, since either way a peer which doesn't understand the frame is going to parse the stream.  Those that skip the frame will start parsing another frame after it and the parser will enter an unknown state.  Similarly, the behavior for TV is going to be unexpected/unknown.\r\n\r\n_Originally posted by @ianswett in https://github.com/vasilvv/webtransport/issues/24#issuecomment-760704522_\r\n\r\n",
      "createdAt": "2021-01-27T19:55:20Z",
      "updatedAt": "2021-05-07T18:24:22Z",
      "closedAt": "2021-05-07T18:24:22Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I had forgotten that at some point H3 removed the restriction on zero-length DATA frames.  That doesn't prevent an extension from frame using length 0 to indicate the remainder of the stream is unframed however.  I think my implementation would be  easier if we used 0 length, but I've made it work with TV frames and can live with it.\r\n\r\nAnother argument for having a length here is if this extension were to allow an optional header block or other variable length field at the beginning of a WT stream, there's currently no way to know how long it is.",
          "createdAt": "2021-03-03T15:03:31Z",
          "updatedAt": "2021-03-03T15:03:31Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 110.  General agreement in the room was that we don't need length at all, as any parser unaware of WebTransport frames would not be able to parse those streams correctly anyways.",
          "createdAt": "2021-03-08T23:59:10Z",
          "updatedAt": "2021-03-08T23:59:10Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Consensus confirmed on the list, closing.",
          "createdAt": "2021-05-07T18:24:22Z",
          "updatedAt": "2021-05-07T18:24:22Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU4MDA5ODc3NTc=",
      "title": "Draining WebTransport Sessions",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/27",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [
        "afrind"
      ],
      "labels": [
        "ready for PR",
        "ietf-112"
      ],
      "body": "An HTTP/3 server needs the ability to gracefully drain existing connections. For HTTP/3, this involves sending a GOAWAY frame indicating that future requests should use a new HTTP/3 connection. However, the behavior of GOAWAY is partially undefined with WebTransport sessions. \r\n\r\nAfter receiving a GOAWAY, the client is no longer able to make new CONNECT requests. This means that any new WebTransport sessions will need to use a new HTTP/3 connection. This is great.\r\n\r\nHowever, it's not clear how existing sessions should behave after receiving a GOAWAY frame. Are they prohibited from creating new streams? How does this interact with the stream ID sent in the GOAWAY frame? Should the application expose the receipt of a GOAWAY to start a shutdown process?",
      "createdAt": "2021-02-04T06:47:49Z",
      "updatedAt": "2023-02-07T23:13:08Z",
      "closedAt": "2023-02-07T23:13:08Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for opening this issue -- it's been on my mind as well. \r\n\r\nI think it's important that we think through all the graceful draining scenarios, including when there are multiple proxies between the WT client and server, and one of the proxies initiates the drain.\r\n\r\nWe already have a use-case which requires a session to be able to create new streams after the receipt of a connection level GOAWAY.  We've been exploring using a GOAWAY with MAXINT to signal the peer to stop creating new sessions, but continuing to all new streams within existing sessions.  I don't think this totally jives with the definition of GOAWAY in the H3 spec, and I don't think it would work if there were 3 or more intermediaries.\r\n\r\nWhat would happen if WebTransport defined a GOAWAY frame that could be sent on the CONNECT stream to signal the intent to drain a session, but not the connection?",
          "createdAt": "2021-02-04T17:16:03Z",
          "updatedAt": "2021-02-04T17:16:03Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should inform application of GOAWAY signal, and possibly add a GOAWAY on the CONNECT stream for intermediation between proxies.",
          "createdAt": "2021-03-05T15:32:13Z",
          "updatedAt": "2021-03-05T15:32:13Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair notes from IETF 112 meeting: no clear consensus in the room to do this. @afrind has volunteered to write a PR proposal with justification of use-case to help motivate this.",
          "createdAt": "2021-11-09T12:30:50Z",
          "updatedAt": "2021-11-09T12:30:50Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Let me see if I can do the justification here, then draft the PR.\r\n\r\n1. Having a first class mechanism to \"make-before-break\" is a key reliability feature in HTTP/2 and HTTP/3.\r\n2. Intermediaries that carry WebTransport sessions *but do not originate originate them* need a mechanism to tell the application endpoints that draining is happening, so it can't be built exclusively into the application protocols\r\n3. HTTP/3 GOAWAY is too broad when multiple sessions pooled and multiple proxy hops are involved\r\n4. It's cheap to add a message that carries this signal on the CONNECT stream, and it's cheap to ignore it if you want to.\r\n\r\nAs a concrete proposal within the current draft using capsules:\r\n\r\n```\r\nDRAIN_WEBTRANSPORT_SESSION Capsule {\r\n  Type (i) = DRAIN_WEBTRANSPORT_SESSION,\r\n  0\r\n}\r\n```\r\n\r\nI don't think we *need* to include any stream information in the Capsule, such as the highest peer initiated uni and bidi stream IDs received by this endpoint.  Since the signal is delivered to the application endpoints, they can react and generate their own application level signal, if desired.\r\n\r\nThe signal is only useful if it can be delivered to the application.  If we agree this is valuable, should we open an issue for W3C?\r\n\r\nWriting this up made me realize that the WT over HTTP/3 draft doesn't describe how it interacts with GOAWAY.  I opened #67 to track that.",
          "createdAt": "2021-11-10T21:07:07Z",
          "updatedAt": "2021-11-10T21:07:07Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in the room at IETF113, @afrind will write a PR",
          "createdAt": "2022-03-24T14:05:50Z",
          "updatedAt": "2022-03-24T14:05:50Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWU4MDE3MDAzMDU=",
      "title": "Session Establishment Race",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/28",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "> From the client's perspective, a WebTransport session is established when the client receives a 200 response. From the server's perspective, a session is established once it sends a 200 response. Both endpoints MUST NOT open any streams or send any datagrams on a given session before that session is established.\r\n\r\nAfter the client initiates the WebTransport session by sending a CONNECT request, the server sends a 200 response and is free to create streams. This means that a server-initiated stream may arrive prior to the CONNECT response. Is the client able to infer that the session was successfully established, or does the client need to buffer this stream until it receives a proper response?",
      "createdAt": "2021-02-04T23:01:59Z",
      "updatedAt": "2021-05-14T03:18:03Z",
      "closedAt": "2021-05-14T03:18:03Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since there are no ordering guarantees across streams on the receiver side, I'd say you have to buffer until the 200 is processed.",
          "createdAt": "2021-02-04T23:18:23Z",
          "updatedAt": "2021-02-04T23:18:23Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with Lucas here.  We also had a similar problem in QuicTransport (server has to buffer streams before checking the origin), and we handled it by buffering.",
          "createdAt": "2021-03-05T15:36:49Z",
          "updatedAt": "2021-03-05T15:36:49Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 110.  There were no objections to buffering (with some limits), so I think we should go ahead and add it.",
          "createdAt": "2021-03-09T00:00:48Z",
          "updatedAt": "2021-03-09T00:00:48Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWU4MDE3MTAxMDE=",
      "title": "Session Establishment Round Trips",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/29",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "For a simple application that wants to send \"hello world\" over a WebTransport stream, it would take a minimum of 2.5 round trips for the data to arrive on the server. This is still an improvement over WebSockets but I'm wondering if we could do better.\r\n\r\n> From the client's perspective, a WebTransport session is established when the client receives a 200 response. From the server's perspective, a session is established once it sends a 200 response. Both endpoints MUST NOT open any streams or send any datagrams on a given session before that session is established.\r\n\r\nIf the client is able to create streams prior to receiving the CONNECT response, then it would remove a round trip. The server would need to buffer any data received on streams associated with an unknown WebTransport session. If the server responds with a non-200 status code, then these streams are discarded.\r\n\r\n> WebTransport over HTTP/3 does not support 0-RTT.\r\n\r\nI believe 0-RTT is disabled for WebTransport because CONNECT is not idempotent and would be subject to replay attacks. An idempotent CONNECT would remove a round trip when 0-RTT is used... although I'm not sure this is a good idea.",
      "createdAt": "2021-02-04T23:21:57Z",
      "updatedAt": "2021-05-18T04:07:39Z",
      "closedAt": "2021-05-18T04:07:39Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> If the client is able to create streams prior to receiving the CONNECT response, then it would remove a round trip. The server would need to buffer any data received on streams associated with an unknown WebTransport session. If the server responds with a non-200 status code, then these streams are discarded.\r\n\r\nI think this is a reasonable optimization",
          "createdAt": "2021-02-04T23:25:58Z",
          "updatedAt": "2021-02-04T23:25:58Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The client requirement is odd in comparison to MASQUE / CONNECT-UDP which says \"client can risk sending datagrams before getting a 200 response, a different response means that datagrams will be discarded\". \r\n\r\nWhat is the motivation for the requirement in WebTransport? If you need some kind of ordering guarantees, then stream IDs provide that.",
          "createdAt": "2021-02-04T23:28:01Z",
          "updatedAt": "2021-02-04T23:28:01Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 110.  There were no objections to buffering (with some limits), so I think we should go ahead and add it.",
          "createdAt": "2021-03-09T00:00:55Z",
          "updatedAt": "2021-03-09T00:00:55Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWU4MTI1MDYzNTc=",
      "title": "Section 4.4: Path MTU computation",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/30",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From Section 4.4: \r\n\r\n\"TODO: Describe how the path MTU can be computed, specifically propagation across HTTP proxies.\"",
      "createdAt": "2021-02-20T03:54:47Z",
      "updatedAt": "2022-03-17T19:35:13Z",
      "closedAt": "2022-03-17T15:57:32Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "My idea was to use headers to figure this out (ietf-wg-masque/draft-ietf-masque-h3-datagram#28).  That doesn't really work for various reasons.  I suggest we wait until MASQUE working group resolves this in something like ietf-wg-masque/draft-ietf-masque-h3-datagram#65.",
          "createdAt": "2021-07-22T23:09:15Z",
          "updatedAt": "2021-07-22T23:09:15Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "NONE",
          "body": "I would strongly recommend that you make clear what requirements you have on MTU discovery from the HTTP layer for Webtrans usage of Datagram. The ongoing discussion is if HTTP Datagram will have to implement anything more than just dropping oversized HTTP Datagram. ",
          "createdAt": "2021-07-26T20:30:50Z",
          "updatedAt": "2021-07-26T20:30:50Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "It appears to me that the MASQUE working group decided to not do anything special about MTU handling, meaning this basically means we have to close this with no action.",
          "createdAt": "2022-03-17T15:57:12Z",
          "updatedAt": "2022-03-17T15:57:12Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@vasilvv that's not quite right - the MASQUE working group decided to not enable extensibility or MTU discovery at the HTTP Datagrams layer, instead leaving this up to individual applications / HTTP upgrade tokens. Therefore WebTransport could potentially define something at the WebTransport layer if it wished to. I'm not suggesting that this would be a good idea, just mentioning that it's possible",
          "createdAt": "2022-03-17T19:35:13Z",
          "updatedAt": "2022-03-17T19:35:13Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "MDU6SXNzdWU4MTQwNzM0Mjg=",
      "title": "Ambiguous RESET_STREAM",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/31",
      "state": "CLOSED",
      "author": "kixelated",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "If a peer receives a RESET_STREAM message before it receives the first few bytes of the stream, then it is unable associate the RESET_STREAM with a protocol or session. This can occur if the STREAM packet is lost but the RESET_STREAM is not.\r\n\r\nAs a consequence, if a WebTransport client closes a stream with an error code, then it's not guaranteed to be received by the server. Worse yet, a reset client-initiated bidirectional stream may be confused for a HTTP/3 request and cause intended consequences.",
      "createdAt": "2021-02-23T03:49:41Z",
      "updatedAt": "2021-11-05T19:39:01Z",
      "closedAt": "2021-11-05T19:39:00Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you give a more concrete example of when this is a problem?\r\n\r\nYou are saying the client opened a unidirectional or bidirectional WT stream, sent some data, then reset it.  The server receives only the reset, or some fraction of the data but not enough to figure out which session the stream belongs to.  I think this is fine and the server just discards any partial data on this stream.\r\n\r\nIf the application needs to receive the data (even just an error code) in the stream, then the client shouldn't reset it, but instead, send some application level close signal that is delivered reliably on the stream.\r\n\r\nI don't see how an H3 server could act on any stream data from the client without seeing the beginning of the stream, so I don't think there's much concern about this being served as an H3 request.",
          "createdAt": "2021-02-23T16:37:50Z",
          "updatedAt": "2021-02-23T16:37:50Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "Sure. I suppose the problem is the reliable delivery of error codes. \r\n\r\nIf the application closes a stream with an integer code via the [WebTransport API](https://w3c.github.io/webtransport/#dom-outgoingstream-abortwriting), then I would expect that code to be reliably delivered to the other peer. This ambiguous RESET_STREAM case opens the possibility of the code not being associated with a WebTransport session, and thus not delivered, depending on packet loss.",
          "createdAt": "2021-02-23T19:14:15Z",
          "updatedAt": "2021-02-23T19:14:15Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Iiuc the problem is if the stream is reset before the Web Transport frame is processed (as far the *current* spec says). That frame associates the stream to the web transport session. A peer that receives the RESET_STREAM know something was cancelled but not whether it was a normal request or a webtransport stream. \r\n\r\nThis highlights a challenge with retconning what bidirectional streams mean for a H3 stack. ",
          "createdAt": "2021-02-23T19:23:23Z",
          "updatedAt": "2021-02-23T19:23:23Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I can construct an application where it's important that the peer knows about every stream that gets created, even if it is reset before anything interesting happens, but it strikes me as a bit fringy.  Can you give a concrete example where the WT endpoint missing the reset stream entirely is problematic?",
          "createdAt": "2021-02-23T19:30:07Z",
          "updatedAt": "2021-02-23T19:30:07Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The only example I can think of relates to session pooling and wanting different concurrency limits in sessions. Since we decided to focus on single sessions for now, my example I'd moot. I'd be interested to know Luke's example ",
          "createdAt": "2021-02-23T19:38:44Z",
          "updatedAt": "2021-02-23T19:38:44Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "> I can construct an application where it's important that the peer knows about every stream that gets created, even if it is reset before anything interesting happens, but it strikes me as a bit fringy. Can you give a concrete example where the WT endpoint missing the reset stream entirely is problematic?\r\n\r\nIronically, the best example is an application implementing a replacement for MAX_STREAMS. Peers can't set a cumulative limit if they disagree on the number of streams created. ex. peer A creates and resets a stream, so it thinks 10 have been created in total, but packet loss could cause peer B to think only 9 have been created in total. This can eventually cause a deadlock.\r\n\r\nAnd yeah, it's pretty easy to imagine an application that uses stream resets. The WebTransport API makes stream closure seem reliable, when really there's a small chance that it gets silently dropped.",
          "createdAt": "2021-02-23T23:15:01Z",
          "updatedAt": "2021-02-23T23:16:03Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This seems like another case of where a \"session layer\" over QUIC would assist. The trouble is, in my limited understanding of the W3C WebTransport API, that it wants to use a QUIC transport feature to manage WebTransport sessions. It is going to be let down by the fact the transport behaves differently than it wishes. \r\n\r\ndraft-ietf-webtrans-http3-00 defines the WEBTRANSPORT_STREAM HTTP/3 frame for initiating WebTransport streams. So it probably needs an equivalent frame for closing WebTransport streams. This could be sent on the stream itself, on a new \"webtransport session control stream\", or on the global control stream.",
          "createdAt": "2021-02-24T00:15:52Z",
          "updatedAt": "2021-02-24T00:15:52Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> This could be sent on the stream itself, on a new \"webtransport session control stream\", or on the global control stream.\r\n\r\nBy 'on the stream itself', do you mean on the CONNECT stream that established the session?  The current draft disables framing on WT streams.  It could be a message like QPACK, where streams that are cancelled have an application level signal.",
          "createdAt": "2021-02-24T17:00:32Z",
          "updatedAt": "2021-02-24T17:00:32Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> By 'on the stream itself', do you mean on the CONNECT stream that established the session?\r\n\r\nNo. If I understand (and that's a big if) the design of draft-ietf-webtrans-http3-00 requires\r\n\r\nstep 1) use extended  CONNECT on client bidi stream to create a WebTransport session\r\n\r\nstep 2) create WebTransport stream on different client bidi stream using WEBTRANSPORT_STREAM frame https://tools.ietf.org/html/draft-ietf-webtrans-http3-00#section-4.2\r\n\r\nMy suggestion wasn't about retiring WebTransport sessions, but retiring streams robustly at the application layer. If you created a stream using an H3 frame, retire it with an H3 frame.\r\n\r\nAlthough we adopted draft-ietf-webtrans-http3-00, I;m not sure how much of the design is appropriate/relevant to the non-pooling constraints we have added. So i guess my current understanding could be subject to change.",
          "createdAt": "2021-02-24T17:07:53Z",
          "updatedAt": "2021-02-24T17:07:53Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "The current draft uses a 'TV' frame on streams created in step 2) that makes sending additional frames on those streams impossible.  I'm suggesting we could use the stream created in step 1) as a \"webtransport session control stream\", if needed.",
          "createdAt": "2021-02-24T18:11:58Z",
          "updatedAt": "2021-02-24T18:11:58Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah yes, I overlooked that. In that case I agree",
          "createdAt": "2021-02-24T18:16:09Z",
          "updatedAt": "2021-02-24T18:16:09Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I was thinking about how to make those more reliable.  One way would be to send a capsule with something like \"stream X associated with this transport has been reset\".  That doesn't work, because the peers don't have consistent stream IDs across possible HTTP proxies.\r\n\r\nI think the approach we should probably go with is \"stream resets are usually not reliable\".  As an API caveat, we should make sure that when the connection is dedicated, all resets with WebTransport error codes are followed to the client, since those are unambiguous.",
          "createdAt": "2021-07-22T23:28:15Z",
          "updatedAt": "2021-07-22T23:28:15Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "This was fixed in #59.",
          "createdAt": "2021-11-05T19:39:00Z",
          "updatedAt": "2021-11-05T19:39:00Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWU4MjEzMjUzNjc=",
      "title": "Specify behavior when receiving a bad session ID",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/32",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The H3 draft is light on error handling guidance.  There are number of cases for bad session IDs:\r\n\r\n1. The session ID is not a client initiated bidirectional stream ID\r\n2. The session ID refers to a stream that did not perform a WebTransport handshake\r\n3. The session ID refers to a stream that has been closed or reset\r\n\r\nPresumably there is no error when a DATAGRAM arrives with a bad session id -- you just drop it?\r\n\r\nFor streams, perhaps HTTP_ID_ERROR is appropriate?\r\n\r\nIssues #28 and #29 both refer to cases where you receive a session ID that has not been created yet.  Best to keep the discussion there, but it's likely we want to allow clients/servers to buffer some of these at their own discretion rather than require an error.",
      "createdAt": "2021-03-03T17:29:06Z",
      "updatedAt": "2021-09-08T19:38:25Z",
      "closedAt": "2021-09-08T19:38:25Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "For 1, I think it should be an error.\r\n\r\nFor 2, we may want to clarify that the headers should be already known at that point, but it should be an error.\r\n\r\nFor 3, I am not sure how to enforce this without running into potential race conditions, so we may want to leave those as-is.\r\n\r\nAs for the datagrams, I think h3-datagram draft should handle this.",
          "createdAt": "2021-07-22T23:32:33Z",
          "updatedAt": "2021-07-22T23:32:33Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Thinking about 2 more, I think there's also a race condition in which a data stream could be received between the stream being open and headers being processed.  I'll write up a PR for 1.",
          "createdAt": "2021-07-28T22:29:06Z",
          "updatedAt": "2021-07-28T22:29:06Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I think for 2, I meant the ID refers to a stream where the headers were known but it was not a CONNECT stream.",
          "createdAt": "2021-07-29T15:11:54Z",
          "updatedAt": "2021-07-29T15:11:54Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 111.  Sense of the room for MUST close for 1, MAY close in other scenarios.",
          "createdAt": "2021-07-30T19:35:23Z",
          "updatedAt": "2021-07-30T19:35:31Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWU4MjIyMjk3MzU=",
      "title": "Should WT streams be reset when the CONNECT stream terminates",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/33",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The draft currently states:\r\n\r\n> Upon learning about the session being terminated, the endpoint MUST stop sending new datagrams and reset all of the streams associated with the session.\r\n\r\nIt's clear that without a CONNECT stream that new streams cannot be created and datagrams cannot be sent, but WT streams that were opened for that session could continue operating normally.  This is how push streams are handled in H2 and H3 -- the push stream continues even if the associated stream is terminated.\r\n\r\nAn endpoint always has the option to reset/stop sending WT streams when the session terminates.\r\n\r\nThis is somewhat related to the graceful drain issue (#27)",
      "createdAt": "2021-03-04T15:17:59Z",
      "updatedAt": "2022-06-27T14:54:32Z",
      "closedAt": "2022-06-27T14:54:32Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 110.  We should keep the current behavior for now, and revisit once we have more implementation experience.",
          "createdAt": "2021-03-09T00:02:08Z",
          "updatedAt": "2021-03-09T00:02:08Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at 113, consensus in room to have close of CONNECT stream close all webtransport streams and datagrams. @vasilvv will double-check that this is what the draft currently says",
          "createdAt": "2022-03-24T14:07:21Z",
          "updatedAt": "2022-03-24T14:07:21Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Draft says:\r\n\r\n> Upon learning that the session has been terminated, the endpoint MUST reset all of the streams associated with the session\r\n\r\nThat should be sufficient (I've opened #75 to add an error code)",
          "createdAt": "2022-06-27T14:54:32Z",
          "updatedAt": "2022-06-27T14:54:32Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWU4MjIzMzYwMjk=",
      "title": "Negotiation of pooling support",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/34",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ekinnear"
      ],
      "labels": [
        "pooling",
        "capsule-dt",
        "ietf-113"
      ],
      "body": "The H3 draft by its nature allows for the parallel processing of multiple WT sessions and also the intermixing of normal H3 request with WT.  Server endpoints may wish to negotiate or disable this behavior.  Clients can simply choose not to do either kind of pooling if they don't want to.\r\n\r\nThere's already a PR open (#25) with a design idea.",
      "createdAt": "2021-03-04T17:16:48Z",
      "updatedAt": "2022-12-16T19:10:12Z",
      "closedAt": "2022-12-16T19:10:12Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to propose a different model than the one in #25:\r\n\r\nThe server sends the maximum WebTransport Session ID, or since 0 is a valid value, it's really the minimum invalid WebTransport Session ID.\r\n\r\nTo indicate WT is not supported, server sends 0.\r\nTo allow for only 1 session ever, server sends 4, and never updates it.\r\nTo allow for only 1 session *at a time*, server sends 4, and updates it by 4 as each session closes/resets.\r\nTo allow for N parallel sessions, server sends 4 * N. and updates as sessions close/reset.\r\n\r\nThis mirrors H3 PUSH, and requires at least one more frame (MAX_WT_SESSION_ID).  Perhaps it would also require CANCEL_WT_SESSION?\r\n\r\nA client need only declare that it supports webtransport, and even that could be optional.  The server will know if it receives a CONNECT with :protocol=webtransport.",
          "createdAt": "2021-03-04T17:18:30Z",
          "updatedAt": "2021-03-04T17:18:30Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I wanted to have a negotiation mechanism in #25, but my conclusion after talking with @DavidSchinazi about it was that we should not do negotiation, and servers should just reject extra streams with a 400 (or maybe even a RESET_STREAM) if they ever see more sessions than they expect; meaning it's on the clients to know if they can pool or not.",
          "createdAt": "2021-03-05T17:03:25Z",
          "updatedAt": "2021-03-05T17:03:25Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Though we may want a more specific 4XX error code so the client knows it should retry in a non-pooled connection",
          "createdAt": "2021-03-05T17:35:23Z",
          "updatedAt": "2021-03-05T17:35:23Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "That's certainly a lot simpler than session credits ;)  The cost of at least an RTT for a client that tries to pool against a server that can't handle it seems somewhat high.  I guess it depends what the common client pooling strategies are and how many servers don't support pooling.",
          "createdAt": "2021-03-05T17:42:02Z",
          "updatedAt": "2021-03-05T17:42:02Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind since it's looking like the JavaScript API will provide a way to disable pooling, I expect that the scenario of pooling-attempted-but-rejected will be quite rare, so a round trip cost should be acceptable",
          "createdAt": "2021-03-05T18:33:56Z",
          "updatedAt": "2021-03-05T18:33:56Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm also considering use cases for WT which are not tied to the JS API.",
          "createdAt": "2021-03-05T18:36:47Z",
          "updatedAt": "2021-03-05T18:36:47Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind that's interesting - and those use-cases won't have a similar mechanism to disable pooling? I suspect they'll need a way to get the WT server's hostname somehow, and having config properties attached to that (such as disable_pooling) could be useful?",
          "createdAt": "2021-03-05T20:47:02Z",
          "updatedAt": "2021-03-05T20:47:02Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@DavidSchinazi : the opposite -- the clients may attempt pooling to servers that might or might not support it.  You can't tell from a hostname if it supports pooling.",
          "createdAt": "2021-03-06T00:26:18Z",
          "updatedAt": "2021-03-06T00:26:18Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind how did the client get the hostname in the first place? I'm suggesting to carry pooling_support next to that.",
          "createdAt": "2021-03-06T00:36:49Z",
          "updatedAt": "2021-03-06T00:36:49Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, let's go back to JS for a second.  The people who write JS at Facebook are very unlikely to know if the edge server terminating their connection supports pooling, or that configuration could change over time.",
          "createdAt": "2021-03-06T00:47:25Z",
          "updatedAt": "2021-03-06T00:47:25Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "(I appreciate the irony of me saying this as a Googler, but) should the JS people talk to the edge people? I agree that this shouldn't fail, but it being inefficient seems reasonable - these teams should talk if they're trying to reach good performance.",
          "createdAt": "2021-03-06T01:33:08Z",
          "updatedAt": "2021-03-06T01:33:08Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I think my main problem with `MAX_WT_SESSION_ID` is that most people who want to disallow pooling want to exclude not only other WebTransport sessions, but also general HTTP traffic.  #25 was written with that assumption in mind.",
          "createdAt": "2021-03-06T20:15:45Z",
          "updatedAt": "2021-03-06T20:15:45Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Ok, MAX_WT_SESSION_ID doesn't handle that case, so it may be an over-engineered solution to the wrong problem.\r\n",
          "createdAt": "2021-03-08T15:32:01Z",
          "updatedAt": "2021-03-08T15:32:01Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As I said in the meeting, I don't think that we should have any signals for dedicated connections from either client or server.\r\n\r\nYutaka made the point that the client can decide to make a connection dedicated after seeing the server settings.  It doesn't need to signal its intent (and signaling would have negative privacy consequences potentially).  I agree with this observation.\r\n\r\nA server needs to support HTTP if we're using HTTP.  So pooling with h3 is already a settled matter.  If the server doesn't want to answer requests, it can use 406 or 421 or other HTTP mechanisms to tell the client to go away.  More generally, the server can just not provide links to that server, such that it might have to respond to GET/OPTIONS/POST/etc.  The question then becomes managing resource limits on the server.  Having a way to limit the number of WebTransport sessions is a good thing and I believe that will be sufficient for this.\r\n\r\nThus, I'm a supporter of option 3: MAX_WT_SESSIONS or similar.",
          "createdAt": "2021-03-08T17:47:15Z",
          "updatedAt": "2021-03-09T11:19:24Z"
        },
        {
          "author": "ddragana",
          "authorAssociation": "NONE",
          "body": "I agree that we should have limits of how many WT can be active at the same time on a connection. It should also define what happens if the limit is exceeded. Should a client open another QUIC connection to the same server or should it fail? Probably it should be former, but that should also have limits defined (6 parallel QUIC connection, may be too much? HTTP/1.1 have the 6 parallel connection limit). ",
          "createdAt": "2021-03-23T11:46:06Z",
          "updatedAt": "2021-03-23T11:46:06Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at IETF 113, consensus in room to change the WT SETTING to carry the number of concurrent WT sessions allowed on this h3 connection",
          "createdAt": "2022-03-24T14:31:42Z",
          "updatedAt": "2022-03-24T14:31:42Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWU4MjIzNjEyMzg=",
      "title": "Alignment with MASQUE/CONNECT-UDP",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/35",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If you ignore WebTransport streams, then the base functionality of WebTransport and CONNECT-UDP+H3 DATAGRAM is virtually identical:\r\n\r\n1. Client sends a HTTP/3 CONNECT(-UDP) request to establish a session, with a unique identifier\r\n2. The lifetime of that stream establishes the lifetime of the session\r\n3. The endpoints can exchange DATAGRAMS using the session ID as the flow ID\r\n\r\nGranted there are important differences -- CONNECT-UDP has particular semantics for the receiver, and needs mechanisms for transport level extensions.  I don't think they can be completely consolidated or factored out.\r\n\r\nNegotiation and pooling support look different at this point -- there doesn't seem to be active discussion that a server endpoint should limit the number of open CONNECT-UDP sessions, or how they can be multiplexed with standard H3, but in WT it's more controversial.\r\n\r\nAre there any opportunities for better alignment here?",
      "createdAt": "2021-03-04T17:49:56Z",
      "updatedAt": "2021-11-09T11:59:31Z",
      "closedAt": "2021-11-09T11:59:31Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind what do you mean by better alignment? In what way are CONNECT_UDP and WT3 not aligned?",
          "createdAt": "2021-03-04T18:16:09Z",
          "updatedAt": "2021-03-04T18:16:09Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@DavidSchinazi : Mostly around feature negotiation and pooling support.",
          "createdAt": "2021-03-04T18:17:30Z",
          "updatedAt": "2021-03-04T18:17:30Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "The Session ID/Flow ID assignment is also different.  The MASQUE approach strikes me overkill in WT, so I'm not sure we'd want to use the same mechanism for both.",
          "createdAt": "2021-03-04T18:19:26Z",
          "updatedAt": "2021-03-04T18:19:26Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding pooling, I think that is completely specific to WT3. I don't see value in controlling the ability to pool CONNECT-UDP more than we have the ability to control pooling of CONNECT or even GET. Do you have a use-case for this?\r\n\r\nRegarding feature negotiation, don't they both use HTTP headers?",
          "createdAt": "2021-03-04T18:19:46Z",
          "updatedAt": "2021-03-04T18:19:46Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding Session ID, since WT3 needs a Datagram Flow ID regardless, I'd suggest using that as the Session ID for simplicity.",
          "createdAt": "2021-03-04T18:20:38Z",
          "updatedAt": "2021-03-04T18:20:38Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@DavidSchinazi : \r\n\r\nre: pooling: it's just a bit strange to have the divergence between MASQUE (no need to limit pooling) and WT (must have strict limits on pooling).  Why is this?\r\n\r\nre: feature negotiation: I was referring to different SETTINGs/negotiation strategy up front rather than the session establishment.  CONNECT+headers is fine.\r\n\r\nre: session ID: why does WT3 need a flow-id?  It would only need one if it uses \"H3 DATAGRAM\" but right now it's using QUIC DATAGRAM.  I'm not sure H3 DATAGRAM brings much value to WT right now, but this is a good example of where we should either align, or perhaps document why we are not aligned.",
          "createdAt": "2021-03-04T18:26:32Z",
          "updatedAt": "2021-03-04T18:26:32Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding pooling, I think WT3 is diverging from all other HTTP semantics here, not just CONNECT-UDP. I don't see why CONNECT-UDP should diverge from GET because WT3 is diverging from GET.\r\n\r\nRegarding negotiation, WT3 needs a SETTING because it changes HTTP/3 semantics (e.g., the semantics of server-initiated bidirectional streams) whereas CONNECT-UDP doesn't change HTTP/3 semantics. Note that H3-DGRAM has a SETTING because it changes the semantics of the DATAGRAM frame in h3 connections.\r\n\r\nRegarding datagram flow ID, WT3 needs a datagram flow ID in order to support multiplexing with other h3 datagram traffic, such as CONNECT-UDP. If we want WT3 to support pooling with other HTTP/3 methods (even if that's optional and disabled by default), we'll need a datagram flow ID.",
          "createdAt": "2021-03-04T18:37:08Z",
          "updatedAt": "2021-03-04T18:37:08Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> Regarding datagram flow ID, WT3 needs a datagram flow ID in order to support multiplexing with other h3 datagram traffic, such as CONNECT-UDP. If we want WT3 to support pooling with other HTTP/3 methods (even if that's optional and disabled by default), we'll need a datagram flow ID.\r\n\r\nAh - if you want to multiplex WT with any *other* HTTP/3 traffic that uses H3 DATAGRAMs, then you could have collisions with Flow-IDs.  We should open a separate issue for this.",
          "createdAt": "2021-03-04T19:01:41Z",
          "updatedAt": "2021-03-04T19:01:41Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I think my proposal would be to just do whatever draft-ietf-h3-datagram does.  That said, we would need to add text regarding context IDs.",
          "createdAt": "2021-07-26T12:05:08Z",
          "updatedAt": "2021-07-26T12:05:08Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the alignment is getting there (both using extended CONNECT, etc), and I don't have any more specific suggestions for now, especially while MASQUE appears to still be in flux pending design team outcome.",
          "createdAt": "2021-11-09T11:59:31Z",
          "updatedAt": "2021-11-09T11:59:31Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "MDU6SXNzdWU4MjIzNzA1OTU=",
      "title": "Session layer resource management",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/36",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "pooling"
      ],
      "body": "QUIC manages resources, specifically streams and flow control, at the transport layer.  Since the H3 draft allows pooling, those mechanisms may be inadequate in cases where WT sessions are multiplexed with each other or standard H3.\r\n\r\nThere are two issues open tracking some different bits of this (#22/Flow Control) and (#31/~Streams), this issue is tracking whether we need to solve that by adding functionality at the WT session layer.   #27 tracks the interpretation of GOAWAY and this could also be a session level concept.\r\n\r\nThis might look like a set of frames for granting stream and flow control credit, which would presumably be a subset of the QUIC transport credit.\r\n\r\nSome arguments against this:\r\n\r\n1. Endpoints that require the resource management features of the transport can disable pooling and fall back to the transport for these.\r\n2. These problems already exist in clients that pool HTTP connections to the same server between different applications (eg: browser tabs) that are generally unaware of each other.\r\n3. \"complexity\"",
      "createdAt": "2021-03-04T18:02:26Z",
      "updatedAt": "2022-03-24T14:37:28Z",
      "closedAt": "2022-03-24T14:37:27Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair notes from IETF 112 meeting: this needs more discussion (on the issue or mailing list)",
          "createdAt": "2021-11-09T12:43:04Z",
          "updatedAt": "2021-11-09T12:43:04Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at 113, closing in favor of #22",
          "createdAt": "2022-03-24T14:37:27Z",
          "updatedAt": "2022-03-24T14:37:27Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU4MjI0MTU2Njk=",
      "title": "QUIC DATAGRAM vs H3 DATAGRAM",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/37",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "WT currently uses QUIC DATAGRAMS (eg: no Flow-Id), and does it's own demultiplexing via the session ID.  This is incompatible with multiplexing other applications that use H3 DATAGRAMs, since the Flow-ID could collide with the session ID, depending on how it is chosen.\r\n\r\nThere was some discussion of this already in a PR on victor's repo: https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/21#discussion_r520160334",
      "createdAt": "2021-03-04T19:05:23Z",
      "updatedAt": "2021-11-05T15:31:32Z",
      "closedAt": "2021-11-05T15:31:32Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "We should use whatever H3 DATAGRAM draft decides in order to be able to coexist with MASQUE.  I've mostly not updated the draft because I don't think there is an exact consensus for H3 DATAGRAM on the exact approach.",
          "createdAt": "2021-03-05T17:24:37Z",
          "updatedAt": "2021-03-05T17:24:37Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I think MASQUE and WT have achieved parity for now",
          "createdAt": "2021-11-05T15:31:32Z",
          "updatedAt": "2021-11-05T15:31:32Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWU4MjM3MzA4MTU=",
      "title": "URI scheme identifying WebTransport over HTTP",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/38",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We need to pick one.  The main two options are `https:` and `wt:`.\r\n\r\nWe've discussed this separately within W3C (see w3c/webtransport#198), and the conclusion there was that it would make more sense to just use `https:` URIs.  We should discuss this at the upcoming IETF meeting.",
      "createdAt": "2021-03-06T19:40:57Z",
      "updatedAt": "2021-05-07T18:24:05Z",
      "closedAt": "2021-05-07T18:24:04Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "(No hats) I think using https would be the simplest option here, so I'd be inclined to go with that",
          "createdAt": "2021-03-06T21:57:08Z",
          "updatedAt": "2021-03-06T21:57:08Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 110.  Consensus in the room was for using `https:`.",
          "createdAt": "2021-03-09T00:02:37Z",
          "updatedAt": "2021-03-09T00:02:37Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Consensus confirmed on the list, the scheme in the draft is already `https`.  Closing this.",
          "createdAt": "2021-05-07T18:24:04Z",
          "updatedAt": "2021-05-07T18:24:04Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWU4NDI1MDI3MTY=",
      "title": "SETTINGS_ENABLE_WEBTRANSPORT from the client",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/39",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "How necessary is to wait for SETTINGS_ENABLE_WEBTRANSPORT from the client?  If we are a server, and we receive a request with `:protocol` set to `webtransport`, this seems like a pretty solid indication of support.  From the current language in the draft, though, the server has to pause the processing of the request in question until the SETTINGS are there (which is really annoying to implement).\r\n\r\nOne counterpoint I can see is that we could use settings to negotiate a specific version of WebTransport over HTTP/3, and in that case we *do* need to wait for settings from both parties.",
      "createdAt": "2021-03-27T13:18:06Z",
      "updatedAt": "2021-09-08T19:38:54Z",
      "closedAt": "2021-09-08T19:38:54Z",
      "comments": [
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I really do not like the idea of delaying the processing of requests on the server side, as it seems bug/attack prone.\r\n\r\nGiven the client has to initiate the webtransport session, and there's no guarantee the client's SETTINGs will arrive before the servers(without something like ALPS), why not only have the server send the setting?  For example, websockets in H2 only requires a setting from server to client.",
          "createdAt": "2021-03-27T15:08:33Z",
          "updatedAt": "2021-03-27T15:08:33Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "One tricky thing here is that whatever we do here, it has to also work with the H3_DATAGRAM setting.",
          "createdAt": "2021-03-27T16:40:20Z",
          "updatedAt": "2021-03-27T16:40:20Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd suggest adding some requirements like:\r\n1) The server MUST indicate support for both WebTransport and H3 datagram, or the connection MUST be closed.\r\n2) The server MUST assume that if the client uses protocol \"webtransport\", that it supports both WebTransport and H3 datagram, and sending the SETTING is optional.\r\n\r\nBut you make a good point that this could crop up in CONNECT-UDP and a few other uses of H3-Datagram.  If the client is always responsible for initiating the datagram flow(s), then the SETTING for h3-datagram only needs to be sent server to client.",
          "createdAt": "2021-03-27T18:16:00Z",
          "updatedAt": "2021-03-27T18:19:10Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at the May 2021 interim.  The agreement in the room seemed to be that this is unavoidable if we want to use SETTINGS for determining the version of WebTransport to use by the server.",
          "createdAt": "2021-05-21T16:09:08Z",
          "updatedAt": "2021-05-21T16:09:08Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWU4NDQ4MDE3NDY=",
      "title": "RESET_STREAM error codes",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/40",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If we are going to let the API users supply their own stream reset code, we should figure out how this is represented on the wire.  We could potentially use the error codes as-is and say they mean different things for WebTransport streams than what they mean for normal streams, but I am not sure this is sound as we don't always know that a stream is a WebTransport stream at the time we process the reset (also this sounds like a pain to implement).\r\n\r\nOne possibility would be to reserve a block within HTTP/3 error code space.  However, since HTTP/3 error codes contain GREASE code-points throughout, we might end up having to \"de-grease\" and \"re-grease\" them as the largest continuous block only has 255 codepoints available.\r\n\r\nAlternatively, if we decide to just send RESET_STREAM as a part of CONNECT stream due to issues in #31, we could just send the error code there, and keep one single code for user-initiated termination.\r\n\r\nWhatever we decide here should probably work for H/2 as well.\r\n\r\ncc @martinthomson",
      "createdAt": "2021-03-30T16:06:50Z",
      "updatedAt": "2021-09-08T19:39:31Z",
      "closedAt": "2021-09-08T19:39:31Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Are application developers asking for custom reset error codes? Making reset unreliable and non-customizable would be much easier if that's sufficient for everyone's needs.",
          "createdAt": "2021-03-30T16:09:20Z",
          "updatedAt": "2021-03-30T16:09:20Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Reset error codes are special in the sense that they are reliably delivered by the transport (unlike the data, which all can be lost to a reset).  So I imagine an application would want to be able to tell apart a regular reset (e.g. due to stream TTL expiring), vs reset due to an error.\r\n\r\n@kixelated might have opinions on this, since he filed #31.",
          "createdAt": "2021-03-30T16:24:22Z",
          "updatedAt": "2021-03-30T16:24:22Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We went through a concerted effort to reduce the number of H3 error codes. Partly because knowing when to use the right code (from an implementation persepctive) can be hard. \r\n\r\nH2's space is small, I don't know if the experts would allow one application to reserve a large block.\r\n\r\nAt a minimum we probably need a WEBTRANS_NO_ERROR. Maybe there are some error codes for \"Web transport wire protocol error\". Anticipating more specific error codes for apps using webtransport is hard. Some motivating use cases might help. ",
          "createdAt": "2021-03-30T16:58:48Z",
          "updatedAt": "2021-03-30T16:58:48Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> H2's space is small, I don't know if the experts would allow one application to reserve a large block.\r\n\r\nIt's 32-bit, so I think we could probably get 16 bits worth of error codes.",
          "createdAt": "2021-03-30T17:36:54Z",
          "updatedAt": "2021-03-30T17:36:54Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah quire right, I was getting mixed up with frame type which is 8 bits. But still, reserving half the code points for one usage of H2 seems overboard. \r\n\r\nGiven that H2 suffices with about a dozen error codes I really wonder what WebTransport thinks it can achieve by using so many. Maybe the ask is for a \"retire stream with a status\"? In which case an alternate design would be to add a control frame for webstransport that contains your own space or possibly a reason phrasr and then a generic error code such as WEBTRANS_STREAM_ABORT to disambiguate it from other H3 errors.",
          "createdAt": "2021-03-30T17:50:25Z",
          "updatedAt": "2021-03-30T17:50:25Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's 1/65536th of the error space, not 1/2.\r\n\r\nWebTransport *by itself* does not need that many error codes (I have so far three or four in the code that I will write a PR as soon as I'm done); the question here is what do applications running on top of it want.",
          "createdAt": "2021-03-30T17:59:59Z",
          "updatedAt": "2021-03-30T17:59:59Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "The [JS API](https://w3c.github.io/webtransport/#web-transport-close-info) exposes connection error codes, so it's something the transport would need to support. I think removing them would be a W3C conversation.\r\n\r\nActually for my application, we wanted to signal when the connection was terminated gracefully versus an unexpected error. We tried using CONNECTION_CLOSE with application error codes but the QuicTransport implementation in Chrome always raised \"Connection Lost\" regardless of the code. We had to resort to making a new stream and our own, high priority message when the connection was closed. This also meant waiting for the message to be acknowledged before actually closing the connection, otherwise the message would be lost.\r\n\r\nSo yeah, I think immediately closing a connection with an error code is useful functionality, hence why it's in QUIC as well.",
          "createdAt": "2021-03-30T18:22:01Z",
          "updatedAt": "2021-03-30T18:22:01Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Would it work to just defer that the registration to applications over WebTransport? I appreciate it's nice to have a contiguous block but there's hardly much churn in that registry and I don't know what practical benefit a contiguous range adds for distinct uses of WebTransport. I'm confused if you're attempting to reserve a block that is then allocated via some sub-protocol negotiation, or if you intend to run a registration scheme inside your reserved block. Or something else.",
          "createdAt": "2021-03-30T18:23:09Z",
          "updatedAt": "2021-03-30T18:23:09Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Are you suggesting that we should let WebTransport applications send arbitrary HTTP/3 error codes?  That could work, but I am not sure what are the security consequences of that.  If we only reserve a block, the error codes outside of that block are \"privileged\", i.e. only the browser (but not the untrusted web application) can send them.",
          "createdAt": "2021-03-30T18:26:27Z",
          "updatedAt": "2021-03-30T18:26:27Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's a good point and puts more weight behind reserving a block that can only be used by the WebTransport API. ",
          "createdAt": "2021-03-30T18:39:46Z",
          "updatedAt": "2021-03-30T18:39:46Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@kixelated could you elaborate on how your application reacts differently to graceful termination of a stream vs unexpected error? I'm just curious to know what you use this for.",
          "createdAt": "2021-03-30T20:49:02Z",
          "updatedAt": "2021-03-30T20:49:02Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "> @kixelated could you elaborate on how your application reacts differently to graceful termination of a stream vs unexpected error? I'm just curious to know what you use this for.\r\n\r\nSure, we're doing live video streaming. We want to distinguish when the connection is closed because the live stream has ended (show an \"thanks for watching\" screen), versus an unexpected error (show an error screen with debug code).",
          "createdAt": "2021-03-30T21:04:39Z",
          "updatedAt": "2021-03-30T21:04:39Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Makes sense, though this is for an entire session (see #41).  Here we're discussing individual streams.",
          "createdAt": "2021-03-30T21:16:30Z",
          "updatedAt": "2021-03-30T21:16:30Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm finding the mention of CONNECTION_CLOSE slightly confusing since this thread is about stream resets. \r\n\r\nThe JS API doesn't mention if CONNECTION_CLOSE is a transport-level or application-level close, it really should. \r\n\r\nThe HTTP-based WebTransports support graceful connection close via GOAWAY.\r\n\r\nApplications built on WebTransport might be able to harness these properties, or they might need to create a control channel per session that could then behave exactly how they want, without the overhead of IETF registries.\r\n\r\n",
          "createdAt": "2021-03-30T21:19:38Z",
          "updatedAt": "2021-03-30T21:19:38Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "Oh sorry, for some reason I thought this was for the entire connection.\r\n\r\nResetting a stream with an error code is less useful, but again it's in the [JS API](https://w3c.github.io/webtransport/#dom-outgoingstream-abortwriting). RESET_STREAM is useful for my application because the streams transfer a large amount of data, which may be blocked on the network, but I don't have a use-case for application error codes at the moment.",
          "createdAt": "2021-03-30T21:38:43Z",
          "updatedAt": "2021-03-30T21:39:38Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just to close the loop here.  We talked about this in the context of W3C and decided that we'd like to have some number of error code points just for web transport.  256 was the initial suggestion; 100 might work; 31 was considered too small.  @DavidSchinazi pointed out that we can play FizzBuzz and step carefully around the reserved greasing points so that a contiguous block is presented to applications even if the underlying code points are not contiguous.",
          "createdAt": "2021-03-31T00:34:45Z",
          "updatedAt": "2021-03-31T00:34:45Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, where I said\r\n\r\n> The JS API doesn't mention if CONNECTION_CLOSE is a transport-level or application-level close, it really should.\r\n\r\nthere is already an issue for it https://github.com/w3c/webtransport/issues/80",
          "createdAt": "2021-03-31T00:50:51Z",
          "updatedAt": "2021-03-31T00:50:51Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> Just to close the loop here. We talked about this in the context of W3C and decided that we'd like to have some number of error code points just for web transport. 256 was the initial suggestion; 100 might work; 31 was considered too small. @DavidSchinazi pointed out that we can play FizzBuzz and step carefully around the reserved greasing points so that a contiguous block is presented to applications even if the underlying code points are not contiguous.\r\n\r\nWe discussed this at May 2021 interim, and there appeared to be an agreement in the room that we should do that.  I'll write up a PR with some set of 256 points.",
          "createdAt": "2021-05-21T16:15:16Z",
          "updatedAt": "2021-05-21T16:15:16Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWU4NDUyODA1MjY=",
      "title": "Error codes for closing the session",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/41",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Since the API was based off QuicTransport, the API document currently has a method to close the session, with both an error code and a reason string (modeled off QUIC CONNECTION_CLOSE): <https://w3c.github.io/webtransport/#web-transport-close-info>.\r\n\r\nWe could attempt to reset the CONNECT stream, but that would imply that it's always reset, and will not let us supply a reason string.  I think the easiest way would be to send trailers on the CONNECT stream.",
      "createdAt": "2021-03-30T21:15:26Z",
      "updatedAt": "2021-10-19T05:21:08Z",
      "closedAt": "2021-10-19T05:21:08Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "If we want to allow trailers (or any non DATA frames) on the CONNECT stream, we need to add text allowing that.\r\n\r\nFrom the H3 spec:\r\n\r\nOnce the CONNECT method has completed, only DATA frames are permitted to be sent on the stream.  Extension frames MAY be used if specifically permitted by the definition of the extension.",
          "createdAt": "2021-04-01T16:39:16Z",
          "updatedAt": "2021-05-20T16:22:18Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Issue #27 also discusses adding a GOAWAY-type frame on the CONNECT stream.  If we did that we could add an error and reason there as an alternative to trailers.",
          "createdAt": "2021-05-20T16:23:20Z",
          "updatedAt": "2021-05-20T16:23:20Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU4NDY5Njc5NjQ=",
      "title": "What status code should lead to creation of WebTransport session?",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/42",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The spec currently explicitly requires `200`.  <https://tools.ietf.org/id/draft-ietf-quic-http-34.html#name-the-connect-method> suggests that any 2xx code should work.  Should we change the text accordingly?",
      "createdAt": "2021-03-31T16:58:48Z",
      "updatedAt": "2021-09-08T19:39:59Z",
      "closedAt": "2021-09-08T19:39:59Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd suggest server MUST send 200 and client MUST accept any 2XX. That way future extensions can apply meaning to other 2XX codes.",
          "createdAt": "2021-03-31T17:29:24Z",
          "updatedAt": "2021-03-31T17:29:24Z"
        },
        {
          "author": "yutakahirano",
          "authorAssociation": "NONE",
          "body": "What would happen if we require client to reject 2xx other than 200?",
          "createdAt": "2021-04-06T06:50:36Z",
          "updatedAt": "2021-04-06T06:50:36Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU4Njg0ODI1Nzg=",
      "title": "[Editorial] `Code` interchanged in Section 7.3 and 7.4",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/43",
      "state": "CLOSED",
      "author": "bashi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It seems that Section 7.3 should mention `Code: 0x41` and Section 7.4 should mention `Code: 0x54`.",
      "createdAt": "2021-04-27T05:51:43Z",
      "updatedAt": "2021-05-18T06:27:59Z",
      "closedAt": "2021-05-18T06:27:59Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for pointing this out!",
          "createdAt": "2021-05-18T06:27:26Z",
          "updatedAt": "2021-05-18T06:27:26Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWU4ODY4MzU1NzI=",
      "title": "WebTransport and 0-RTT",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/45",
      "state": "CLOSED",
      "author": "ddragana",
      "authorAssociation": "NONE",
      "assignees": [
        "vasilvv"
      ],
      "labels": [
        "ready for PR"
      ],
      "body": "\r\nThere is this sentence about 0-RTT:\r\n\r\n>  WebTransport over HTTP/3 does not support 0-RTT.\r\n\r\nI think this needs a better explanation. I expect that CONNECT requests can be sent during 0-RTT period, but WebTranpsort\r\nstreams cannot be open before response to the CONNECT requests is received.\r\nClients may remember that WebTransport was supported by a server and may try to negotiate sessions during 0-RTT.",
      "createdAt": "2021-05-11T10:40:06Z",
      "updatedAt": "2022-12-16T19:28:39Z",
      "closedAt": "2022-12-16T19:28:39Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "CONNECT is considered [unsafe and non-idempotent](https://www.iana.org/assignments/http-methods/http-methods.xhtml) by HTTP semantics, so the current specs state that it [MUST NOT](https://datatracker.ietf.org/doc/html/rfc8470#section-4) be sent in 0-RTT.\r\n\r\nWe could override those however and explicitly state that 0-RTT is allowed for this specific kind of CONNECT request, but I'm not sure we should? If a server implementation makes creation of a WebTransport session expensive, then this could be used as a DoS vector. That said, servers could protect themselves by either disabling 0-RTT on that origin, or by returning 425 if their intermediaries support the Early-Data header.\r\n\r\nAll this to say: here there be dragons, and if we want to add this feature we'll need to write guidance for implementors.",
          "createdAt": "2021-05-11T14:38:42Z",
          "updatedAt": "2021-05-11T14:38:42Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "The MUST NOT only applies in absence of other indications; an API flag could be such indication.  That said, I am not sure it's worth investing into designing WebTransport 0-RTT support at this point.",
          "createdAt": "2021-05-11T20:04:55Z",
          "updatedAt": "2021-05-11T20:04:55Z"
        },
        {
          "author": "ddragana",
          "authorAssociation": "NONE",
          "body": "I agree  we do not need to allow 0RTT for WebTransport.\r\n\r\nSince WebTransport does not support 0RTT what will happen to the SETTINGS_ENABLE_WEBTRANSPORT setting when 0RTT is used on a HTTP/3 connection and in the previous session WebTransport support was negotiated? There is some explanation in the HTTP/3 draft:\r\n\r\n> If 0-RTT data is accepted by the server, its\r\n   SETTINGS frame MUST NOT reduce any limits or alter any values that\r\n   might be violated by the client with its 0-RTT data.\r\n\r\n In the WebTransport case 0RTT data is not relevant, but there may be a small window when a client has 1RTT keys but still do not have the settings from a server.\r\n \r\nWe can allow the client to remember WebTransport setting or WebTransport setting needs to be negotiated in each session therefore the client must wait for the settings from the server before confirming that WebTransport is supported. I am fine with either way, but I think the WebTransport draft needs a couple of sentences to explain the behavior.",
          "createdAt": "2021-05-14T08:09:12Z",
          "updatedAt": "2021-05-14T08:09:12Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "HTTP/3 draft says:\r\n\r\n> When a 0-RTT QUIC connection is being used, the initial value of each server setting is the value used in the previous session.\r\n\r\nThis obviously only works for SETTINGS_ENABLE_WEBTRANSPORT if the server is not allowed to go from 1 to 0 while accepting 0-RTT; we should probably clarify this explicitly.",
          "createdAt": "2022-03-21T20:43:16Z",
          "updatedAt": "2022-03-21T20:43:16Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWU4OTAzMzI4MzY=",
      "title": "HTTP/3 Transport and Alt-Svc",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/47",
      "state": "CLOSED",
      "author": "wilaw",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Moving an issue from W3C https://github.com/w3c/webtransport/issues/78 as we felt it is better handled here at IETF. OP by @LPardue. \r\n\r\n> \r\n> During the WEBTRANS BoF at IETF Singapore 106 I made a comment at the microphone about the relationship between WebTransport over HTTP/3 and Alt-Svc. I was asked to open an issue here.\r\n> \r\n> __Simple Problem__\r\n> The following are requirements from https://tools.ietf.org/html/draft-vvv-webtransport-http3-01#section-4.1:\r\n> \r\n> *  In order to indicate support for Http3Transport, both the client and\r\n>    server MUST send an empty \"http3_transport_support\" transport\r\n>    parameter.  Endpoints MUST NOT use any Http3Transport-related\r\n>    functionality unless the parameter has been negotiated.\r\n> \r\n> *  If \"http3_transport_support\" is negotiated, support for the QUIC\r\n>    DATAGRAM extension MUST be negotiated.\r\n> \r\n> For any given HTTP/3 connection with a value of \"h3-draft\" that meets the following above criteria, what happens if an Alt-Svc advert on that connection incorrectly causes a client to attempt a new connection that cannot meet the same requirements? I think marking the alternative as broken is probably good enough.\r\n> \r\n> __Broader problem__\r\n> An HTTP/3 connection that coalesces connections might trip up if some of the traffic to origin is intended to be Http3Transport and some is not. An alternative for a non-Http3Transport-using authority might cause a complete changeover to fail. \r\n> \r\n> HTTP/2 defines the 421 status code that can be used to mitigate such problems but it doesn't apply to all possible error cases (only the one where extended CONNECT fails).\r\n> \r\n> I think in reality, an Http3Transport server will likely want to be smart about the Alt-Svc values it produces. \r\n> \r\n> __Broader broader problem__\r\n> How does a client discover an Http3Transport service?\r\n> \r\n> We're also talking about putting Alt-Svc in the DNS. How does a client learn of the availability of Http3Transport providing server based on its name, should it even be able to?\r\n> \r\n> I wrote an I-D about a related problem in https://tools.ietf.org/html/draft-pardue-alt-svc-ext-unsupported-00.",
      "createdAt": "2021-05-12T17:39:42Z",
      "updatedAt": "2022-06-27T12:52:46Z",
      "closedAt": "2022-06-27T12:52:46Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at 113, consensus in room to close with no action. We can revisit this when the altsvc-bis effort makes more progress over in the HTTPBIS WG",
          "createdAt": "2022-03-24T14:09:37Z",
          "updatedAt": "2022-03-24T14:09:37Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as per above.",
          "createdAt": "2022-06-27T12:52:46Z",
          "updatedAt": "2022-06-27T12:52:46Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "MDU6SXNzdWU4OTIyMjQ1MDg=",
      "title": "Unidirectional stream framing",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/48",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "vasilvv"
      ],
      "labels": [
        "ready for PR",
        "ietf-114",
        "ietf-115"
      ],
      "body": "WT uni streams are currently defined as\r\n\r\n`Stream Type | Preface (Session ID) | Unframed`\r\n\r\nThis was awkward to implement, and asymmetric with how client-initiated bidi WT streams are implemented (and now server-initiated bidi -- with a frame).  \r\n\r\nI'd like to propose we change WT uni streams to \r\n\r\n`Stream Type | TV Frame` \r\n\r\nor perhaps \r\n\r\n`Stream Type | Preface | TV Frame`",
      "createdAt": "2021-05-14T20:35:56Z",
      "updatedAt": "2023-02-21T23:14:27Z",
      "closedAt": "2023-02-21T23:10:59Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Not discussed at IETF 111.  I don't see the point in trying to match this up with bidi streams.  All this achieves is wasting bytes for the frame type field.",
          "createdAt": "2021-07-30T19:45:44Z",
          "updatedAt": "2021-07-30T19:45:44Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I tend to think the current design is fine as well.\r\n\r\nIf you think about the first value of the unidirectional stream being a frame type, not a stream type, then I think they do conceptually align with the Bidi WT streams?",
          "createdAt": "2021-07-31T15:41:13Z",
          "updatedAt": "2021-07-31T15:41:13Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Paging in context...\r\n\r\nI think my reason for suggesting this was that my parser always wants to consume the stream-type when it dispatches a unidirectional stream, but given the similarities to the other WT stream types, I wanted to use the generic frame parser after dispatch.  I made it work by not consuming the type-byte in this special case.  A side effect of defining it as `Stream Type | Frames* | TV Frame` is that one could more easily add extension frames before the TV frame in the future, at the cost of an extra byte now.\r\n\r\nI can live with it as is too.",
          "createdAt": "2021-08-02T21:03:01Z",
          "updatedAt": "2021-08-02T21:03:01Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind Should I add this to the agenda for the next meeting, or should we just leave this as-is and close this issue?",
          "createdAt": "2022-03-21T20:52:42Z",
          "updatedAt": "2022-03-21T20:52:42Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Given the relation to the issue just opened ^ covering a similar topic on bidi streams (eg: which frames are allowed before TV), maybe we should have a brief discussion?  I think they should behave similarly.  I have the context paged in now before the meeting.  It sounds like @martin-seeman suggested Grease frames as a possible use case, in addition to \"future extensions\" suggested here.  Maybe a frame for signaling the initial priority in the bidi-case is plausible? \r\n\r\nGrease frames may be marginal in this context (you can't send one on a QPACK stream either), and any extension needs to be enabled via SETTINGS (or capsules or headers?) anyways so said extension can change the format of WT streams.  I'll counter that the cost (1 byte per stream) is low and it's easier to bake in the flexibility from the start rather than bolt it on later.\r\n\r\nI'll reiterate that I can live with the current scheme.",
          "createdAt": "2022-03-22T12:42:49Z",
          "updatedAt": "2022-03-22T12:42:49Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that the unidirectional design (having a dedicated stream type) is the much cleaner solution. There is greasing for unidirectional stream types in HTTP/3, so I don't think we need to do anything here.\r\nI wish we also had stream types for bidirectional streams in HTTP/3, so that ship has sailed.",
          "createdAt": "2022-03-22T12:46:32Z",
          "updatedAt": "2022-03-22T12:46:32Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "@marten-seemann - I read your position on the other issue and assumed you wanted future extensions to be able to send frames before the WT stream became unframed.  If that's true, I don't understand why you would want that capability for bidi streams but not uni streams.",
          "createdAt": "2022-03-22T14:01:22Z",
          "updatedAt": "2022-03-22T14:01:22Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "At IETF 114, we discussed uni/bidi streams and there was consensus in the room to be consistent between unidirectional and bidirectional. See #71",
          "createdAt": "2022-10-28T17:51:06Z",
          "updatedAt": "2022-10-28T17:51:06Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: understanding is that this is closed by #96, let's keep the related discussion going on in #81 which is still open",
          "createdAt": "2023-02-21T23:14:26Z",
          "updatedAt": "2023-02-21T23:14:26Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "MDU6SXNzdWU4OTcwOTQ5NDM=",
      "title": "Stale references to a transport parameter in security consideration?",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/49",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-http3-01#section-6 states\r\n\r\n> WebTransport over HTTP/3 requires explicit opt-in through the use of\r\n   a QUIC transport parameter; this avoids potential protocol confusion\r\n   attacks by ensuring the HTTP/3 server explicitly supports it.\r\n\r\nI can't tell if that is stale text or if it still true. \r\n\r\nThere is a SETTING - SETTINGS_ENABLE_WEBTRANSPORT - for extended CONNECT. Maybe that applies instead?",
      "createdAt": "2021-05-20T16:36:47Z",
      "updatedAt": "2022-03-21T20:54:57Z",
      "closedAt": "2022-03-21T20:54:57Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, it used to be a transport parameter in a very early version of this draft.",
          "createdAt": "2022-03-21T20:54:32Z",
          "updatedAt": "2022-03-21T20:54:32Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "MDU6SXNzdWU5MDI3NDA1OTM=",
      "title": "New Connection throttling",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/50",
      "state": "CLOSED",
      "author": "wilaw",
      "authorAssociation": "NONE",
      "assignees": [
        "vasilvv"
      ],
      "labels": [
        "ready for PR"
      ],
      "body": "Porting https://github.com/w3c/webtransport/issues/230  originally posted to W3C WT @ricea\r\n\r\nNew connections should be throttled to avoid being a DoS vector. Maybe we will just have some language in the standard to permit and encourage throttling, and leave the details to browsers. ",
      "createdAt": "2021-05-26T17:46:41Z",
      "updatedAt": "2022-12-16T19:22:56Z",
      "closedAt": "2022-12-16T19:22:56Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Shouldn't the throttling be performed at the W3C layer? If throttling happens, should the W3C API let the caller know?",
          "createdAt": "2021-05-26T18:22:57Z",
          "updatedAt": "2021-05-26T18:22:57Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is a back-to-front way of suggesting that WebTransport include something like the guidance in https://datatracker.ietf.org/doc/html/rfc6455#section-4.1 (which I found [via this gDoc](https://docs.google.com/document/d/1a8sUFQsbN5uve7ziW61ATkrFr3o9A-Tiyw8ig6T3puA/edit#), linked from https://chromium.googlesource.com/chromium/src/+/refs/heads/main/net/websockets/README.md\r\n\r\n> If the client already has a WebSocket connection to the remote\r\n>        host (IP address) identified by /host/ and port /port/ pair, even\r\n>        if the remote host is known by another name, the client MUST wait\r\n>        until that connection has been established or for that connection\r\n>        to have failed.  There MUST be no more than one connection in a\r\n>        CONNECTING state.  If multiple connections to the same IP address\r\n>        are attempted simultaneously, the client MUST serialize them so\r\n>        that there is no more than one connection at a time running\r\n>        through the following steps.",
          "createdAt": "2021-05-26T19:10:35Z",
          "updatedAt": "2021-05-26T19:11:10Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh thanks for finding that. I'm supportive of adding something like that.",
          "createdAt": "2021-05-26T19:31:37Z",
          "updatedAt": "2021-05-26T19:31:37Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm actually not sure that the specific requirement in WebSocket spec is useful, compared to just recommending throttling (or other forms of resource limits) in general.",
          "createdAt": "2021-05-27T19:28:33Z",
          "updatedAt": "2021-05-27T19:28:33Z"
        },
        {
          "author": "ricea",
          "authorAssociation": "NONE",
          "body": "The WebSocket throttling in RFC6455 requires you to implement it close to\r\nthe socket layer (in particular, after DNS lookup), which is messy in\r\npractice. I think it may be sufficient to leave the details of the\r\nthrottling to the implementation. If we want to ensure it is interoperable,\r\na per-network-partitiion delay based on the number of pending and\r\nrecently-failed connections should be sufficient.\r\n",
          "createdAt": "2021-05-27T19:52:03Z",
          "updatedAt": "2021-05-27T23:45:09Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So given that this is over HTTP/3, what is the anticipated throttling? Is it really just trying to tell HTTP clients to not make lots of requests? Is WebTransport sufficiently more expensive than other types of requests? I'm struggling to see language we would include here that is needed over language we have in QUIC or HTTP/3 already",
          "createdAt": "2021-05-27T23:21:59Z",
          "updatedAt": "2021-05-27T23:21:59Z"
        },
        {
          "author": "ricea",
          "authorAssociation": "NONE",
          "body": "Generally a browser will only make one HTTP/3 connection per server,\r\nregardless of how many resources the page requests. So servers don't need\r\nto worry about a well-behaved browser initiating large numbers of\r\nsimultaneous QUIC handshakes. However, when WebTransport connections are\r\nnot pooled, it is valid to make several at the same time. If there were no\r\nrestrictions, a badly-behaved web page could request thousands of\r\nWebTransport connections simultaneously, DoSing the server.",
          "createdAt": "2021-05-27T23:43:44Z",
          "updatedAt": "2021-05-27T23:45:19Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks Adam. I think phrasing thing as a design deviation from HTTP/3's recommendation to use one connection is good idea.",
          "createdAt": "2021-05-27T23:53:25Z",
          "updatedAt": "2021-05-27T23:53:25Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "From what I can read from this discussion, there isn't that much in terms of design here, and this mostly requires writing up that throttling is up to the implementation.",
          "createdAt": "2022-03-21T20:50:41Z",
          "updatedAt": "2022-03-21T20:50:41Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU5NTIyODg2ODU=",
      "title": "WEBTRANSPORT_STREAM payload length?",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/53",
      "state": "CLOSED",
      "author": "ydnar",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi folks! Thanks for your efforts on this project. I\u2019m really excited about what WT will enable.\r\n\r\nI\u2019m working on a WT3 implementation and had a question about `WEBTRANSPORT_STREAM` frames.\r\n\r\nWhy doesn\u2019t a `WEBTRANSPORT_STREAM` header include a payload length value following the `0x41` frame type, before the session ID? (I saw this [comment]( https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/26#issuecomment-793185048) but curious for more context.)\r\n\r\nFrom what I can tell, this exception forces a WT3-capable H3 server to be WT3-aware\u2014or at least aware of H3 frames that don\u2019t conform to the [frame layout spec](https://www.ietf.org/archive/id/draft-ietf-quic-http-34.html#name-frame-layout).\r\n\r\nI\u2019ve modified an existing H3 implementation to pass unknown frame types and streams to an extension. Right now, in order to accommodate `WEBTRANSPORT_STREAM` frames, a receiver has to stop parsing the frame after reading the frame type, and pass the stream to an extension that could either process or skip the unknown frame.\r\n\r\nGiven that the Session ID occupies the same place where a payload length varint would be, the frame parser could parse the second varint as a \"length\" and the WT3 extension could interpret it as a Session ID. Workable, but seems like a kludge.\r\n\r\nIt seems like one additional byte per bidi stream seems reasonable to align these.\r\n\r\nCould `WEBTRANSPORT_STREAM` conform to the H3 frame layout spec with a zero-length payload, and have the payload start with the Stream ID?\r\n",
      "createdAt": "2021-07-25T14:40:39Z",
      "updatedAt": "2021-07-26T14:24:21Z",
      "closedAt": "2021-07-26T14:24:21Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> Why doesn\u2019t a WEBTRANSPORT_STREAM header include a payload length value following the 0x41 frame type, before the session ID? (I saw this comment but curious for more context.)\r\n\r\nBecause its payload length is infinite (as in, it extends until the end of the stream).\r\n\r\n> From what I can tell, this exception forces a WT3-capable H3 server to be WT3-aware\u2014or at least aware of H3 frames that don\u2019t conform to the frame layout spec.\r\n>\r\n> I\u2019ve modified an existing H3 implementation to pass unknown frame types and streams to an extension. Right now, in order to accommodate WEBTRANSPORT_STREAM frames, a receiver has to stop parsing the frame after reading the frame type, and pass the stream to an extension that could either process or skip the unknown frame.\r\n\r\nNote that this does not actually solve the issue, since even if you treat it as length 0 frame, the remainder of the stream is unframed, so a regular HTTP/3 parser would fail regardless.\r\n\r\nAll WT-over-H3 implementations already have to be WT-aware since HTTP/3 does not allow server-initiated bidirectional streams.\r\n\r\n> Could WEBTRANSPORT_STREAM conform to the H3 frame layout spec with a zero-length payload, and have the payload start with the Stream ID?\r\n\r\nWe already [discussed this at IETF 110](https://datatracker.ietf.org/doc/minutes-110-webtrans/), and the consensus was to leave this as-is.",
          "createdAt": "2021-07-26T12:39:43Z",
          "updatedAt": "2021-07-26T12:39:43Z"
        },
        {
          "author": "ydnar",
          "authorAssociation": "NONE",
          "body": "Thanks for the reply. I dug a bit more and found this comment to be a bit of helpful additional context about un-negotiated extensions vs negotiated extensions: https://github.com/quicwg/base-drafts/issues/2396#issuecomment-459171364\n\nMaybe the ship has sailed, but I'm wondering if H3 section 7.1 could note that negotiated extensions may vary the framing: https://www.ietf.org/archive/id/draft-ietf-quic-http-34.html#section-7.1\n\nThanks!",
          "createdAt": "2021-07-26T14:08:37Z",
          "updatedAt": "2021-07-26T14:08:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Maybe the ship has sailed, but I'm wondering if H3 section 7.1 could note that negotiated extensions may vary the framing: \r\n\r\nI think this is covered pretty well by https://www.ietf.org/archive/id/draft-ietf-quic-http-34.html#section-9\r\n",
          "createdAt": "2021-07-26T14:17:24Z",
          "updatedAt": "2021-07-26T14:17:24Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "MDU6SXNzdWU5NTUyNTk0MDc=",
      "title": "What to do with datagram context IDs?",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/54",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "h3-datagram provides an ability to multiplex multiple datagram contexts over a single flow of datagrams associated with a stream.  This feature is optional; an endpoint can disable contexts by sending a register-without-context capsule.\r\n\r\nWe currently do not have a use for multiple contexts; there are potential extensions that could utilize those (e.g. multiple datagram queues with different priorities), but those would not make it into the first version of the spec.\r\n\r\nThere are roughly two approaches we could potentially take here:\r\n\r\n1. Require WebTransport servers to handle multiple contexts correctly even if we don't use those currently.\r\n2. Allow WebTransport servers to reject any kind of context registration other than register-without-context, unless there's an extension negotiated via a header.\r\n\r\nThe first option has the drawback of complexity that would not benefit most server implementers.  The downside of the second option is that if we go with it, we would need to wait for the headers from the server before sending any datagrams.\r\n\r\ncc @DavidSchinazi who can probably add more",
      "createdAt": "2021-07-28T21:48:31Z",
      "updatedAt": "2022-03-05T01:56:49Z",
      "closedAt": "2022-03-05T01:56:49Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "(no hats) Since you've isolated some potential extensions that could benefit from contexts, I strongly believe that WebTransport should not preclude them. Having just implemented this, the complexity is honestly very minor. I'll also note that this complexity will be inside the QUIC/h3 library and not inside the WebTransport-server code. Multi-purpose QUIC/h3 libraries will support contexts for CONNECT-UDP. So I strongly prefer the first option.\r\n\r\n",
          "createdAt": "2021-07-28T22:12:48Z",
          "updatedAt": "2021-07-28T22:12:48Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There's not much difference one context with an ID and one context without an ID. If you want to profile something on top of H3 datagram down to a single context, just say that like \"we only define how to use one context, endpoints have no means to use more, extensions could change that\".",
          "createdAt": "2021-07-28T22:16:46Z",
          "updatedAt": "2021-07-28T22:16:46Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@LPardue I think Victor was proposing to allow servers to not have to implement REGISTER_DATAGRAM_CONTEXT. I think we should not do that. WebTransport without extensions will use either no context or a single context, but servers need to support both.",
          "createdAt": "2021-07-28T22:22:04Z",
          "updatedAt": "2021-07-28T22:22:04Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah I don't like that idea, it breaks future use.. Support both register capsule but limit the number to one if you want that today.",
          "createdAt": "2021-07-28T23:37:21Z",
          "updatedAt": "2021-07-28T23:37:21Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "YAGNI says if you don't know that you need it, you don't build it.  I would reserve use of these for future use, but say that in this version they aren't used.",
          "createdAt": "2021-07-30T19:52:06Z",
          "updatedAt": "2021-07-30T19:52:06Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson the trickiness there is around negotiation of extensions. Capsules and context IDs are end-to-end, so we can't negotiate a new context-using extension via SETTINGS. If we rely on HTTP headers for negotiating extensions, we waste a round trip before being able to send core protocol datagrams. The benefit of the current design (where contexts are optional to use but mandatory to implement) is that it allows a client to immediately start using datagrams with or without contexts before it's received the response headers.",
          "createdAt": "2021-07-30T20:09:54Z",
          "updatedAt": "2021-07-30T20:09:54Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> If we rely on HTTP headers for negotiating extensions, we waste a round trip before being able to send core protocol datagrams.\r\n\r\nI'm not sure this would be a significant problem in practice.  Most protocols usually perform some kind of negotiation first, meaning that the first flight is most likely to be just stream data (CONNECT-UDP is the only exception to this as far as I know).",
          "createdAt": "2021-07-30T20:52:10Z",
          "updatedAt": "2021-07-30T20:52:10Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would prefer to not expose contexts because it causes the API to diverge from QUIC transport.  And so far, the API is modeled very close on that API.  I believe that's been a good choice.\r\n\r\nIf you want multiple streams of datagrams, you can open multiple WebTransport sessions or potentially use H3-datagram directly if you only need datagrams.",
          "createdAt": "2021-07-30T22:10:58Z",
          "updatedAt": "2021-07-30T22:10:58Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@ianswett we're not suggesting exposing contexts to JavaScript. This is about the interaction between draft-ietf-webtrans-http3 and draft-ietf-masque-h3-datagram.",
          "createdAt": "2021-07-30T22:17:54Z",
          "updatedAt": "2021-07-30T22:17:54Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we're not exposing it in Javascript, then it seems like it's not a core feature of WebTransport.\r\n\r\nOn a practical note, we've decided that for the fallback options, we'll layer a QUIC-lite streaming + datagaram layer on top of H2 or H1.  If we wanted to also support datagram contexts, I think we'd have to pull in all of HTTP/3, since that lives in h3 datagram, not datagram.  I do not want to pull in all of H3 as well to add this currently unused functionality.\r\n\r\nTell me if I'm missing something.",
          "createdAt": "2021-07-31T15:27:34Z",
          "updatedAt": "2021-07-31T15:27:34Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So I think that the question is a bigger one: is there sufficiently large set of protocols that would use context identifiers, such that they all might benefit from common machinery in support of them?\r\n\r\nThis is a question for draft-ietf-masque-h3-datagram more than this document, but it's a question that I'm not confident about.  This document very much doesn't need the mechanism, but - unfortunately - it has to engage with it, if only to get it out of the way.",
          "createdAt": "2021-08-02T04:37:51Z",
          "updatedAt": "2021-08-02T04:37:51Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@ianswett I think you're misunderstanding how contexts work, have you read the latest version of draft-ietf-masque-h3-datagram? ([draft -03](https://datatracker.ietf.org/doc/html/draft-ietf-masque-h3-datagram-03))\r\n\r\n@martinthomson let's take the conversation about contexts to draft-ietf-masque-h3-datagram. [Can you file an issue there please?](https://github.com/ietf-wg-masque/draft-ietf-masque-h3-datagram/issues/new)",
          "createdAt": "2021-08-02T16:29:08Z",
          "updatedAt": "2021-08-02T16:29:08Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "MDU6SXNzdWU5NjkyMzk0OTA=",
      "title": "Client handling of HTTP redirect",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/61",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready for PR",
        "ietf-114",
        "ietf-115",
        "ietf-112",
        "ietf-116"
      ],
      "body": "We need to specify what the client should do if the server responds to the Extended CONNECT request with a 3XX status code. See [BCP56bis s4.3](https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-bcp56bis-13#section-4.3).",
      "createdAt": "2021-08-12T17:27:42Z",
      "updatedAt": "2023-04-18T22:13:24Z",
      "closedAt": "2023-04-18T22:13:24Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "For what it's worth, last time we discussed this in W3C, the agreement was \"we should not support this, the application developers are welcome to add a redirect layer on their own\".",
          "createdAt": "2021-08-18T19:18:12Z",
          "updatedAt": "2021-08-18T19:18:12Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair notes from IETF 112 meeting: we will analyze BCP56bis and follow the recommendations there",
          "createdAt": "2021-11-09T12:47:20Z",
          "updatedAt": "2021-11-09T12:47:20Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "https://www.rfc-editor.org/rfc/rfc9205.html#name-redirection says:\r\n\r\n> As noted in [[HTTP](https://www.rfc-editor.org/rfc/rfc9205.html#HTTP)], a user agent is allowed to automatically follow a 3xx redirect that has a Location response header field, even if they don't understand the semantics of the specific status code. However, they aren't required to do so; therefore, if an application using HTTP desires redirects to be automatically followed, it needs to explicitly specify the circumstances when this is required.\r\n\r\nI assume this means that we are not required to make the user agent automatically follow redirects.  Servers may return 3xx (in which case no WebTransport session is created), and we may define some form of propagating that information in the browser, but as far as I can tell, there isn't much to say in the draft.",
          "createdAt": "2022-06-27T14:53:10Z",
          "updatedAt": "2022-06-27T14:53:10Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "BCP56bis (now published as RFC 9205) [states in s4.3](https://datatracker.ietf.org/doc/html/rfc9205#section-4.3):\r\n> Redirect handling:  Applications need to specify how redirects are expected to be handled\r\n\r\nTherefore, we need to be explicit in the WebTransport document: we need to pick which variation of \"the client MAY/SHOULD/MUST follow redirects\" we want. That'll make it clear to application developers whether or not they can use redirects.",
          "createdAt": "2022-06-27T17:27:20Z",
          "updatedAt": "2022-06-27T17:27:20Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at IETF 114, Folks in the room strongly preferred a mandatory statement (MUST or MUST NOT instead of SHOULD/MAY/SHOULD NOT). Majority of the room preferred MUST over MUST NOT. Victor believes that some folks who would have objections because this was hard in WebSockets are not in the room, so we are not declaring consensus today and will continue discussing on this issue. @vasilvv is taking an action item to get these folks to chime in on this issue.",
          "createdAt": "2022-07-26T15:40:11Z",
          "updatedAt": "2022-07-26T15:40:11Z"
        },
        {
          "author": "guoye-zhang",
          "authorAssociation": "NONE",
          "body": "If redirection is supported, what does a client do with 303 that changes the method to GET? Treat it as a failure?",
          "createdAt": "2022-07-26T15:52:00Z",
          "updatedAt": "2022-07-26T18:53:14Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a good point, we should probably ban 300, 303, 304, 305, and 306.",
          "createdAt": "2022-07-26T18:23:48Z",
          "updatedAt": "2022-07-26T18:23:48Z"
        },
        {
          "author": "ricea",
          "authorAssociation": "NONE",
          "body": "Redirects were banned for WebSockets because of the following attack:\r\n\r\n1. A page takes the address of a WebSocket as a query parameter, validates the origin, and connects to it if the origin is correct.\r\n2. The same origin has an open redirect.\r\n3. An attacker sets the query parameter to something like https://target.domain/redirect?href=https://attacker.domain/fake-endpoint\r\n4. The page believes it's talking to a trusted endpoint, when actually it's talking to an attacker-controller endpoint.\r\n\r\nOpen redirects are surprisingly common (even google.com has one), but I don't know how likely it is that a page will take an endpoint as a query parameter.\r\n\r\nFrom an implementation point of view, not supporting redirects has made Chrome's WebSocket implementation significantly simpler and more secure.\r\n\r\nAs a general principle, I would recommend WebTransport avoid adopting any HTTP features that are not strictly necessary for it to function. The most difficult bugs in Chrome's WebSocket implementation come from supporting HTTP features.",
          "createdAt": "2022-07-29T08:17:16Z",
          "updatedAt": "2022-07-29T08:17:16Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting, folks would prefer to disallow redirect for now and add them in a separate doc later if we really need them. Let's discuss at 116.",
          "createdAt": "2023-03-07T23:41:03Z",
          "updatedAt": "2023-03-07T23:41:03Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at IETF 116. Consensus in room was to not handle redirect transparently at the IETF WebTransport layer. W3C will decide whether a 3xx can be sent by the server and whether that will be reported to JavaScript.",
          "createdAt": "2023-03-29T05:40:51Z",
          "updatedAt": "2023-03-29T05:40:51Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "I_kwDOCvK98s49FAJv",
      "title": "Request forgery",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/63",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "When we built thewebsocketprotocol, masking was added to protect intermediaries from carefully crafted messages that were controlled by web sites.  No such mechanism exists in this protocol and we should be certain that this is the right answer.\r\n\r\nThe threat model here is similar to websockets. The attacker is given complete control over the server and the ability to determine the content of QUIC datagrams or streams that are sent by the client.  This doesn't give the attacker complete control over the content of UDP datagrams, but the level of control can be very good.  As the attacker knows the keys that will be used and they can probably guess the offset into the packet at which data will be placed, they have fine control over the resulting ciphertext.\r\n\r\nThe result being than an attacker controls most of the content of the UDP datagrams sent by the browser.  They choose connection IDs and with the exception of a small number of bytes toward the start of a packet and the authentication tag at the end of a packet, they have nearly complete control over the payload of UDP datagrams.\r\n\r\nAn attacker might also control the destination address if the client supports the use of preferred addresses. (Though they need to control this address if the client is going to send any meaningful data toward it.)\r\n\r\nWhat an attacker can do with this control is hard to estimate.  The attacks that used thewebsocketprotocol relied on having an intermediary that looked at TCP segments and applied some fairly loose parsing.  Attackers could then exploit that intermediary.  Cache poisoning was the demonstrated example, but we've since seen how bad logic in other intermediaries can be exploited in other ways.\r\n\r\nHow much intermediaries make decisions based on the content of random UDP packets they see is still unclear.  There are a few protocols for which we might want to avoid the risk.  For that, blocking traffic to a destination port of 68, 69 or 53 seems like it might provide an easy win.  The [fetch port blocklist](https://fetch.spec.whatwg.org/#port-blocking) is TCP-specific, but we could just use that for now and work on a UDP version.\r\n\r\nAdding something like masking is possible, but far more disruptive.  We do not apply masking to HTTP requests, but we allow sites similar levels of control over the content of packets.  In a sense we're already accepting some risk of request forgery.\r\n\r\nNo matter what we decide, the specification needs to address this risk.",
      "createdAt": "2021-10-13T03:11:20Z",
      "updatedAt": "2022-03-17T18:55:30Z",
      "closedAt": "2022-03-17T18:55:30Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See w3c/webtransport#175 for more context.",
          "createdAt": "2021-10-13T03:15:19Z",
          "updatedAt": "2021-10-13T03:15:19Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson is this specific to WebTransport-over-h3 or is it general to QUIC? RFC 9000 [already discusses the implications of request forgery](https://quicwg.org/base-drafts/rfc9000.html#name-request-forgery-attacks), and I'm not sure what WebTransport-over-h3 needs to say on top of that. In your description, it sounds like the attacker is the WebTransport-over-h3 server, but I'm not seeing that this server can do that can't be done by any QUIC server.",
          "createdAt": "2021-10-14T20:26:35Z",
          "updatedAt": "2021-10-14T20:26:35Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The text in RFC 9000 is generic.  Anything that is deployed to the web context needs to consider this and determine whether generic mitigations are sufficient.  WebTransport is - perhaps - special in the sense that it allows for nearly arbitrary control over the content of QUIC packets, so I believe that it is important to directly address this case.  thewebsocketprotocol did.",
          "createdAt": "2021-10-14T23:40:25Z",
          "updatedAt": "2021-10-14T23:40:25Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Apologies, I don't know the history of WebSocket too well. What's the threat model here? Who's the attacker and who's the victim?",
          "createdAt": "2021-10-15T00:26:42Z",
          "updatedAt": "2021-10-15T00:26:42Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The paper you might want to read \"[Talking to yourself for fun and profit](https://www.adambarth.com/papers/2011/huang-chen-barth-rescorla-jackson.pdf)\".\r\n\r\nThe short synopsis is that there are intermediaries that try to do smart things by looking at the traffic that goes past them.  Emphasis on \"try\" there, because some of these are colossally stupid.  A small study found that passing arbitrary TCP under the noses of some intermediaries caused them to do unsafe things.  Even though there was a whole lot of garbage on the connection, the intermediaries would scrub through looking for things that seemed to be HTTP requests and responses.  They would then take whatever junk they saw, put it in a cache, and serve it as authoritative to other network users.\r\n\r\nThe way thewebsocketprotocol dealt with this was to make the content of frames unpredictable to websites.  That's the masking trick.\r\n\r\nThere are a bunch of reasons why this is less interesting today.  I'm only asking that this be considered and either deal with or deliberately acknowledged.\r\n\r\nThe other paper that is relevant here is the \"[NAT slipstreaming](https://samy.pl/slipstream/)\" attack, which also relies on intermediaries doing stupid things based on what they think they see on the wire.  That's far more recent and relevant.",
          "createdAt": "2021-10-15T00:37:04Z",
          "updatedAt": "2021-10-15T00:37:04Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "I see, thanks for the interesting reads. Here's my understanding of the threat model: the user is served a malicious ad with malicious JavaScript. That JavaScript opens up a WebSocket/WebTransport connection to an attacker-controlled WebSocket/WebTransport server. The JavaScript then crafts WebSocket/WebTransport messages such that they send a chosen blob directly over TCP/UDP. A victim middlebox (NAT or intermediary) then interprets that blob as a command from the user and takes action.\r\n\r\nIn the WebSocket strawman proposals, the attack was very simple since the JavaScript could directly control the bytes that were sent over TCP. The fix was to have each client-to-server WebSocket message be masked using a random per-message nonce that the JavaScript has no control over.\r\n\r\nIn WebTransport, this isn't quite as bad because the application data is encrypted by the QUIC or TLS layer before being sent on the wire. However, because the WebTransport server is controlled by the attacker, it can share the TLS secrets and the packet numbers with the JavaScript, and then the JavaScript can probabilistically deduce the keymat and therefore control what ends up being sent on the wire. The attack is harder to pull off than the original WebSocket one, but not impossible. Though you could conceivably perform the same attack over HTTP/3 and HTTP/2 by sending a set of POSTs over a shared connection. WebTransport doesn't seem to open up a new attack vector, but it does make the probability of attacker success higher by giving the attacker more control over individual plaintext bytes.\r\n\r\nI'm not seeing a port-agnostic WebTransport-layer mitigation apart from adding a random nonce to every single QUIC packet, and that would chew into the MTU and reduce performance. This becomes a tradeoff between probability of attack success and user-facing performance.\r\n\r\nRe-reading you first message, I'm realizing that I agree with you, just that it took me a second to get there :-) Our best bet sounds like we need a UDP fetch port blocklist for HTTP/3 in general.",
          "createdAt": "2021-10-15T01:10:40Z",
          "updatedAt": "2021-10-15T01:10:40Z"
        },
        {
          "author": "yutakahirano",
          "authorAssociation": "NONE",
          "body": "A difference between websocket and webtransport-over-h3 (other than mandatory encryption) is the latter requires intermediaries to state their support of webtransport-over-h3 via ALPN and SETTINGS.  We don't have such a mechanism for websocket - A proxy that doesn't know websocket at all could be a websocket proxy. This reduces the risk of sending webtransport-over-h3 traffic to intermediaries that misinterpret the bytes.",
          "createdAt": "2021-10-15T06:45:39Z",
          "updatedAt": "2021-10-15T06:46:03Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think that is a meaningful difference.  The attacks described are against an intermediary that doesn't care about the content of the stream unless it fits a particular pattern, with that pattern appearing anywhere.\r\n\r\nThe endpoints might agree on what the protocol is, but the intermediary is oblivious to that.  In that setting, ALPN and SETTINGS do nothing to improve things.  Encryption doesn't help either.",
          "createdAt": "2021-10-15T08:13:55Z",
          "updatedAt": "2021-10-15T08:13:55Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair notes from IETF 112 meeting: let's punt this to the W3C: https://github.com/w3c/webtransport/issues/229",
          "createdAt": "2021-11-09T13:00:53Z",
          "updatedAt": "2021-11-09T13:00:53Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "I_kwDOCvK98s4-f5wa",
      "title": "Folding datagrams/streams into the CONNECT stream",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/66",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "ekinnear"
      ],
      "labels": [
        "capsule-dt"
      ],
      "body": "Should the protocol share framing semantics with the HTTP/2 draft so that it is easy/easier to take datagrams or streams and put them on the CONNECT stream?\r\n\r\nShould it be possible to use that mechanism, or should it instead be forbidden?\r\n\r\nAs much as possible, it would be desirable to have the forwarding logic be fairly uniform across different protocol versions.  Right now, we have two almost completely different protocols.",
      "createdAt": "2021-11-09T12:28:30Z",
      "updatedAt": "2022-12-16T19:10:13Z",
      "closedAt": "2022-12-16T19:10:13Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I was discussing this with @ekinnear and @vasilvv.  What happens when an H3 WT server receives \"version independent\" WT framing on its CONNECT stream.\r\n\r\nSince WT over H3 requires H3 datagrams, then there is no need to fold datagrams into the CONNECT stream.  There shouldn't be a need to fold streams either, unless you want to defeat QUIC stream limits :) \r\n\r\nAllowing this would also increase work to implement an H3 only WT client/server: you have to re-implement QUIC over an HTTP byte-stream just in case the peer decides to send you \"version independent\" WT.\r\n\r\nRight now I think they are totally different and never the twain shall meet.  Proxies can convert between the two versions.  If we did that, should we have different upgrade tokens?",
          "createdAt": "2021-11-09T12:59:04Z",
          "updatedAt": "2021-11-09T12:59:04Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Is this issue still relevant now that we have the outcome of HTTP Datagram Design Team?",
          "createdAt": "2022-03-21T21:04:47Z",
          "updatedAt": "2022-03-21T21:04:47Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson gentle ping",
          "createdAt": "2022-07-20T21:19:40Z",
          "updatedAt": "2022-07-20T21:19:40Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually never mind, this is blocked on the capsule design team - the output of that design team will decide on whether the h2 capsules are allowed in h3 or not",
          "createdAt": "2022-07-20T21:21:09Z",
          "updatedAt": "2022-07-20T21:21:09Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "I_kwDOCvK98s4-mmkO",
      "title": "Describe what is allowed after sending or receiving a GOAWAY",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/67",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If a connection carrying WebTransport sessions receives a GOAWAY, is the sender allowed to continue \r\n\r\n1) sending datagrams\r\n2) creating new WT streams\r\n3) receiving new WT streams\r\n\r\nI assume it's ok to continue sending data on already open WT streams and the CONNECT stream, but clarification would be good.\r\n\r\nAlso, are the rules any different after sending a GOAWAY?  Can the sender continue doing the above?",
      "createdAt": "2021-11-10T21:03:00Z",
      "updatedAt": "2022-06-30T13:03:29Z",
      "closedAt": "2022-06-30T13:03:29Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll just note that because in H2 WT streams are contained to a single stream, they are implicitly allowed there unless we forbid them.",
          "createdAt": "2021-11-10T21:04:04Z",
          "updatedAt": "2021-11-10T21:04:04Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at IETF 113, consensus to have GOAWAY not prevent opening new WT streams on existing WT sessions. @vasilvv will write a PR",
          "createdAt": "2022-03-24T14:17:00Z",
          "updatedAt": "2022-03-24T14:17:00Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "I_kwDOCvK98s5Dzz3v",
      "title": "Remove implicit SETTINGS_ENABLE_CONNECT_PROTOCOL",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/68",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ekinnear"
      ],
      "labels": [
        "ready for PR"
      ],
      "body": "[Section 3.2](https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-http3-02#section-3.2) currently states:\r\n> the SETTINGS_ENABLE_WEBTRANSPORT setting implies that an endpoint supports extended CONNECT\r\n\r\nThat is not well-defined: it relies on [RFC 8441](https://datatracker.ietf.org/doc/html/rfc8441) which only discusses HTTP/2, and the relevant changes between HTTP/2 and HTTP/3 are subtle.\r\n\r\nSince we have [a draft for extended CONNECT for HTTP/3](https://datatracker.ietf.org/doc/draft-ietf-httpbis-h3-websockets/) that is now in the RFC Editor Queue, WebTransport needs to instead refer to that and require servers to send `SETTINGS_ENABLE_CONNECT_PROTOCOL`.",
      "createdAt": "2022-02-14T18:03:33Z",
      "updatedAt": "2023-02-07T23:10:04Z",
      "closedAt": "2023-02-07T23:10:04Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "This sounds like an obvious way forward.\r\n\r\nThat said, I would personally prefer to wait until we make another breaking wire protocol change.",
          "createdAt": "2022-03-21T20:22:38Z",
          "updatedAt": "2022-03-21T20:22:38Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good to me, there's no rush here - in my personal opinion we just need to get this in before WGLC",
          "createdAt": "2022-03-22T10:29:44Z",
          "updatedAt": "2022-03-22T10:29:44Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "More generally, it looks like we may want to remove any implied support and just require endpoints to explicitly signal support for each \"layer\" of capabilities that we're relying on.",
          "createdAt": "2022-10-24T19:11:48Z",
          "updatedAt": "2022-10-24T19:11:48Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 115, consensus in room to require all the relevant settings and transport parameters to be sent individually - for this issue means: require that SETTINGS_ENABLE_CONNECT_PROTOCOL be sent",
          "createdAt": "2022-11-10T14:01:13Z",
          "updatedAt": "2022-11-10T14:01:13Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "I_kwDOCvK98s5FQWmj",
      "title": "Stream Limits",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/70",
      "state": "CLOSED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "pooling"
      ],
      "body": "Moving [this](https://github.com/ietf-wg-webtrans/draft-webtransport-http2/issues/24) to HTTP/3 since it's no longer an issue for HTTP/2:\r\n\r\nFrom @martinthomson:\r\n> This is likely shared with the HTTP/3 mapping also, but I'm here first.\r\n>\r\n> Web applications will want some degree of certainty about the streams they are able to access. As they also operate servers, this is probably not so bad in the client-to-server direction. The main concern for client-to-server is the potential for the connection to be used for HTTP requests that consume these limits. In the server-to-client direction clients might need to provide some number of streams that it would guarantee that a server can use for a given session.\r\n>\r\n> As multiple sessions are involved, this gets harder, because the web security model might prevent us from exposing information about what other origins are using a shared connection for. That said, it's not clear that there is any value in withholding this information either (see https://github.com/ietf-wg-webtrans/draft-webtransport-http2/issues/23) as the security boundary is essentially already gone once coalescing is involved.\r\n>\r\n> (I'm deliberately not considering isolation of state by top-level browsing context; I expect that no coalescing or connection sharing would occur for different top-level sites.)",
      "createdAt": "2022-03-07T20:56:40Z",
      "updatedAt": "2022-03-24T14:37:32Z",
      "closedAt": "2022-03-24T14:37:31Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Is this not effectively same issue as #36?",
          "createdAt": "2022-03-17T18:54:44Z",
          "updatedAt": "2022-03-17T18:54:44Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at 113, closing in favor of #22",
          "createdAt": "2022-03-24T14:37:31Z",
          "updatedAt": "2022-03-24T14:37:31Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "I_kwDOCvK98s5GIPNf",
      "title": "Bidirectional Stream Frame Ordering Requirements",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/71",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "vasilvv"
      ],
      "labels": [
        "ready for PR",
        "ietf-114",
        "ietf-115"
      ],
      "body": "The draft says:\r\n> WebTransport endpoints can initiate bidirectional streams by opening an HTTP/3 bidirectional stream and sending an HTTP/3 frame with type WEBTRANSPORT_STREAM (type=0x41).\r\n\r\nIt is unclear if it is allowed to send other frames before sending the WEBTRANSPORT_STREAM frame. I can't think of any currently defined HTTP/3 frame that would make sense to send here, but that might not be the case with future extensions. At the very least, it would be nice of grease frames could be sent.",
      "createdAt": "2022-03-22T10:18:49Z",
      "updatedAt": "2023-02-21T23:10:58Z",
      "closedAt": "2023-02-21T23:10:58Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "#48 touches on this issue for unidirectional WT streams - eg: should they be defined as a sequence of TLV frames followed by a WT TV frame which converts the stream to unframed?",
          "createdAt": "2022-03-22T10:48:32Z",
          "updatedAt": "2022-03-22T10:48:32Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "What is the value in sending grease frames on these streams?  Specifically to allow for future extensions that send other frames before WEBTRANSPORT_STREAM?",
          "createdAt": "2022-03-22T13:58:21Z",
          "updatedAt": "2022-03-22T13:58:21Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I can imagine sending a PRIORITY_UPDATE or something of that nature, though it's not clear to me it's worth the effort compared top just not using any frames on the stream before WEBTRANSPORT_STREAM.",
          "createdAt": "2022-03-23T20:19:22Z",
          "updatedAt": "2022-03-23T20:19:22Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at IETF 114, consensus in the room to\r\n* be consistent between unidirectional and bidirectional\r\n* require WEBTRANSPORT_STREAM to be the first frame on a bidirectional stream\r\n* this also disallows extension frames before WEBTRANSPORT_STREAM",
          "createdAt": "2022-07-26T15:48:17Z",
          "updatedAt": "2022-07-26T15:48:17Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wasn't in the room but following up on the meeting recording, I could support this proposal. However, I don't understand how we make the WEBTRANSFORM_STREAM actually do what we describe here robustly, so I opened #81",
          "createdAt": "2022-08-04T16:43:06Z",
          "updatedAt": "2022-08-04T16:43:06Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "I_kwDOCvK98s5GuzG4",
      "title": "closing streams when the session is closed",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/72",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The draft says that all streams need to be closed when the WebTransport session is closed.\r\n\r\nThis makes me wonder:\r\n1. Which error code to use for that? Should we mandate using the same error code that the WebTransport session was closed with?\r\n2. Stream tracking: If it's the WebTransport implementation's responsibility to reset all the stream, this means that I need to keep another list / map of streams (outside of my QUIC stack). The interesting question is how to garbage collect closed streams from that list. It seems like the only way to do so is by introducing a callback for my QUIC stack to signal that a stream was closed / reset in both directions, so I can clean it up on the WebTransport layer.",
      "createdAt": "2022-03-30T16:00:15Z",
      "updatedAt": "2022-07-24T19:57:17Z",
      "closedAt": "2022-07-24T19:57:17Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding the first issue, I was going to add a separate error code, but forgot to.  Wrote #75 to address this.\r\n\r\nRegarding the second issue, I am not sure what the question here.  In Chromium, we keep a list of stream IDs for every WebTransport session, and call Reset() on all stream once the CONNECT stream is closed.",
          "createdAt": "2022-06-27T13:50:06Z",
          "updatedAt": "2022-06-27T13:50:06Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@marten-seemann gentle ping",
          "createdAt": "2022-07-20T21:22:33Z",
          "updatedAt": "2022-07-20T21:22:33Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#75 fixes the issue. Regarding my second point, I assume that most implementations will actually keep a second map of streams around, but that's an implementation detail that we probably don't need to address in the spec.",
          "createdAt": "2022-07-24T19:57:17Z",
          "updatedAt": "2022-07-24T19:57:17Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "I_kwDOCvK98s5G_bYQ",
      "title": "opening WebTransport streams before the WebTransport session is established",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/73",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "marten-seemann"
      ],
      "labels": [
        "editorial"
      ],
      "body": "In order to save a round-trip on connection establishment, a client could optimistically open streams just after sending the CONNECT request, before it has received a reply from the server.\r\n\r\nAs both unidirectional and bidirectional streams are identified by the session ID, the server will be able to associate these streams with the WebTransport session as soon as it has processed the CONNECT request.\r\n\r\nIn case the server rejects the CONNECT request, the client should probably reset / cancel these streams. Note that this doesn't require any additional logic on the server side, as the server needs to be prepared to receive streams for sessions that it didn't establish anyway (a malicious client might open streams with arbitrary session IDs, and a server should better be prepared for that).\r\n\r\n\r\nCurrently, the spec forbids opening unidirectional streams before the session is established:\r\n> Once established, both endpoints can open unidirectional streams.\r\n\r\nThere's no such restriction for bidirectional stream.",
      "createdAt": "2022-04-03T20:09:30Z",
      "updatedAt": "2022-10-28T20:02:37Z",
      "closedAt": "2022-10-28T20:02:37Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this is a left-over from the older text of the draft.  We've agreed in #29 that both types of streams should be sent immediately, and as far as I remember, that is what the Chrome implementation does.",
          "createdAt": "2022-04-11T14:46:42Z",
          "updatedAt": "2022-04-11T14:46:42Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I believe this is a left-over from the older text of the draft. We've agreed in https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/29 that both types of streams should be sent immediately\r\n\r\nThat's great! I'll write up a PR.\r\n\r\n> and as far as I remember, that is what the Chrome implementation does\r\n\r\nHow does that work? I tried it out, but it seems like `transport.ready` waits for the response to the CONNECT request. This is my JS code:\r\n```js\r\nconst transport = new WebTransport(url);\r\nawait transport.ready;\r\nlet str = await transport.createBidirectionalStream();\r\nlet wr = await str.writable.getWriter();\r\nawait wr.write((new TextEncoder()).encode(\"Hello world!\"));\r\nawait wr.close();\r\n```\r\nRemoving the `await transport.ready` also doesn't work, then I'm getting this error:\r\n> Uncaught DOMException: Failed to execute 'createBidirectionalStream' on 'WebTransport': No connection.\r\n\r\nAny hint would be highly appreciated.",
          "createdAt": "2022-04-13T12:36:49Z",
          "updatedAt": "2022-04-13T12:36:49Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Good question.  I am not sure the current API state machine allows this; when I said \"what the Chrome implementation does\", I meant that it supports receiving streams before it considers them confirmed (for the client, it means that streams received before HTTP 200 for the CONNECT stream are buffered instead of dropped).  We should probably figure out how to allow this on the client side, but that's a W3C issue.",
          "createdAt": "2022-04-13T18:05:21Z",
          "updatedAt": "2022-04-13T18:05:21Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From my reading of the W3C spec this is already allowed: https://www.w3.org/TR/webtransport/#dom-webtransport-createbidirectionalstream\r\n> Run the following steps [in parallel](https://html.spec.whatwg.org/multipage/infrastructure.html#in-parallel), but abort them whenever transport\u2019s [[[State]]](https://www.w3.org/TR/webtransport/#webtransport-state) becomes \"closed\" or \"failed\", and instead [queue a network task](https://www.w3.org/TR/webtransport/#webtransport-queue-a-network-task) with transport to [reject](http://www.ecma-international.org/ecma-262/6.0/index.html#sec-promise-objects) p with an [InvalidStateError](https://webidl.spec.whatwg.org/#invalidstateerror).\r\n> 1. Wait for transport\u2019s [[[State]]](https://www.w3.org/TR/webtransport/#webtransport-state) to be \"connected\".\r\n> 2. Let internalStream be the result of [creating a bidirectional stream](https://www.w3.org/TR/webtransport/#session-create-a-bidirectional-stream) with transport\u2019s [[[Session]]](https://www.w3.org/TR/webtransport/#webtransport-session).\r\n\r\nSo maybe this is just a bug in Chrome that it returns the `DOMException`?",
          "createdAt": "2022-04-13T18:51:05Z",
          "updatedAt": "2022-04-13T18:51:05Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds like we need an editorial PR to clarify that this is allowed",
          "createdAt": "2022-07-20T21:23:43Z",
          "updatedAt": "2022-07-20T21:23:43Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#80 adds some text to clarify that opening streams as well as sending datagrams is permitted as soon as the CONNECT request has been sent out.",
          "createdAt": "2022-07-24T20:06:23Z",
          "updatedAt": "2022-07-24T20:06:23Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "I_kwDOCvK98s5MvWAh",
      "title": "Stream resets can leave streams half-closed indefinitely",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/77",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "vasilvv"
      ],
      "labels": [
        "ietf-114",
        "ietf-115",
        "has pull request"
      ],
      "body": "Consider the following situation:\r\n1. A opens a bidirectional WebTransport stream to B, sends some application data, and then decides to abort data transmission (i.e. it sends a RESET_STREAM frame)\r\n2. B receives the RESET_STREAM frame before it receives the application data, and surfaces the stream reset to the WebTransport application before it had the chance to read the Session ID. Note that there's no way around this: the STREAM frames might have been lost, and A won't retransmit them since the stream was reset.\r\n\r\nWe're now in the situation where one side of the stream is reset, but the other side of the stream is still open. Unless _someone_ explicitly closes / resets the other side of the stream, it will stay this way indefinitely.\r\n\r\nI can see two ways forward here:\r\n1. Require A to send a STOP_SENDING frame as well. This is a kind of sad solution, as this would be a significant deviation from the QUIC stream state machine.\r\n2. Require B to reset streams iff it processes B's stream reset before reading the session ID. We'd have to define the error code to use for that.",
      "createdAt": "2022-06-28T14:56:02Z",
      "updatedAt": "2024-06-11T22:31:50Z",
      "closedAt": "2024-06-11T22:31:50Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "In the case of 2, if we're talking about a client initiated bidirectional stream, the server (B) might not know if the stream was a request stream or a WebTransport stream (or some other kind of extension stream).  I suppose there isn't much harm to requiring a RST_STREAM in response an HTTP request that got reset before it was processed.  For combining with other extensions that use bidi streams, I'm less sure.\r\n\r\nI think there's another way forward, which is that WebTransport streams need a reset message at a layer above the QUIC transport (eg: a capsule on the CONNECT stream).  I recall there was another issue for which that might be useful.",
          "createdAt": "2022-07-20T20:30:30Z",
          "updatedAt": "2022-07-20T20:30:30Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at IETF 114, consensus in room to resolve this by adding a capsule that reliably communicates that a reset stream is associated with a WebTransport session",
          "createdAt": "2022-07-26T15:56:38Z",
          "updatedAt": "2022-07-26T15:56:38Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We're now in the situation where one side of the stream is reset, but the other side of the stream is still open.\r\n\r\nAdding to this:\r\n* B doesn't know if the stream was a WebTransport or an HTTP/3 stream\r\n* if there are multiple WebTransport sessions running on the QUIC connection, B doesn't know which transport session the stream was associated with\r\n\r\nIt now depends on the application protocol if this is problematic or not. Some application protocols might allow the peer to respond to a stream reset, which is only possible if the stream can actually be routed to that application protocol.",
          "createdAt": "2022-10-27T21:13:02Z",
          "updatedAt": "2022-10-27T21:13:02Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at IETF 115, consensus in room was to solve this at the QUIC layer in the QUIC WG",
          "createdAt": "2023-02-07T23:17:18Z",
          "updatedAt": "2023-02-07T23:17:18Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: now that [draft-ietf-quic-reliable-stream-reset](https://datatracker.ietf.org/doc/draft-ietf-quic-reliable-stream-reset/) is almost entering QUIC WGLC, we're declaring this issue unblocked and ready for PR. The PR would add a dependency on that draft with normative text on how to use it",
          "createdAt": "2024-01-23T23:42:43Z",
          "updatedAt": "2024-01-23T23:42:43Z"
        }
      ]
    },
    {
      "number": 78,
      "id": "I_kwDOCvK98s5NeKJQ",
      "title": "When closing a session, should the read side of the request stream be reset?",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/78",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "afrind"
      ],
      "labels": [
        "ready for PR",
        "ietf-114"
      ],
      "body": "After sending the CLOSE_WEBTRANSPORT_SESSION capsule and sending the FIN on the stream, it would make sense to also stop reading on the stream (by sending a STOP_SENDING). Should that be the recommended behavior in the spec?",
      "createdAt": "2022-07-09T19:28:25Z",
      "updatedAt": "2023-03-07T23:34:34Z",
      "closedAt": "2023-03-07T23:34:34Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at IETF 114, consensus in the room to allow but not require sending STOP_SENDING",
          "createdAt": "2022-07-26T16:03:10Z",
          "updatedAt": "2022-07-26T20:29:05Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "The spec currently reads:\r\n\r\n```\r\nA CLOSE_WEBTRANSPORT_SESSION capsule MUST be followed by a FIN on the sender\r\nside.  If any additional stream data is received on the CONNECT stream after\r\nCLOSE_WEBTRANSPORT_SESSION, the stream MUST be reset with code\r\nH3_MESSAGE_ERROR.  The recipient MUST close the stream upon receiving a FIN.\r\nIf the sender of CLOSE_WEBTRANSPORT_SESSION does not receive a FIN after some\r\ntime, it SHOULD send STOP_SENDING on the CONNECT stream.\r\n```\r\n\r\nSo it currently recommends setting a timer and then issuing a STOP_SENDING.  I guess the request here is to send indicate the sender of CLOSE_WEBTRANSPORT_SESSION may send the STOP_SENDING immediately.  I'm going to remove the bit about the timer since it's not really relevant?  If the closing endpoint wants to wait to see if there's any other messages in flight on the CONNECT stream that's fine.  The CLOSE_WEBTRANSPORT_SESSION + FIN + must-respond-with-FIN is an implicit STOP_SENDING.",
          "createdAt": "2023-03-07T19:06:21Z",
          "updatedAt": "2023-03-07T19:06:21Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "I_kwDOCvK98s5PNZSU",
      "title": "Indefinite-length frames are too underspecified",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/81",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ietf-115"
      ],
      "body": "I'm curious how anyone has got handling of the WEBTRANSPORT_STREAM frame working based on strict following of the specs. \r\n\r\nWT over H3 says:\r\n\r\n> A client can create a bidirectional stream using a special indefinite-length HTTP/3 frame that transfers ownership of the stream to WebTransport.\r\n\r\nH3 says in https://www.rfc-editor.org/rfc/rfc9114.html#name-frame-layout:\r\n\r\n> All frames have the following format\r\n> HTTP/3 Frame Format {\r\n  Type (i),\r\n  Length (i),\r\n  Frame Payload (..),\r\n}\r\n\r\nsnip\r\n\r\n> Each frame's payload MUST contain exactly the fields identified in its description. A frame payload that contains additional bytes after the identified fields or a frame payload that terminates before the end of the identified fields MUST be treated as a [connection error](https://www.rfc-editor.org/rfc/rfc9114.html#errors) of type [H3_FRAME_ERROR](https://www.rfc-editor.org/rfc/rfc9114.html#H3_FRAME_ERROR). In particular, redundant length encodings MUST be verified to be self-consistent; see [Section 10.8](https://www.rfc-editor.org/rfc/rfc9114.html#frame-parsing).\r\n\r\nWT over h3 says of the `WEBTRANSPORT_STREAM` frame:\r\n\r\n> The format of the frame SHALL be the frame type, followed by the session ID, encoded as a variable-length integer, followed by the user-specified stream data ([Figure 2](https://ietf-wg-webtrans.github.io/draft-ietf-webtrans-http3/draft-ietf-webtrans-http3.html#fig-bidi-client)). The frame SHALL last until the end of the stream.\r\n\r\nSo it appears that WT is trying to omit the length field to imply an Indefinate length, but H3 doesn't allow that. I'd expect a standard H3 frame parser to read the first N bytes of the session ID and incorrectly parse that as the length. I don;t think you can special case this frame, because your breaking the H3 contract that unknown frame types have a correct length that allows them to be read and discarded.\r\n\r\nOne option (lets call it A) would be to say that `WEBTRANSPORT_STREAM` has a length field of MAX_VAL and then create a new caveat that if you're a WebTransport supporting endpoint, you don't need to create a connection error the stream if it is FIN'd before that length is reached. However, that has the unfortunate problem of consuming 8 bytes at the start of every stream.\r\n\r\nAnother option (B) might be to say that the `WEBTRANSPORT_STREAM` frame is fixed length as so:\r\n\r\n> WEBTRANSPORT_STREAM Frame {\r\n  Type (i) = 0x41,\r\n  Length (i),\r\n  Session ID (i),\r\n}\r\n\r\nMeaning the frame only contains the Session ID field, and the length of that frame is truly the length of Session ID - satisfying the general H3 requirements. Then after this frame, you switch into WebTransport bidi streams as we seem to be going towards on #71. However, H3 endpoints that read this frame and discard it, would then move on to parsing the subsequent bytes as frames (when the sender never intended that) and bad stuff might happen.",
      "createdAt": "2022-08-04T16:40:00Z",
      "updatedAt": "2023-03-08T01:04:38Z",
      "closedAt": "2023-03-08T01:04:38Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "We already discussed this in #26.  The expectation for unknown H3 frames to have length does not apply here: WebTransport support is explicitly negotiated via SETTINGS, meaning that by the time someone sends WEBTRANSPORT_STREAM, both peers know they support it.",
          "createdAt": "2022-08-08T05:42:57Z",
          "updatedAt": "2022-08-08T05:42:57Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for reminding of that.\r\n\r\nGiven the discussion on #71, if ee go that way I don't think we should bother calling this an HTTP/3 frame. For all intents and purposes it isn't. Rather, we could make it clearer that WebTransport is a semantic extension to H3 that permits client bidirectional streams to start with a special byte sequence that changes the stream purpose and meaning.",
          "createdAt": "2022-08-08T08:57:47Z",
          "updatedAt": "2022-08-08T08:57:47Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "It needs to be registered in the h3 frame type IANA registry to avoid conflicts though",
          "createdAt": "2022-08-08T16:48:32Z",
          "updatedAt": "2022-08-08T16:48:32Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You could seek to reserve the codepoint to help prevent unintended interop problems, we already do that e.g. https://www.rfc-editor.org/rfc/rfc9114.html#section-7.2.8\r\n\r\n> Frame types that were used in HTTP/2 where there is no corresponding HTTP/3 frame have also been reserved ([Section 11.2.1](https://www.rfc-editor.org/rfc/rfc9114.html#iana-frames)). These frame types MUST NOT be sent, and their receipt MUST be treated as a [connection error](https://www.rfc-editor.org/rfc/rfc9114.html#errors) of type [H3_FRAME_UNEXPECTED](https://www.rfc-editor.org/rfc/rfc9114.html#H3_FRAME_UNEXPECTED).",
          "createdAt": "2022-08-08T16:52:28Z",
          "updatedAt": "2022-08-08T16:52:28Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "At the end of the day calling this an infinite-length-frame or a non-frame-that-is-reserved-in-the-list-of-frames ends up being the same thing implementation-wise. My personal two cents is that infinite-length frame is easier to explain and reason about.",
          "createdAt": "2022-08-08T16:54:37Z",
          "updatedAt": "2022-08-08T16:54:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I disagree. With the proposal on #71, we're making a non-frame that can't have anything before or after it. This is a very special thing that sticks out and I doubt is likely to be replicated.\r\n\r\nSo I'd like to hear what other implementers have done or would do. My implementation that reads from streams already has branches that go into frame parsing mode or not depending on the stream type. If I were to add the code, I'd model it as a different stream type that is only supported when WebTransport is enabled and it wouldn't touch my frame parsing part at all. \r\n\r\nedit: (added comment) given HTTP/3 already has the notion of stream types, I don't know why we need to invent another special concept in HTTP/3 to support WebTransport.",
          "createdAt": "2022-08-08T17:12:14Z",
          "updatedAt": "2022-08-08T17:13:37Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting, @vasilvv thinks this is resolved by #96. @LPardue do you agree?",
          "createdAt": "2023-03-07T23:49:05Z",
          "updatedAt": "2023-03-07T23:49:05Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry I missed that PR as I was on holiday. I believe that #96 channels the spirit of my PR #83, and addresses the original issue here\r\n\r\nI think the text could continue to have some editorial improvements to better highlight how much of a divergence this is for request streams, but lets track the separately. ",
          "createdAt": "2023-03-08T00:46:07Z",
          "updatedAt": "2023-03-08T00:46:07Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Awesome, thanks Lucas! Closing based on that comment.\r\n\r\nFor the remaining editorial bits, please file a separate issue or PR :-)",
          "createdAt": "2023-03-08T01:04:38Z",
          "updatedAt": "2023-03-08T01:04:38Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "I_kwDOCvK98s5Ut0sA",
      "title": "WT over HTTP/3 should require capsule support and datagram support explicitly",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/84",
      "state": "CLOSED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ekinnear"
      ],
      "labels": [
        "ietf-115",
        "has pull request"
      ],
      "body": "Per discussion at IETF 114, we should explicitly require support for each layer of capabilities that are needed. \r\n\r\nThere was also a discussion about whether or not we needed to require datagram support, since requiring capsules technically means that you could use a datagram capsule and implementations may exist that do not want to have datagram support at all.\r\n\r\nDocumenting some of that discussion in replies to this issue, as well.",
      "createdAt": "2022-10-24T19:13:30Z",
      "updatedAt": "2023-03-13T20:46:07Z",
      "closedAt": "2023-03-13T20:46:07Z",
      "comments": [
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Specific to datagrams and capsules:\r\n- WT supported means that capsule protocol is supported, thus you must always support capsules.\r\n- Proposal: You need to have datagrams in order to do WT over HTTP/3\r\n    - Adding additional signaling to negotiate datagram support introduces a lot of additional complexity and different configurations that may harm interoperability.\r\n    - Dropping a datagram is about as easy as doing any other error path\r\n    - HTTP Datagrams must already be supported in the receive direction for capsules (and you need capsules for WT) either way\r\n- Intermediaries will need to be able to either translate for upstream or ensure that upstream can provide an equivalent feature set\r\n\r\nMore generally:\r\n- We want to explicitly call out dependencies/prerequisites so that we don't need to teach layers about other layers. For example, WT being supported doesn't mean that the layers that implement capsules, H3 datagrams, or QUIC datagrams should have any idea about the existence of WebTransport",
          "createdAt": "2022-10-24T19:17:18Z",
          "updatedAt": "2022-10-24T19:21:46Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at IETF 115, consensus in room to require all the relevant settings and transport parameters to be sent individually",
          "createdAt": "2022-11-10T14:00:40Z",
          "updatedAt": "2022-11-10T14:00:40Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "So we need: \r\n- HTTP Setting: SETTINGS_H3_DATAGRAM (0x33) with a value of 1 for HTTP datagrams\r\n- QUIC TP: max_datagram_frame_size with a value greater than 0 for QUIC datagrams\r\n- Capsule protocol support is implicit in the `webtransport` upgrade token, as explicitly called out by RFC 9297 _or_ we can require `Capsule-Protocol: true` to be sent on every extended connect request as well.\r\n\r\nto be added to the existing\r\n- HTTP Setting: SETTINGS_ENABLE_WEBTRANSPORT = 1\r\n- HTTP Setting: SETTINGS_WEBTRANSPORT_MAX_SESSIONS > 0\r\n\r\n(although we may be removing SETTINGS_ENABLE_WEBTRANSPORT)",
          "createdAt": "2023-03-11T00:22:25Z",
          "updatedAt": "2023-03-11T00:22:48Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "SGTM\r\nI think we can skip mentioning Capsule-Protocol to match CONNECT-UDP",
          "createdAt": "2023-03-11T00:30:32Z",
          "updatedAt": "2023-03-11T00:30:32Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "I_kwDOCvK98s5VH8Bt",
      "title": "MAX_STREAMS and flow control",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/85",
      "state": "OPEN",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "vasilvv"
      ],
      "labels": [
        "ietf-115",
        "ietf-116",
        "has pull request",
        "ietf-117",
        "ietf-118"
      ],
      "body": "From https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/22#issuecomment-1077698720:\r\n> figure out MAX_STREAMS, a way to limit the number of streams within a session\r\n\r\nWe've addressed the rest of the plan except for this part via the capsule DT, but there are still open questions about reordering of closed streams and their interaction with stream flow control limits via MAX_STREAMS.",
      "createdAt": "2022-10-29T08:01:02Z",
      "updatedAt": "2024-08-20T22:22:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "If reliable resets happen in QUIC, then it should be possible to model this after how QUIC MAX_STREAMS works, and we can just look at the biggest numbered stream.",
          "createdAt": "2023-02-07T23:24:05Z",
          "updatedAt": "2023-02-07T23:24:05Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at IETF 116. Consensus in room was to punt this unless someone proposes a solution. More specifically, we'll keep this issue open until IETF 117. If someone proposes a PR (or separate draft) that adds flow control, we will give them agenda time at IETF 117 and discuss whether to include it based on the details of the proposal. If no one has proposed anything by then, we will close the issue with no action.",
          "createdAt": "2023-03-29T05:47:50Z",
          "updatedAt": "2023-03-29T05:47:50Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting. @ekinnear and @martinthomson wrote up a proposal. Action Item is with @vasilvv to review.",
          "createdAt": "2023-04-18T22:18:21Z",
          "updatedAt": "2023-04-18T22:18:21Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://www.ietf.org/archive/id/draft-thomson-webtrans-session-limit-00.html is the proposal.  We might also want to consider the inclusion of the WebTransport-Init header field to govern initial values for those.  And then, see https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http2/pull/78 regarding settings to additionally govern these.",
          "createdAt": "2023-05-02T22:36:45Z",
          "updatedAt": "2023-05-02T22:36:45Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at editor's meeting: plan is to discuss at 117. @ekinnear can you make slides please?",
          "createdAt": "2023-07-18T22:12:30Z",
          "updatedAt": "2023-07-18T22:12:30Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at 117. Lots of discussion in the room, but consensus in room on the following:\r\n* we can't do pooling without flow control as that would cause starvation\r\n* we want JavaScript to not get measurable changes when the session is pooled vs not pooled\r\n* therefore, we can't disable flow control when pooling is disabled\r\n* this is hard to implement\r\n* implementers are focusing on other parts of WebTransport first\r\n* for now, we'll wait on more implementer experience\r\n* we will not publish the document without flow control",
          "createdAt": "2023-07-27T21:55:12Z",
          "updatedAt": "2023-07-27T21:55:12Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at length in editor's meeting. @ekinnear to file an issue with the W3C. Needs more discussion here, too.",
          "createdAt": "2023-08-08T23:05:23Z",
          "updatedAt": "2023-08-08T23:05:23Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I've been thinking about this a bit more, and I'm not sure draft-thomson-webtrans-session-limit actually solves the problem fully.\r\n\r\nConsider the following situation.  Imagine I have a connection where the client can open up to 100 streams (let's exclude actual HTTP requests for now), and it has 10 sessions.  We want to avoid the situation where one session uses up all of the resources.\r\n\r\nAs far as I can tell, the nested flow control does not actually solve this problem.  The server can tell the peer that it can accommodate 100 streams on every session, and that would be a perfectly valid thing to do (if, e.g., it's proxying to a backend, and backend's limit is also 100).  The problem here is running into the connection-wide limit (that we already know).\r\n\r\nNow, one possible scheme here would be to just do proportionate allocation.  The browser sees it has 100 streams remaining, it can allocate 10 streams to each session.\r\n\r\nAnother option would be to separate stream limits for WebTransport sessions and stream limits for HTTP/3 stuff.  I wrote a draft on one possible way to do this: https://vasilvv.github.io/draft-vvv-quic-namespaces/draft-vvv-quic-namespaces.html",
          "createdAt": "2023-08-22T16:55:09Z",
          "updatedAt": "2023-08-22T16:55:09Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting. Folks voiced concerns about various complex solutions to the flow control issue. There's interest in writing up a simple solution for now and allowing future extensions to be more complex if needed. @vasilvv has the action item to write up a minimal proposal that handles just enough flow control",
          "createdAt": "2023-09-19T22:30:12Z",
          "updatedAt": "2023-09-19T22:30:12Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "So, the basic problem we are trying to solve here is as follows. Thanks to the QUIC flow control mechanisms, an endpoint has a limit on how many streams it can open. That limit is shared by multiple WebTransport sessions, as well as non-WebTransport streams (such as regular HTTP requests). The endpoint has to limit the number of streams in each session, and also limit number of concurrent HTTP requests so that they don't starve out WebTransport data streams.\r\n\r\nWe can model this limitation as\r\n```\r\nmax_concurrent_streams = max_streams_per_session * max sessions + max_requests,\r\n```\r\nwhere we already know `max_sessions` from SETTINGS_WEBTRANSPORT_MAX_SESSIONS. We *kind of* know `max_concurrent_streams` from the flow control window, though that is not necessarily always the number we want, since the peer can use different strategies for updating window (e.g. start low and ramp it up exponentially).\r\n\r\nMy current proposal is to add a setting for WEBTRANSPORT_MAX_BIDI_STREAMS_HINT and MAX_TOTAL_BIDI_STREAMS_HINT, that tell us the values of `max_streams_per_session` and `max_concurrent_streams`; `max_requests` can be inferred from the formula above.\r\n\r\nWorked example: assume that a server is willing to accept a max of 100 concurrent streams. It sends a MAX_STREAM_ID of 400 to indicate that; it also sends MAX_TOTAL_BIDI_STREAMS_HINT of 100 to indicate that this is what the client should expect going further.  The server can set MAX_SESSIONS to 3, and WEBTRANSPORT_MAX_BIDI_STREAMS_HINT to 30, meaning that the three WebTransport sessions can consume a total of 90 streams, leaving a headroom of at least 10 streams to regular HTTP traffic.\r\n\r\nNote that those are called \"hints\", because those are not directly enforced; if the client does not enforce those, some parts of the connection may starve the others, but this is not a concern since (1) all of those share the same origin, and (2) they still have to fit into the peer's overall limit, which is strictly enforced by the protocol.\r\n\r\nThe above mechanism can be extended to other types of streams, as well as MAX_STREAM_DATA (it's actually easier for some of those, since e.g. the only server-initiated bidi streams in H3 are from WebTransport).",
          "createdAt": "2023-11-06T03:45:20Z",
          "updatedAt": "2023-11-06T03:45:20Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "NONE",
          "body": "We should think about this from an adversarial perspective as well.  Recent experience with HTTP/2 Rapid Reset (and similar) attacks demonstrate further how servers need to be able to bound their resource usage.  We'll want to make sure servers can defend themselves against a range of creative attacks in a way that doesn't impair interoperability.",
          "createdAt": "2023-11-06T15:52:24Z",
          "updatedAt": "2023-11-06T15:52:24Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in the WG session at IETF 118. No consensus on a path forward at this stage. We heard:\r\n* we don't need flow control\r\n* we should do flow control hints\r\n* we need a reliable flow control solution\r\n\r\nAll of which happen to be incompatible.\r\n\r\nWe'll need to keep discussing this. The chairs will consider potentially setting up an interim meeting focused on this topic.",
          "createdAt": "2023-11-06T15:54:11Z",
          "updatedAt": "2023-11-06T15:54:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Assigning to @vasilvv since @ekinnear has written the PR so the next step here is for @vasilvv to review #166.",
          "createdAt": "2024-08-20T22:22:33Z",
          "updatedAt": "2024-08-20T22:22:33Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "I_kwDOCvK98s5W8whb",
      "title": "race condition when closing the underlying QUIC connection",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/89",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "vasilvv"
      ],
      "labels": [],
      "body": "A common use (at least for non-pooled WebTransport connections) will be to close the underlying QUIC connection when closing the WebTransport session.\r\n\r\nThis is inherently racy: The sender will send both a CLOSE_WEBTRANSPORT_SESSION capsule and a QUIC CONNECTION_CLOSE frame (unless you wait for the peer's FIN on the request stream, but why would you?). It's undetermined which one of the two will be received / processed first by the receiver.\r\n\r\nThis is not a problem if the sender uses the same error code and error message for the CONNECTION_CLOSE frame and for the CLOSE_WEBTRANSPORT_SESSION capsule. Assuming the QUIC stack properly exposes these values on its API, the receiver will be able to learn error code and error message.\r\n\r\nShould we add that as a recommendation, or even a requirement?",
      "createdAt": "2022-11-21T23:54:31Z",
      "updatedAt": "2023-03-07T23:30:33Z",
      "closedAt": "2023-03-07T23:30:33Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed during editor's meeting, see https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/95#issuecomment-1439235798",
          "createdAt": "2023-02-21T23:47:11Z",
          "updatedAt": "2023-02-21T23:47:11Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "I_kwDOCvK98s5YqsgW",
      "title": "increase WebTransport error code space",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/90",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready for PR",
        "ietf-116"
      ],
      "body": "The current draft specifies that there are 256 error codes that applications running on top of WebTransport can use. That's a very small number, and I'm currently struggling with mapping some application protocols onto WebTransport, because this space is way too small.\r\n\r\nI'd like to explore if we can increase this space. 16 bit would be the absolute minimum, 32 bit would be nice, but maybe we can even achieve the full 62 bit that QUIC gives us.\r\n\r\nThe draft says:\r\n> Since WebTransport shares the error code space with HTTP/3, WebTransport application errors for streams are limited to an unsigned 8-bit integer, assuming values between 0x00 and 0xff.\r\n\r\nThere's a few problem with that statement:\r\n* It's questionable if WebTransport really shares the error code space with HTTP/3. Arguably, WebTransport takes over the stream from HTTP/3 after the header of the WEBTRANSPORT_STREAM (for bidirectional streams), and after the unidirectional stream type (for unidirectional streams), although technically the respective frame stretches to the end of the stream.\r\n     * This is even more true once we resolve #77, such that stream resets wouldn't end up in limbo when reset before the session ID was read by the receiver.\r\n     * This would allow us to use the entire 62 bit space.\r\n* Even if WebTransport did share the error code space with HTTP/3, it's not clear why this would limit it to an 8-bit integer. HTTP/3 itself uses the the full 62 bit space allowed by QUIC, so it doesn't seem excessive to reserve more than 8 bits out of that space for WebTransport. Even if we consumed 32 bits out of that space, this would barely make a dent in the number of unclaimed HTTP/3 error codes.\r\n\r\nOne thing to keep in mind is that when mapping WebTransport onto HTTP/2, we only have access to 32 bit error code space. It might be desirable to use the same error code space both mappings of WebTransport.\r\n\r\n",
      "createdAt": "2022-12-09T22:58:29Z",
      "updatedAt": "2023-04-18T22:15:21Z",
      "closedAt": "2023-04-18T22:15:21Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The QUIC application error code space is shared between stream and connection level errors. Similar for H2 stream and goaway. There's no way to detangle those. The application protocol is H2 or H3, and WebTransport is squatting over the top. \r\n\r\nGiven that H2 and H3 get by with ~20 error codes each, I'm struggling to understand why something over the top needs more than 256. Grabbing a huge swathe of the available space for WebTransport-only usage can't really be undone. I'd want to see stronger motivation or use cases that cannot be solved some other way by a WebTransport application",
          "createdAt": "2022-12-09T23:32:17Z",
          "updatedAt": "2022-12-09T23:32:17Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The QUIC application error code space is shared between stream and connection level errors. Similar for H2 stream and goaway. There's no way to detangle those. The application protocol is H2 or H3, and WebTransport is squatting over the top.\r\n\r\nThis is subtle. You can regard WebTransport streams as being layered on top of HTTP/3 streams, or you can view WebTransport as \"taking over\" an HTTP/3 stream. While the draft in its current form is more likely to be read as the former, I think that most implementations (including my own) implement the latter.\r\n\r\nYou raise a good point here though. Currently, WebTransport never sets / sends CONNECTION_CLOSE frames, but with the resolution to https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/89 that I proposed, it would. This would necessitate sharing an error code space with HTTP/3, regardless of your views on layering.\r\n\r\n> Grabbing a huge swathe of the available space for WebTransport-only usage can't really be undone.\r\n\r\nI disagree that taking a 32 bit space out of 62 bits qualifies as a huge swathe. It's roughly 1 billionth of the available space.\r\n\r\n> Given that H2 and H3 get by with ~20 error codes each, I'm struggling to understand why something over the top needs more than 256.\r\n\r\nHappy to give more context here. I'm trying to layer libp2p / IPFS on top of WebTransport, thereby giving browsers an easy option to participate in the network. libp2p / IPFS is composed of a large number (dozens) of sub-protocols that are run on top of streams. Each of these sub-protocols would like have their own error code space. It's really easy to exhaust the tiny space of 256 error codes.",
          "createdAt": "2022-12-10T02:16:39Z",
          "updatedAt": "2022-12-10T02:16:39Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the extra information. Does each sub-protocol use more than 256 errors? If not, and the problem is that the sub-protocols have to share a restricted space, that seems like a problem the libp2p / IPFS mapping can and should solve. E.g you'll know what streams belong to which sub-protocol?",
          "createdAt": "2022-12-10T12:49:48Z",
          "updatedAt": "2022-12-10T12:49:48Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Introducing another mapping layer would complicate things quite a bit. Error reporting and monitoring would be much easier if error code were unique.\r\n\r\nI\u2019m not sure how we ended up with 8 bits here, usually IETF protocols that specify a stream multiplexer use a much larger space: 32 bits in the case of H2, and 62 bits for H3.\r\n\r\nIn my use case, assigning unique error codes would be trivial if the error code space was 32 bit, and probably still doable if it was 16 bit.\r\n\r\nAs I\u2019ve argued above, there\u2019s no real reason to limit ourselves to 8 bit, given the vast size of the underlying QUIC error code space.",
          "createdAt": "2022-12-10T19:31:40Z",
          "updatedAt": "2022-12-10T19:31:40Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "But earlier we've said that the error space is shared for GOAWAY and CONNECTION_CLOSE. And if WebTransport can be pooled with conventional HTTP/2 and HTTP/3, then there doesn't seem to be anyway to disambiguation the error codes when they are used for that.",
          "createdAt": "2022-12-10T19:49:09Z",
          "updatedAt": "2022-12-10T19:49:09Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree in general that 8 bits is somewhat suboptimal for application error codes.\r\n\r\nSince we're currently trying to figure out how to make sure that resets of WebTransport streams have the session ID associated with them, would it make sense to use the same mechanism to associate an application reset error code as well?\r\n\r\n> One thing to keep in mind is that when mapping WebTransport onto HTTP/2, we only have access to 32 bit error code space. It might be desirable to use the same error code space both mappings of WebTransport.\r\n\r\nSince we're not re-using HTTP/2 streams as WebTransport streams for WT over HTTP/2, the error space there is actually 62 bits as well.",
          "createdAt": "2023-02-18T23:27:03Z",
          "updatedAt": "2023-02-18T23:27:03Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting, we're blocked on the upcoming \"reliable reset\" draft in the QUIC WG since the details of that will impact what we do here",
          "createdAt": "2023-03-08T00:03:30Z",
          "updatedAt": "2023-03-08T00:03:30Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why is this blocked on reliable resets? Reliable resets only protect the beginning of the stream, containing the WebTransport session ID. The error code is part of the RESET_STREAM frame, and never serialized onto the stream to begin with.",
          "createdAt": "2023-03-08T01:05:06Z",
          "updatedAt": "2023-03-08T01:05:06Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@vasilvv can you answer that please?",
          "createdAt": "2023-03-08T01:06:11Z",
          "updatedAt": "2023-03-08T01:06:11Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "It's blocked because if we adopt marten-seemann/draft-seemann-quic-reliable-stream-reset#2, we can add the full 62-bit error code into the reset payload; if not, we'll have to find an alternative workaround.",
          "createdAt": "2023-03-08T21:00:55Z",
          "updatedAt": "2023-03-08T21:00:55Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see, you don't want to use the RESET_STREAM error code. My objection would be that this makes building a general-purpose API _very_ complicated, but let's keep the discussion on that PR.",
          "createdAt": "2023-03-08T22:27:43Z",
          "updatedAt": "2023-03-08T22:27:43Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at IETF 116. Consensus in room to expand the error code space taken by our current \u201cde-GREASE algorithm\u201d from 8 bits to 32 bits, where all values would be in the varint 8-byte portion of the IANA registry.",
          "createdAt": "2023-03-29T05:44:04Z",
          "updatedAt": "2023-03-29T05:44:04Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "I_kwDOCvK98s5bMjQV",
      "title": "Why is use of the Origin header field a MUST",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/92",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "vasilvv"
      ],
      "labels": [
        "ready for PR"
      ],
      "body": "In draft 03 the following requirement is made\r\n\r\n> An Origin header [[RFC6454](https://www.rfc-editor.org/rfc/rfc6454)] MUST be provided within the request.\r\n\r\nWebTransport's closest equivalent in this regard is WebSockets, which doesn't mandate the origin header; see https://www.rfc-editor.org/rfc/rfc6455#section-1.3\r\n\r\nThis requirement makes it weird to use for user agents that have no concept of an origin model. So the MUST level seems a bit overzealous.",
      "createdAt": "2023-01-12T02:59:09Z",
      "updatedAt": "2023-02-21T23:08:26Z",
      "closedAt": "2023-02-21T23:08:26Z",
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "NONE",
          "body": "It is not just the user agent. Take for example the proposed use of [Web Transport for media over Quic](https://datatracker.ietf.org/doc/draft-lcurley-warp/). That application does not have any concept of \"origin\" -- indeed, there is no mention of the word \"origin\" in that draft.",
          "createdAt": "2023-01-12T19:36:08Z",
          "updatedAt": "2023-01-12T19:36:08Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "I_kwDOCvK98s5gOYIC",
      "title": "Clarify the way the stream is terminated",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/100",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "vasilvv"
      ],
      "labels": [
        "ready for PR",
        "editorial"
      ],
      "body": "We should be clear that:\r\n\r\n- FIN on the CONNECT stream terminates the session\r\n- RESET_STREAM or STOP_SENDING does the same\r\n- When a session is terminated, both ends of the CONNECT stream have to be closed, and all data streams have to be reset.",
      "createdAt": "2023-03-07T23:36:54Z",
      "updatedAt": "2023-06-27T22:13:28Z",
      "closedAt": "2023-06-27T22:13:28Z",
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "The draft covers a lot of this ground already:\r\n\r\n```\r\n* the CONNECT stream is closed, either cleanly or abruptly, on either side; or\r\n* a CLOSE_WEBTRANSPORT_SESSION capsule is either sent or received.\r\n\r\nUpon learning that the session has been terminated, the endpoint MUST reset the\r\nsend side and abort reading on the receive side of all of the streams\r\nassociated with the session (see Section 2.4 of {{!RFC9000}}) using the\r\nH3_WEBTRANSPORT_SESSION_GONE error code; it MUST NOT send any new datagrams or\r\nopen any new streams.\r\n```\r\n\r\nI think the third bullet is covered by the new text:\r\n\r\n```\r\nAn endpoint that sends a CLOSE_WEBTRANSPORT_SESSION capsule MUST immediately\r\nsend a FIN.  The endpoint MAY send a STOP_SENDING to indicate it is no longer\r\nreading from the CONNECT stream.  The recipient MUST close the stream upon\r\nreceiving a FIN.  If any additional stream data is received on the CONNECT\r\nstream after receiving a CLOSE_WEBTRANSPORT_SESSION capsule, the stream MUST be\r\nreset with code H3_MESSAGE_ERROR.\r\n```\r\n\r\nIs `either cleanly or abruptly` too vague with respect to FIN, RST_STREAM or STOP_SENDING?",
          "createdAt": "2023-03-13T22:39:41Z",
          "updatedAt": "2023-03-13T22:39:41Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed during editor's meeting, action item is with @vasilvv to check if anything still needs to be done",
          "createdAt": "2023-04-18T22:19:41Z",
          "updatedAt": "2023-04-18T22:19:41Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "I_kwDOCvK98s5gOhCN",
      "title": "Priorities and Pooling",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/102",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "afrind"
      ],
      "labels": [
        "ietf-116",
        "has pull request"
      ],
      "body": "I made this comment on a PR related to the Warp draft for moq: https://github.com/kixelated/warp-draft/pull/98\r\n\r\nHow are streams across different WebTransport sessions prioritized? The WebTransport CONNECT request can have an HTTP Priority header -- one logical interpretation is that all streams belonging to that session be prioritized \"under\" that top level prioritization. eg: if I have two sessions at the same urgency and incremental on, session A has 3 streams and session B has 1, then I might expect the scheduler to round-robin at the session level (rather than the QUIC stream level), splitting the bandwidth 50/50 between A and B. Is that correct?  For WebTransport over H2, that is the most natural (or only) interpretation.",
      "createdAt": "2023-03-08T00:16:38Z",
      "updatedAt": "2023-07-18T22:10:55Z",
      "closedAt": "2023-07-18T22:10:55Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's discuss at 116. This could be a new feature in the drafts or it could be tackled by a future extension.",
          "createdAt": "2023-03-08T00:20:03Z",
          "updatedAt": "2023-03-08T00:20:03Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, RFC 9218 sort of recommends sharing already for conventional CONNECT; https://www.rfc-editor.org/rfc/rfc9218.html#name-scheduling-and-the-connect-\r\n\r\nI keep hearing that people want strict ordering guarantees among streams. Are you saying that you'd want a fair share of bandwidth but strict ordering inside that fair share?",
          "createdAt": "2023-03-08T01:03:46Z",
          "updatedAt": "2023-03-08T01:03:46Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "> fair share of bandwidth but strict ordering inside that fair share\r\n\r\nI think I want to apply the HTTP prioritization per WT session (so one session could entirely block another, if they have different urgency, eg) but additional ability to prioritize streams within that session, which could be strict ordering, incremental or some combination.",
          "createdAt": "2023-03-13T22:32:23Z",
          "updatedAt": "2023-03-13T22:32:23Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed the following at IETF 116\r\n\r\nOption 1: Nothing, you get what you get and don\u2019t throw a fit\r\nOption 2: Streams are prioritized globally, be careful what you pool\r\nOption 3: WebTransport sessions are round robin, any stream prioritization is scoped within a session \r\n\tWhat about HTTP request streams?\r\nOption 4: WebTransport sessions and HTTP request streams are prioritized by Priority header, any WebTransport stream prioritization is scoped within a session\r\n\r\nThe sense I got from the room was that folks preferred Option 4.",
          "createdAt": "2023-03-31T01:49:36Z",
          "updatedAt": "2023-03-31T01:49:36Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting. Plan is to have @afrind write up a PR for option 4 and we'll confirm consensus on the list before merging.",
          "createdAt": "2023-04-18T22:26:40Z",
          "updatedAt": "2023-04-18T22:26:40Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "I_kwDOCvK98s5iJb-G",
      "title": "Please use RFC 9000 style message formats instead of misleading octet graphs",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/107",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [
        "ekinnear"
      ],
      "labels": [
        "ready for PR",
        "editorial"
      ],
      "body": "I just got mislead by the way the webtransport draft is written. It includes drawings like:\r\n\r\n~~~\r\n     0                   1                   2                   3\r\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\r\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n     |                           0x54 (i)                          ...\r\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\r\n~~~\r\n\r\nLooking at the graphic, you get the impression that the first byte of the unidir stream is 0x54. Of course, that's incorrect, the varint is encoded on two bytes, 0x4054. But the confusion would not happen if the text used RFC 9000 style notations, as in:\r\n\r\n~~~\r\nunidir-stream {\r\n    signal-value(i),\r\n    session-id(i),\r\n    stream-body(...)\r\n}\r\n~~~\r\n\r\nIt would be nce to fix that!\r\n\r\nBy the way, there is a nice interop test. What if the session ID was encoded as 0x8000000054 ?",
      "createdAt": "2023-03-29T22:46:49Z",
      "updatedAt": "2023-04-18T22:38:48Z",
      "closedAt": "2023-04-18T22:38:48Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe @LPardue already fixed that in #103, we just need to merge that.",
          "createdAt": "2023-03-30T00:49:34Z",
          "updatedAt": "2023-03-30T00:49:34Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed during editor's meeting, #103 didn't fix all of this issue, keeping open for now",
          "createdAt": "2023-04-18T22:11:13Z",
          "updatedAt": "2023-04-18T22:11:13Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "PR open, planning to merge, happy to take additional editorial PRs after this if we should tweak the format",
          "createdAt": "2023-04-18T22:38:11Z",
          "updatedAt": "2023-04-18T22:38:11Z"
        }
      ]
    },
    {
      "number": 108,
      "id": "I_kwDOCvK98s5iZNq-",
      "title": "MAX_WEBTRANSPORT_SESSIONS or WEBTRANSPORT_MAX_SESSIONS?",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/108",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "ekinnear"
      ],
      "labels": [
        "editorial"
      ],
      "body": "The draft uses both but I presume they refer to the same thing, so lets pick one.",
      "createdAt": "2023-04-02T02:21:17Z",
      "updatedAt": "2023-04-03T07:37:51Z",
      "closedAt": "2023-04-03T07:37:51Z",
      "comments": [
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, left over from a previous change, I believe. `WEBTRANSPORT_*` is the correct form, can update to match. ",
          "createdAt": "2023-04-02T02:29:24Z",
          "updatedAt": "2023-04-02T02:29:24Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep sgtm",
          "createdAt": "2023-04-02T02:55:22Z",
          "updatedAt": "2023-04-02T02:55:22Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "I_kwDOCvK98s5i6M6B",
      "title": "Datagram encoding is a bit unspecified.",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/110",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [
        "ekinnear"
      ],
      "labels": [
        "ready for PR",
        "editorial"
      ],
      "body": "I have read the discussion in issue #54, and I agree with its conclusion that sending a datagram over the WT API should be about the same as sending a datagram over QUIC -- no subcontext needed or anything like that. But! The protocol overview says that _\"A datagram can be sent using HTTP Datagrams [HTTP-DATAGRAM].\"_ Cool, but RFC 9297 says : _When used with HTTP/3, the Datagram Data field of QUIC DATAGRAM frames uses the following format:_\r\n~~~\r\nHTTP/3 Datagram {\r\n  Quarter Stream ID (i),\r\n  HTTP Datagram Payload (..),\r\n}\r\n~~~\r\nAnd then it goes on specifying that the \"Quarter Stream ID\" is defied by _\"the value of the client-initiated bidirectional stream that this datagram is associated with divided by four.\"_ Fine too. I assume that this client-initiated bidirectional stream is the CONNECT stream. But when I look at section 4.4, I only find \"_Datagrams can be sent using HTTP Datagrams.  The WebTransport datagram payload is sent unmodified in the \"HTTP Datagram Payload_\" field of an HTTP Datagram.\" There is no mention anywhere of a quarter stream ID.\r\n\r\nMaybe it goes without saying, but actually saying it would avoid implementers scratching their head...\r\n\r\n\r\n\r\n\r\n \r\n",
      "createdAt": "2023-04-08T07:01:52Z",
      "updatedAt": "2023-05-02T22:28:11Z",
      "closedAt": "2023-05-02T22:28:11Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "WebTransport could benefit from some clarifying text like we added for [CONNECT-UDP](https://www.rfc-editor.org/rfc/rfc9298#section-5):\r\n> When HTTP Datagrams (see [Section 2](https://www.rfc-editor.org/rfc/rfc9297#section-2) of [[HTTP-DGRAM](https://www.rfc-editor.org/rfc/rfc9298#RFC9297)]) are associated with UDP Proxying request streams, the HTTP Datagram Payload field has the format defined in [Figure 7](https://www.rfc-editor.org/rfc/rfc9298#dgram-format), using notation from [Section 1.3](https://www.rfc-editor.org/rfc/rfc9000#section-1.3) of [[QUIC](https://www.rfc-editor.org/rfc/rfc9298#RFC9000)]. Note that when HTTP Datagrams are encoded using QUIC DATAGRAM frames [[QUIC-DGRAM](https://www.rfc-editor.org/rfc/rfc9298#RFC9221)], the Context ID field defined below directly follows the Quarter Stream ID field, which is at the start of the QUIC DATAGRAM frame payload; see [Section 2.1](https://www.rfc-editor.org/rfc/rfc9297#section-2.1) of [[HTTP-DGRAM](https://www.rfc-editor.org/rfc/rfc9298#RFC9297)].\r\n> ```\r\n> UDP Proxying HTTP Datagram Payload {\r\n>   Context ID (i),\r\n>   UDP Proxying Payload (..),\r\n> }\r\n> ```\r\n> [Figure 7](https://www.rfc-editor.org/rfc/rfc9298#figure-7): [UDP Proxying HTTP Datagram Format](https://www.rfc-editor.org/rfc/rfc9298#name-udp-proxying-http-datagram-)",
          "createdAt": "2023-04-10T18:18:05Z",
          "updatedAt": "2023-04-10T18:18:05Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "I_kwDOCvK98s5jBOSa",
      "title": "Section 2: Aspects not covered in the protocol overview",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/111",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "aboba"
      ],
      "labels": [
        "editorial",
        "has pull request"
      ],
      "body": "A discussion on the MoQ list has highlighted widely held misunderstandings about the WebTransport architecture.  Lucas Pardue provides a clarifying post here: \r\nhttps://mailarchive.ietf.org/arch/msg/moq/yOnZu3d5mDZGcV1mBODJ2-MTeko/\r\n\r\nSince the misunderstandings that Lucas debunks are widely held (I have heard them repeated by at least 4 developers), it seems like they should be covered in Section 2. \r\n\r\n",
      "createdAt": "2023-04-10T19:46:21Z",
      "updatedAt": "2024-05-14T23:03:12Z",
      "closedAt": "2024-05-14T23:03:12Z",
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Pointer to a reference implementation to demonstrate that implementing WebTransport isn't a monumental task. Web Platform Tests server (600 lines in Python): \r\nhttps://github.com/web-platform-tests/wpt/blob/master/tools/webtransport/h3/webtransport_h3_server.py",
          "createdAt": "2023-04-18T22:33:08Z",
          "updatedAt": "2023-05-03T21:38:09Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in editor's meeting: @aboba to start with Lucas's text in a PR and we can iterate during review.",
          "createdAt": "2023-11-28T23:29:09Z",
          "updatedAt": "2023-11-28T23:29:09Z"
        }
      ]
    },
    {
      "number": 112,
      "id": "I_kwDOCvK98s5jQwSf",
      "title": "What if capsule negotiation fails?",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/112",
      "state": "CLOSED",
      "author": "huitema",
      "authorAssociation": "NONE",
      "assignees": [
        "afrind"
      ],
      "labels": [
        "ready for PR",
        "editorial"
      ],
      "body": "Per RFC 9297: _\"Endpoints indicate that the Capsule Protocol is in use on a data stream by sending a Capsule-Protocol header field with a true value.\"_ What happens if a client does not include the Capsule-Protocol header field in a Connect request, or if it sets the value to false? Similarly, what if the server does not include the value or set it to false?\r\n\r\nWebtransport only uses the Capsule protocol to send the `CLOSE_WEBTRANSPORT_SESSION` capsule. If the capsule protocol is not negotiated, what are the options? Should the node just close the connect stream in case of \"no error\"? Should they use \"reset\" with an appropriate error code?\r\n\r\nShouldn't the behavior be specified in the draft?",
      "createdAt": "2023-04-12T22:12:56Z",
      "updatedAt": "2023-05-02T22:06:53Z",
      "closedAt": "2023-05-02T22:06:53Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree the spec would benefit from being more explicit here. I would suggest if an endpoint does not send the correct signal to enable the Capsule Protocol on the data stream (I.e. the request stream) then the receiver fails closed. In other words an extended CONNECT request that doesn't include `capsule-protocol: ?1` must be rejected with an error status code. And a sucessful response to an extended CONNECT request, where the response does not include the field, must cause the stream to be terminated.",
          "createdAt": "2023-04-12T22:21:28Z",
          "updatedAt": "2023-04-18T22:20:35Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That wasn't the intent of the header. You can use WebTransport (and CONNECT-UDP for that matter) without setting the `capsule-protocol` header. For WebTransport, the capsule protocol is in use as soon as there's a 2xx response",
          "createdAt": "2023-04-12T22:24:58Z",
          "updatedAt": "2023-04-12T22:24:58Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Wait up. So I agree the header isn't mandatory for capsule protocol. \r\n\r\nI think the confusion here is that the spec says the `webtransport` token enables the capsule protocol but that can be overlooked. The spec could be a bit more clear what the implications of this all are. Possibly also specifically saying that the capsule-protocol header is not in play.\r\n\r\nIf my updated understanding applies, you can't get into a logical mismatch as I described earlier, so my earlier suggestion is moot.",
          "createdAt": "2023-04-12T22:31:45Z",
          "updatedAt": "2023-04-12T22:35:45Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah maybe we just need to say explicitly that in WebTransport a 2xx response is what starts the capsule protocol.",
          "createdAt": "2023-04-12T22:40:00Z",
          "updatedAt": "2023-04-12T22:40:00Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To Christian's point though, we need to make it clear that a server that sees `:protocol: webtransport` and `capsule-protocol: ?0`* shouldn't generate an error because the header is not used.\r\n\r\n* https://httpwg.org/http-extensions/draft-ietf-httpbis-sfbis.html#name-parsing-a-boolean",
          "createdAt": "2023-04-12T22:45:45Z",
          "updatedAt": "2023-04-18T22:21:22Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "SGTM",
          "createdAt": "2023-04-12T22:46:58Z",
          "updatedAt": "2023-04-12T22:46:58Z"
        }
      ]
    },
    {
      "number": 116,
      "id": "I_kwDOCvK98s5joiLR",
      "title": "Keying material exporters",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/116",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "vasilvv"
      ],
      "labels": [
        "has pull request",
        "ietf-117"
      ],
      "body": "Per w3c/webtransport#411, there is some interest in using [key exporters](https://datatracker.ietf.org/doc/rfc5705/) with WebTransport.  While in theory that could be purely an API concept, given that we do things like pooling (and given that we should register exporter labels with IANA), it probably would make sense to define the exact mechanism in this document.\r\n\r\nI propose the following.  A WebTransport exporter takes `(label, context, length)` as input, similar to the TLS ones.  To derive a WebTransport exporter, derive a TLS key exporter with label `EXPORTER-WebTransport` and the context being the following:\r\n\r\n```\r\nWebTransport Exporter Context {\r\n  WebTransport Session ID (64),\r\n  WebTransport Application-Supplied Exporter Label Length (32),\r\n  WebTransport Application-Supplied Exporter Label (..),\r\n  WebTransport Application-Supplied Exporter Context (..)\r\n}\r\n```\r\n\r\nThis should help avoiding collisions with non-WebTransport exporters, as well as WebTransport exporters from different pooled sessions.  What do people think?",
      "createdAt": "2023-04-17T16:34:44Z",
      "updatedAt": "2024-05-14T22:54:07Z",
      "closedAt": "2024-05-14T22:54:07Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "SGTM",
          "createdAt": "2023-04-17T21:01:32Z",
          "updatedAt": "2023-04-17T21:01:32Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting. We'd like to get @martinthomson 's opinion before writing a PR.",
          "createdAt": "2023-04-18T22:41:36Z",
          "updatedAt": "2023-04-18T22:41:36Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You don't have a field for the context length, which isn't technically incorrect, but I'd prefer not to rely on the TLS layer having a length field of its own so that you can delineate the context field.\r\n\r\nFixed-size lengths are good here as you avoid canonicalization challenges with varints, so that is good.\r\n\r\nThe similarities with TLS ensure that you can switch out QUIC for WebTransport, which seems to be a goal here that is worth explaining.  Otherwise, the \"label\" and \"context\" separation only exists for that reason.\r\n\r\nOverall, this is pretty much what we discussed on the referenced issue.  I'm not seeing a ton of urgency around this feature, but what @vasilvv describes is a good approach.",
          "createdAt": "2023-04-24T05:10:00Z",
          "updatedAt": "2023-04-24T05:10:00Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting, some folks think we should remove this and punt to an extension, while others prefer to keep it. Let's discuss at 117.",
          "createdAt": "2023-06-27T22:22:15Z",
          "updatedAt": "2023-06-27T22:22:15Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at 117. @marten-seemann is supportive and has a use case but multiple people said this wasn't necessary. Agreement in the room that this would be implemented only in browsers due to the need for a security boundary between a layer that has access to the TLS keying material (browser) and a layer that does not (JavaScript). Right now there is no consensus to add this. @marten-seemann will take an action item to file an issue at the W3C to try to gather more use cases there. If the W3C comes back to us with a strong need for this we will revisit.",
          "createdAt": "2023-07-27T21:01:00Z",
          "updatedAt": "2023-07-27T21:01:00Z"
        },
        {
          "author": "Neustradamus",
          "authorAssociation": "NONE",
          "body": "To follow.",
          "createdAt": "2023-07-30T03:17:17Z",
          "updatedAt": "2023-07-30T03:17:17Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting. @marten-seemann have you found more supporters for this? If not we'll close this as it can always be added as an extension later.",
          "createdAt": "2023-09-19T22:31:16Z",
          "updatedAt": "2023-09-19T22:31:16Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: closing due to lack of interest",
          "createdAt": "2023-10-17T22:16:41Z",
          "updatedAt": "2023-10-17T22:16:41Z"
        },
        {
          "author": "Neustradamus",
          "authorAssociation": "NONE",
          "body": "@vasilvv, @martinthomson, @DavidSchinazi, @ietf-wg-webtrans, @w3c: A bad news...",
          "createdAt": "2023-10-17T23:01:45Z",
          "updatedAt": "2023-10-17T23:01:45Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Reopening, since there was some display of web developer interest recently.",
          "createdAt": "2024-02-13T15:25:48Z",
          "updatedAt": "2024-02-13T15:25:48Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "I_kwDOCvK98s5ju5MS",
      "title": "Reserved HTTP/3 error codes for Webtransport have a name, for what purpose?",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/117",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "LPardue"
      ],
      "labels": [
        "has pull request"
      ],
      "body": "By my understanding, we are reserving a range of error codes for WebTransport applications to use. At the time of writing, the IANA considerations says to reserve these as `H3_WEBTRANSPORT_APPLICATION_<MIN>..H3_WEBTRANSPORT_APPLICATION_<MAX>` (where <MIN> and <MAX> are a little in flux due to the extension of the space in https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/115.\r\n\r\nWhat isn't clear to me is who the intended audience of those error code names are? Applications on top of WebTransport are probably going to want to use their own semantic names for the errors (e.g. MOQ_NO_ERROR, MOQ_AWFUL_THING) or whatever. They could do that by saying something like \r\n\r\n> when condition X happens, close the WebTransport session with MOQ_AWFUL_THING ((WebTransport error code 1)|. \r\n\r\nOr is the intention that they will use a form like:\r\n\r\n> > when condition X happens, close the WebTransport session with MOQ_AWFUL_THING ((H3_WEBTRANSPORT_APPLICATION_000001). \r\n\r\nWhatever the preference, we should probably start thinking about how to explain to people consistent sytyling for using WebTransport. So this is possibly or more general question.",
      "createdAt": "2023-04-18T14:18:31Z",
      "updatedAt": "2023-05-16T22:36:25Z",
      "closedAt": "2023-05-16T22:36:25Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "The IANA registry has a mandatory `Name` column, I think the audience is anyone reading that registry?",
          "createdAt": "2023-04-18T22:43:31Z",
          "updatedAt": "2023-04-18T22:43:31Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Registries are to avoid collisions, not to help use the protocol . The current names are pretty terrible to use, they encode the value in the name, the value is already obvious.  Furthermore, we have a layer indirection because applications using WebTransport will benefit from labelling error codes with names that make sense to humans. \r\n\r\nWe already have a similar situation with QUIC's CRYPTO_ERROR, which reserves a range with a single name and requires people to map the TLS error code space into QUIC's. Those TLS errors also have their own nice labels defined elsewhere.\r\n\r\nHow about we just reserve the single WEBTRANSPORT_APP_ERROR name? Then we can write applications on top of WebTransport by saying \r\n\r\n> when condition X happens, close the WebTransport session with MOQ_AWFUL_THING (WEBTRANSPORT_APP_ERROR with a value 1)\r\n\r\n\r\n",
          "createdAt": "2023-04-18T23:04:32Z",
          "updatedAt": "2023-04-18T23:05:13Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "(chair hat off) I like the idea of a single name for the range to match CRYPTO_ERROR.\r\n\r\nFWIW, our stack will print out `CRYPTO_ERROR(certificate_expired)` in the debug logs, so we can do something similar for WebTransport errors.",
          "createdAt": "2023-04-18T23:09:30Z",
          "updatedAt": "2023-04-18T23:09:30Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah if you're aware of the application running over WebTransport (likely) affordance in debug logs would be neat too, \r\n\r\nNote that we could simplify things with a single registration and punt on the name bikeshed. But FWIW, since this is an  app error, inside WebTransport removing the `H3_` prefix makes the intention a little clearer. Whether that should extend to the other codes registeres in this document I have not thought through. ",
          "createdAt": "2023-04-18T23:17:51Z",
          "updatedAt": "2023-04-18T23:17:51Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting. No strong opinions but everyone seemed fine with switching to a single name for the whole range.\r\n@LPardue can you write a PR?",
          "createdAt": "2023-05-02T22:21:55Z",
          "updatedAt": "2023-05-02T22:21:55Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yep by the 3nd of the week",
          "createdAt": "2023-05-02T22:40:55Z",
          "updatedAt": "2023-05-02T22:40:55Z"
        }
      ]
    },
    {
      "number": 119,
      "id": "I_kwDOCvK98s5jxpuV",
      "title": "Add guidance about the intended use of capsules",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/119",
      "state": "CLOSED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "afrind"
      ],
      "labels": [
        "ready for PR"
      ],
      "body": "Even though the CONNECT stream uses capsules and capsules are extensible, application protocols written on top of WebTransport are not intended to define their own capsules to send in this context.  The w3c API for webtrans doesn't have a mechanism for sending capsules as they are intended to be a channel for the user-agent rather than the application.  We should add some guidance to this effect.",
      "createdAt": "2023-04-18T23:35:35Z",
      "updatedAt": "2023-08-08T22:09:22Z",
      "closedAt": "2023-08-08T22:09:22Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I might go as far to suggest that we RECOMMEND not doing it along with the guidance. If people need more capsules, they should extend WebTransport not via the application.",
          "createdAt": "2023-04-18T23:42:23Z",
          "updatedAt": "2023-04-18T23:42:23Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting. Sounds reasonable, let's see a PR",
          "createdAt": "2023-05-02T22:23:12Z",
          "updatedAt": "2023-05-02T22:23:12Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting. Plan is to not use 2119 keywords and instead write prose.",
          "createdAt": "2023-06-27T22:25:08Z",
          "updatedAt": "2023-06-27T22:25:08Z"
        }
      ]
    },
    {
      "number": 125,
      "id": "I_kwDOCvK98s5msfUL",
      "title": "Unify on a single setting to indicate support for WebTransport?",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/125",
      "state": "CLOSED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ekinnear"
      ],
      "labels": [],
      "body": "This came up in an editor's call when keeping settings in sync. Several folks thought this was already unified, so filing an issue to cover cleaning this up.\r\n\r\nToday, HTTP/2 uses `SETTINGS_WEBTRANSPORT_MAX_SESSIONS` instead of `SETTINGS_ENABLE_WEBTRANSPORT` to indicate support for WebTransport and requires both the client and the server to send the setting with a non-zero value.\r\n\r\nHTTP/3 still uses _both_ `SETTINGS_WEBTRANSPORT_MAX_SESSIONS` and `SETTINGS_ENABLE_WEBTRANSPORT`, and at the time we said it was in part due to the fact that \"h3 requires `SETTINGS_ENABLE_WEBTRANSPORT` because it changes the format of server-initiated bidi streams\" ([context](https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http2/issues/73#issuecomment-1464720983)).\r\n\r\nHowever, we've said that `SETTINGS_WEBTRANSPORT_MAX_SESSIONS` > 0 is semantically equivalent to `SETTINGS_ENABLE_WEBTRANSPORT`.\r\n\r\nIf that's the case, then it should be okay to replace that setting with the one by a different name, with otherwise identical language. It's a little bit odd to send `SETTINGS_WEBTRANSPORT_MAX_SESSIONS` from an endpoint that isn't able to have sessions opened to it, but it seems like completely eliminating a setting reduces complexity and the actual string spelling of the setting name isn't that important. That would unify both HTTP/2 and HTTP/3 on a single way to say \"yes, I speak WebTransport and you can speak WebTransport to me\".\r\n\r\nConcretely, the proposal is to replace uses of\r\n`SETTINGS_ENABLE_WEBTRANSPORT` = 1\r\nwith\r\n`SETTINGS_WEBTRANSPORT_MAX_SESSIONS` = 1\r\nwith no other change in meaning or semantics.",
      "createdAt": "2023-05-23T23:35:19Z",
      "updatedAt": "2023-06-13T22:28:06Z",
      "closedAt": "2023-06-13T22:28:06Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This seems like a good change. \r\n\r\n> Concretely, the proposal is to replace uses of\r\n> SETTINGS_ENABLE_WEBTRANSPORT = 1\r\n> with\r\n> SETTINGS_WEBTRANSPORT_MAX_SESSIONS = 1\r\n> with no other change in meaning or semantics.\r\n\r\nI think practically this substitution is more like moving to \"greater than 0\", to marry up with how the HTTP/2 spec does it. ",
          "createdAt": "2023-05-24T01:07:14Z",
          "updatedAt": "2023-05-24T01:07:14Z"
        }
      ]
    },
    {
      "number": 126,
      "id": "I_kwDOCvK98s5oG5MD",
      "title": "Clarify the GOAWAY semantics for WebTransport session",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/126",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "vasilvv"
      ],
      "labels": [
        "ready for PR"
      ],
      "body": "In #76, we clarified that GOAWAY does not stop you from opening new streams or sending more datagrams, but we never indicated whether it has any other semantic effect.  My interpretation (that is at least in part [reflected in the current W3C API](https://w3c.github.io/webtransport/#session-draining)) is that a GOAWAY should be treated as semantically equivalent to DRAIN_WEBTRANSPORT_SESSION on every WebTransport session: it does not actually affect the ability to use those sessions, but the client should attempt to gracefully terminate ASAP.  Does this sound reasonable?",
      "createdAt": "2023-06-07T20:35:14Z",
      "updatedAt": "2023-06-28T15:58:22Z",
      "closedAt": "2023-06-28T15:58:22Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "+1. My initial read of this was that GOAWAY didn't apply at all to existing WebTransport sessions and therefore shouldn't be forwarded to the W3C layer. That interpretation contradicts the W3C spec though. We should definitely clarify the text. Aligning with the current W3C spec (say that receipt of GOAWAY is treated the same as receipt of DRAIN_WEBTRANSPORT_SESSION on all sessions) sounds reasonable to me.",
          "createdAt": "2023-06-07T20:43:26Z",
          "updatedAt": "2023-06-07T20:43:26Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting. Consensus in the room to clarify that GOAWAY implies receipt of DRAIN_WEBTRANSPORT_SESSION on every WebTransport session.",
          "createdAt": "2023-06-27T22:29:41Z",
          "updatedAt": "2023-06-27T22:29:41Z"
        }
      ]
    },
    {
      "number": 130,
      "id": "I_kwDOCvK98s5opl44",
      "title": "Clarify long term plans for clients to signal support for WebTransport",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/130",
      "state": "CLOSED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ekinnear"
      ],
      "labels": [
        "ietf-117"
      ],
      "body": "> Long term, once this has shipped as RFC and all browsers have dropped support for pre-RFC drafts, is the plan to have clients send SETTINGS_WEBTRANSPORT_MAX_SESSIONS forever or to stop sending it? If the goal is to only do this during the draft period, we should have \"to be removed by RFC editor\" notes explaining that\r\n\r\n_Originally posted by @DavidSchinazi in https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/129#issuecomment-1585130081_\r\n            ",
      "createdAt": "2023-06-13T22:22:13Z",
      "updatedAt": "2023-10-17T22:19:21Z",
      "closedAt": "2023-10-17T22:19:21Z",
      "comments": [
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Why not use upgrade tokens and update extended connect to support negotiation? \r\nChanging semantics of HTTP so that the server can initiate bidirectional streams, that needs to be in a hop-by-hop manner, so a SETTING is needed\r\n\r\nProposal: \r\nServer sends SETTINGS_WEBTRANSPORT_MAX_SESSIONS, client doesn't send any settings, but it uses extended connect to ask to use the WebTransport that the server said it supported. If we change the version later, we use a new upgrade token and use a different setting to indicate support, letting the client still pick.",
          "createdAt": "2023-06-27T22:38:59Z",
          "updatedAt": "2023-06-27T22:38:59Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this proposal",
          "createdAt": "2023-06-27T22:47:44Z",
          "updatedAt": "2023-06-27T22:47:44Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "- Don't use the same frame identifier for different frame layouts (even across WebTransport versions), and you don't need a client setting to let you read those formats (since you can't wait for settings to arrive anymore and streams may arrive before the connect request)",
          "createdAt": "2023-06-27T22:49:31Z",
          "updatedAt": "2023-06-27T22:49:31Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting. Let's discuss at 117. @ekinnear to write slide",
          "createdAt": "2023-06-27T22:52:50Z",
          "updatedAt": "2023-06-27T22:53:11Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at 117. This was quite confused. We see two proposals:\r\n* both client and server send SETTINGS_WEBTRANSPORT_MAX_SESSIONS and then both compute the maximum of the intersection of both sets to pick the version in use\r\n* only server sends SETTINGS_WEBTRANSPORT_MAX_SESSIONS and the clients sends the version in the upgrade token (i.e., if we change the protocol we will change the upgrade token)\r\n\r\nPlease keep discussing on this issue",
          "createdAt": "2023-07-27T21:12:26Z",
          "updatedAt": "2023-07-27T21:12:26Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in editor's meeting: \r\n\r\nSETTINGS\r\n- You cannot mix versions, there is only one version that can be used on the HTTP connection\r\n\r\nServer advertises, client chooses\r\n- This is unambiguous after the CONNECT comes in, but there may be WT streams that show up ahead of the connect and, while you still have to pend them until you get the session ID, it would be nice to at least know how to parse that frame. Instead, you have to wait until you know what version you are using.\r\n- This also opens the door to using multiple versions on the same HTTP connection, which is very complicated and not particularly useful.\r\n\r\nHTTP syntax is extended by client-initiated bidirectional streams, which is why this matters more than it would otherwise. This raises the question if we should have included a \"fake\" very high length for the \"frame that runs to the end of the stream\" so that a parser that's doing the wrong thing won't see the session ID and try to parse out that number of bytes.\r\n\r\nConclusion: Leave this as-is.",
          "createdAt": "2023-08-08T22:32:23Z",
          "updatedAt": "2023-08-08T22:32:23Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting. Does anyone object to leaving this as-is and closing this issue?",
          "createdAt": "2023-09-19T22:33:34Z",
          "updatedAt": "2023-09-19T22:33:34Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: closing due to no objections",
          "createdAt": "2023-10-17T22:19:21Z",
          "updatedAt": "2023-10-17T22:19:21Z"
        }
      ]
    },
    {
      "number": 135,
      "id": "I_kwDOCvK98s5tzdXs",
      "title": "Should clients wait for SETTINGS?",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/135",
      "state": "CLOSED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ekinnear"
      ],
      "labels": [
        "has pull request"
      ],
      "body": "HTTP syntax is extended by client-initiated bidirectional streams, which is why the settings for enabling WebTransport matter more than it would otherwise. This raises the question if we should have included a \"fake\" very high length for the \"frame that runs to the end of the stream\" so that a parser that's doing the wrong thing won't see the session ID and try to parse out that number of bytes.\r\n\r\nThe question is if that would matter? Would it help? Is it worth the cost (9 bytes per stream)?\r\n\r\nThe scenario: \r\n1. Client tries to do WT, thinking that the server does it, but it does not. \r\n2. Server sees a frame of a type that it doesn't recognize, so tries to read the length to skip that frame.\r\n3. The length is actually the WT Session ID, so now the server reads that far through the byte stream and attempts to parse the next bytes as the beginning of an HTTP/3 frame. \r\n4. You now have the ability to write whatever HTTP/3 frames you want to the server, but the client has no idea what you're saying. \r\n\r\n- Hopefully, the client doesn't allow you to talk WT to a server that doesn't actually talk WT\r\n- If you had a client that was either malicious or buggy, you could try to send these frames\r\n\r\nImpact: \r\n- What sort of information could you get by sending custom HTTP/3 frames to the server? \r\n- This would be a CORS bypass in a browser\r\n- Allows the attacker to access secrets in the dynamic table\r\n     - If the connection is shared with other HTTP requests, that's especially concerning\r\n     - You can put indices that will extract headers and then talk to an echo endpoint on the same server that will reflect them back to you\r\n    - You can also use these headers, for example authorization\r\n\r\nWays to fix this: \r\na. Send a sentinel frame (say, empty SETTINGS, 4 and 0) that means nothing ahead of the WT frames. WT servers will know and discard. Other implementations will fail and tear down the whole connection. \r\nb. Considered using max length in the WT frame, but the failure mode is less good (if someone tries to allocate that much memory, we have issues, plus it's not great to have things stall).\r\nc. We should write down that client MUST wait until settings (this exists, but we should add it to security considerations)\r\n\r\nOverall:\r\nDon't offer a WT API that allows people to write arbitrary bytes to various streams.",
      "createdAt": "2023-08-08T22:49:10Z",
      "updatedAt": "2024-03-04T23:57:36Z",
      "closedAt": "2024-03-04T23:57:36Z",
      "comments": [
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in editor's meeting: \r\n\r\n(c) we should definitely do. \r\n\r\nWe should discuss if we want to do (a).",
          "createdAt": "2023-08-08T22:49:28Z",
          "updatedAt": "2023-08-08T22:49:28Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting. Consensus in (small, limited) room was to add some text saying clients MUST wait for settings and explaining why, and that's it. @vasilvv can you write a PR?",
          "createdAt": "2023-09-19T22:39:17Z",
          "updatedAt": "2023-09-19T22:39:17Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "adding guidance for the client sounds good",
          "createdAt": "2023-09-20T00:48:59Z",
          "updatedAt": "2023-09-20T00:48:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in the WG session at IETF 118. Consensus in the room was to have client wait for the server's SETTINGS before sending the WebTransport request.",
          "createdAt": "2023-11-06T16:16:18Z",
          "updatedAt": "2023-11-06T16:16:18Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in editor's meeting: @vasilvv to write PR adding this to security considerations.",
          "createdAt": "2023-11-28T23:35:23Z",
          "updatedAt": "2023-11-28T23:35:23Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting. Plan is to write one PR that resolves #135, #140, #141, and #143. That PR would say:\r\n* client MUST wait for server settings\r\n* endpoints MUST send SETTINGS_H3_DATAGRAM (however servers that want to validate this MUST need to take into account the fact that the request might arrive before the client's SETTINGS)\r\n* client no longer sends the WEBTRANSPORT_MAX_SESSIONS setting\r\n* Add a \"Considerations for future versions of WebTransport\" section that explain that if a future version of WebTransport changes the syntax of the request, it'll need to change the Upgrade Token. Similarly, changes to stream formats will require changes to the Unidirectional Stream Type and Bidirectional Stream Signal Value.",
          "createdAt": "2024-01-24T00:04:24Z",
          "updatedAt": "2024-01-24T00:04:24Z"
        }
      ]
    },
    {
      "number": 136,
      "id": "I_kwDOCvK98s5xefbC",
      "title": "[hold for WGLC] Renumber codepoints",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/136",
      "state": "OPEN",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "vasilvv"
      ],
      "labels": [
        "held for wglc"
      ],
      "body": "Our current codepoints are often two-bytes or four-bytes where they could be smaller.  This matters, especially for prefixes we use for user data.  We should renumber them after WGLC, this is a bug to not forget this.",
      "createdAt": "2023-09-19T22:37:33Z",
      "updatedAt": "2023-11-28T23:37:19Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 137,
      "id": "I_kwDOCvK98s5y8VXj",
      "title": "Define a header for subprotocol negotiation",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/137",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "vasilvv"
      ],
      "labels": [
        "ietf-118"
      ],
      "body": "To be able to implement w3c/webtransport#536 (see moq-wg/moq-transport#233 for some background, but the problem here is porting applications that rely on ALPN).  Client sends a list of supported subprotocols, server responds with one of the selected.\r\n\r\nPossible syntax ideas for the client header:\r\n- sf-list of [sf-byte-sequences](https://www.rfc-editor.org/rfc/rfc8941.html#name-byte-sequences)\r\n- sf-list of [sf-strings](https://www.rfc-editor.org/rfc/rfc8941.html#name-strings)\r\n- sf-list of [sf-tokens](https://www.rfc-editor.org/rfc/rfc8941.html#name-tokens)\r\n- [RFC 7639](https://datatracker.ietf.org/doc/rfc7639/)\r\n\r\nPossible response syntax:\r\n- one byte-sequence/string/token\r\n- number indicating the index of the selected subprotocol",
      "createdAt": "2023-10-05T14:21:16Z",
      "updatedAt": "2023-12-12T23:15:27Z",
      "closedAt": "2023-12-12T23:15:27Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: editor's meeting. Proposal is to have client send ALPN header (using format from RFC 7639) (client can send multiple ALPNs if it wants to). Server then sends a single ALPN header. This would be an optional feature.\r\n\r\nThoughts?",
          "createdAt": "2023-10-17T22:26:11Z",
          "updatedAt": "2023-10-17T22:26:11Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "I think this is good functionality, mirroring what QUIC provides.\r\n\r\nMoQ currently does version negotiation itself. We could leverage the CONNECT request and the ALPN for version negotiation instead. Although we'll still need to do extension negotiation, so I'm not 100% certain if MoQ would use the ALPN, but it's still quite useful.",
          "createdAt": "2023-10-17T23:26:14Z",
          "updatedAt": "2023-10-17T23:27:11Z"
        },
        {
          "author": "enygren",
          "authorAssociation": "NONE",
          "body": "If we use ALPN we clearly need to define how these interact with the \"alpn\" SvcParam in SVCB/HTTPS DNS RRs and the defined behavior there. ",
          "createdAt": "2023-11-06T15:36:14Z",
          "updatedAt": "2023-11-06T15:36:14Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in the WG session at IETF 118. Consensus in the room was to add an ALPN-like feature to WebTransport, but to disconnect it from actual ALPN, in particular not using the ALPN IANA registry and instead build a new registry.",
          "createdAt": "2023-11-06T15:37:46Z",
          "updatedAt": "2023-11-06T15:37:46Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "And now speaking as individual contributor: I would suggest restricting this new ALPN-like construct to [tokens](https://www.rfc-editor.org/rfc/rfc9110#name-tokens) to avoid the encoding footgun that exists in ALPN.",
          "createdAt": "2023-11-06T15:40:49Z",
          "updatedAt": "2023-11-06T15:40:49Z"
        }
      ]
    },
    {
      "number": 138,
      "id": "I_kwDOCvK98s51luUO",
      "title": "Feedback from IANA",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/138",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "IANA has sent in the following feedback:\r\n\r\n> Any values that have yet to be allocated (either permanently or via the RFC 7120 early allocation policy), like the values named in sections 8.2, 8.3, 8.4, 8.5 and 8.6, should be described as \u201c1 (suggested)\u201d and \u201c2 (suggested)\u201d (or similar).\r\n>\r\n> If you have any questions, just let us know. If you'd like to talk in person, you can find us next to the RFC Editor's table from Monday through Thursday. You can also request another review at any time by contacting us at [iana@iana.org](mailto:iana@iana.org).\r\n>\r\n> For more information about IANA Considerations section requirements, please see https://www.iana.org/help/protocol-registration",
      "createdAt": "2023-11-01T17:47:13Z",
      "updatedAt": "2023-11-28T23:19:59Z",
      "closedAt": "2023-11-28T23:19:59Z",
      "comments": [
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in editor's meeting: Tracked in #136.",
          "createdAt": "2023-11-28T23:19:59Z",
          "updatedAt": "2023-11-28T23:19:59Z"
        }
      ]
    },
    {
      "number": 139,
      "id": "I_kwDOCvK98s514vde",
      "title": "clarify if Extended CONNECT can be sent before receiving the server's SETTINGs frame",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/139",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "RFC 9114, section 7.2.4.2 says:\r\n> An HTTP implementation MUST NOT send frames or requests that would be invalid based on its current understanding of the peer's settings.\r\n\r\nIt's not clear if this applies to the WebTransport Extended CONNECT request. \r\n\r\nThere seems little harm in sending the request immediately, if the server doesn't support WebTransport, it can just reject it.",
      "createdAt": "2023-11-05T14:17:26Z",
      "updatedAt": "2023-11-06T16:24:17Z",
      "closedAt": "2023-11-06T16:24:17Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The server needs to have advertised SETTINGS_ENABLE_CONNECT_PROTOCOL or else the request with `:protocol` is an unknown pseudo-header that must be treated as a malformed rquest per https://datatracker.ietf.org/doc/html/rfc9114#section-4.3-3",
          "createdAt": "2023-11-05T14:25:38Z",
          "updatedAt": "2023-11-05T14:25:45Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue I think you're right. For everyone else wondering which sentence it is:\r\n> Endpoints MUST treat a request or response that contains undefined or invalid pseudo-header fields as [malformed](https://datatracker.ietf.org/doc/html/rfc9114#malformed).",
          "createdAt": "2023-11-05T14:33:33Z",
          "updatedAt": "2023-11-05T14:33:33Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That said, since servers MUST treat malformed request as a stream error (as opposed to a connection error), then we don't really have a problem here. If the client sends the request optimistically before it's received settings, then the request will fail - and that's the same outcome as when the settings don't indicate extended connect support. Luckily we have a [keyword](https://www.rfc-editor.org/rfc/rfc6919#section-1) for such scenarios.",
          "createdAt": "2023-11-05T14:49:37Z",
          "updatedAt": "2023-11-05T14:49:37Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "H2 and H3 allow any server to close the connection if they want. You might be suprised to find that severs that see bad requests might eventually block clients that keep doing this, or that they rip down a conn3ction on the first occasion. \r\n\r\nThis could ruin the day if the connection is being pooled with non-WebTransport requests",
          "createdAt": "2023-11-05T14:54:19Z",
          "updatedAt": "2023-11-05T14:54:19Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's fine that the client has to wait for the server's SETTINGS. SETTINGS frames can be sent in 0.5-RTT data, so (in the common case) this doesn't cause any additional latency.\r\n\r\nThe important part is that SETTINGS_ENABLE_CONNECT_PROTOCOL is only sent by the server, not by the client. This means that the server doesn't need wait for the client's SETTINGS.",
          "createdAt": "2023-11-05T14:58:26Z",
          "updatedAt": "2023-11-05T15:11:22Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is the same as #135\r\n\r\nI think both the client and the server have to wait for settings, otherwise things don't work.",
          "createdAt": "2023-11-05T21:00:20Z",
          "updatedAt": "2023-11-05T21:00:20Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in the WG session at IETF 118. Consensus in the room was to have client wait for the server's SETTINGS before sending the WebTransport request. I've opened up #143 to discuss how the server should handle receiving the request before settings. I'm closing this issue, we can continue the discussion in either #135 or #143.",
          "createdAt": "2023-11-06T16:24:17Z",
          "updatedAt": "2023-11-06T16:24:17Z"
        }
      ]
    },
    {
      "number": 140,
      "id": "I_kwDOCvK98s5140AJ",
      "title": "requirement on HTTP DATAGRAMs requires servers to buffer requests",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/140",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "ekinnear"
      ],
      "labels": [
        "has pull request"
      ],
      "body": "In order to establish a WebTransport session, both client and server need to enable HTTP DATAGRAM support.\r\n\r\nThis is a problem on the server side, since SETTINGS are sent on a different stream, and the server might not have received the client's SETTINGS when it processes the Extended CONNECT request. If the server wants to verify the requirement from the draft, it will need to buffer the Extended CONNECT request until it has received the client's SETTINGS. Obviously, this is suboptimal, especially since a malicious client can delay sending of the SETTINGS.\r\n\r\nA possible solution would be to revisit our previous decision to require datagram support for WebTransport. It would then be valid to have a WebTransport session that doesn't support datagrams.",
      "createdAt": "2023-11-05T15:04:10Z",
      "updatedAt": "2024-03-04T23:57:36Z",
      "closedAt": "2024-03-04T23:57:36Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "WebTransport already requires the server to not read any data from incoming bidirectional streams until it receives settings, because WebTransport changes the syntax of those in non-backwards-compatible manner.",
          "createdAt": "2023-11-05T21:16:35Z",
          "updatedAt": "2023-11-05T21:16:35Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's not my understanding.\r\n\r\nAs soon as a server _sent_ the SETTINGS frame (containing all the extensions needed to use WebTransport), you need to be prepared to receive WebTransport streams. This shouldn't be a problem, since they start with the Signal Value (0x41), so the HTTP layer knows that it's a WebTransport stream. The WebTransport layer might need to buffer the stream if there's no session for that session ID, but there shouldn't be a situation where the HTTP layer needs to buffer anything.",
          "createdAt": "2023-11-06T07:40:04Z",
          "updatedAt": "2023-11-06T07:40:04Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "Is this specific to datagrams? Wouldn't a pedantic WebTransport server also have to buffer the CONNECT and any streams until `SETTINGS_WEBTRANSPORT_MAX_SESSIONS` has been verified?\r\n\r\nI agree that the race between SETTINGS and CONNECT is strange. The receipt of a CONNECT request with :protocol WebTransport implies that the client has sent the associated SETTINGS. But I think the draft is right:\r\n\r\n> Similarly, the server MUST NOT process any incoming WebTransport requests until the client settings have been received, as the client may be using a version of the WebTransport extension that is different from the one used by the server.\r\n\r\nThis behavior is inevitable if the any SETTINGS changes the encoding/behavior of the CONNECT request. Until then, a smart server could defer verifying the SETTINGS frame but there's really no point.",
          "createdAt": "2023-11-06T08:16:24Z",
          "updatedAt": "2023-11-06T08:17:14Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Is this specific to datagrams? Wouldn't a pedantic WebTransport server also have to buffer the CONNECT and any streams until `SETTINGS_WEBTRANSPORT_MAX_SESSIONS` has been verified?\r\n\r\nRight, that's why I opened #141. I'd like to get to a state where the server doesn't need to wait for SETTINGS.\r\n\r\n> > Similarly, the server MUST NOT process any incoming WebTransport requests until the client settings have been received, as the client may be using a version of the WebTransport extension that is different from the one used by the server.\r\n> \r\n> This behavior is inevitable if the any SETTINGS changes the encoding/behavior of the CONNECT request. Until then, a smart server could defer verifying the SETTINGS frame but there's really no point.\r\n\r\nIt's my understanding that the client's SETTINGS don't change the meaning of CONNECT. It's the _server's_ SETTINGS that enable Extended Connect.",
          "createdAt": "2023-11-06T08:44:19Z",
          "updatedAt": "2023-11-06T08:44:19Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: we didn't discuss this specific issue in the WG session at IETF 118, but see related issues #135, #141, and #143.",
          "createdAt": "2023-11-06T17:07:47Z",
          "updatedAt": "2023-11-06T17:07:47Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting. Plan is to write one PR that resolves #135, #140, #141, and #143. That PR would say:\r\n* client MUST wait for server settings\r\n* endpoints MUST send SETTINGS_H3_DATAGRAM (however servers that want to validate this MUST need to take into account the fact that the request might arrive before the client's SETTINGS)\r\n* client no longer sends the WEBTRANSPORT_MAX_SESSIONS setting\r\n* Add a \"Considerations for future versions of WebTransport\" section that explain that if a future version of WebTransport changes the syntax of the request, it'll need to change the Upgrade Token. Similarly, changes to stream formats will require changes to the Unidirectional Stream Type and Bidirectional Stream Signal Value.",
          "createdAt": "2024-01-24T00:04:21Z",
          "updatedAt": "2024-01-24T00:04:21Z"
        }
      ]
    },
    {
      "number": 141,
      "id": "I_kwDOCvK98s5140yO",
      "title": "don't require the client to send the WEBTRANSPORT_MAX_SESSIONS setting",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/141",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "ekinnear"
      ],
      "labels": [
        "has pull request"
      ],
      "body": "There's no need for the client to send the WEBTRANSPORT_MAX_SESSIONS setting. The server doesn't need to know that a client supports WebTransport until it receives the first Extended CONNECT request that attempts to establish a WebTransport session.\r\n\r\nSimilar to #140, this requirement technically requires servers to buffer incoming requests until they have received the SETTINGS frame, if they want to check that the client actually sent the setting.",
      "createdAt": "2023-11-05T15:11:07Z",
      "updatedAt": "2024-03-04T23:57:36Z",
      "closedAt": "2024-03-04T23:57:36Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "It's a version negotiation mechanism. You can't figure out what version of WebTransport is being used until you see what version the client supports, and what version the server supports, since the version used is max(client versions \u2229 server versions).\r\n\r\n> Similar to https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/140, this requirement technically requires servers to buffer incoming requests until they have received the SETTINGS frame, if they want to check that the client actually sent the setting.\r\n\r\nCorrect.",
          "createdAt": "2023-11-05T21:17:29Z",
          "updatedAt": "2023-11-05T21:17:29Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "For extra context, see also #125, #84, and especially #130 where it was proposed that the client not send the setting.",
          "createdAt": "2023-11-05T21:51:32Z",
          "updatedAt": "2023-11-05T21:51:32Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "If we can get to a place (and not run into issues with some of the other settings that get exchanged) that means we don't need to add any roundtrips before we can get going with WebTransport application data, I think we'll be very happy, so I would generally support anything that gets us closer to that goal.",
          "createdAt": "2023-11-05T21:52:39Z",
          "updatedAt": "2023-11-05T21:52:39Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "None of this causes any additional latency unless there is packet loss, and since you'd usually bundle your settings with ServerHello (for the server) or the CONNECT request (for the client), that should normally not matter for the client either.",
          "createdAt": "2023-11-05T22:17:00Z",
          "updatedAt": "2023-11-05T22:17:00Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> None of this causes any additional latency unless there is packet loss, and since you'd usually bundle your settings with ServerHello (for the server) or the CONNECT request (for the client), that should normally not matter for the client either.\r\n\r\nI'm not worried about roundtrips here. The server sends SETTINGS in 0.5-RTT data, so they should be available as soon as the handshake completes. What I'm worried about are resource exhaustion attacks if the server has to buffer requests until it receives the client's SETTINGS. A malicious client could withhold sending of this frame for an arbitrarily long time.\r\n\r\n\r\n> It's a version negotiation mechanism. You can't figure out what version of WebTransport is being used until you see what version the client supports, and what version the server supports, since the version used is max(client versions \u2229 server versions).\r\n\r\nIn my HTTP/3 implementation, every HTTP request is handled immediately. There's no buffering of requests. I believe this is a reasonable design for defending against a variety of resource exhaustion attacks.\r\nWebTransport version negotiation seems to be the only occurrence that breaks this design. Note that this however is only needed if you want to support multiple draft versions. If you only offer a single WebTransport draft version, you _know_ that the client will have to use that version, as the client MUST wait for the SETTINGS frame.\r\n\r\n",
          "createdAt": "2023-11-06T07:57:09Z",
          "updatedAt": "2023-11-06T07:57:09Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: we didn't discuss this specific issue in the WG session at IETF 118, but see related issues https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/135, https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/140, and https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/143.",
          "createdAt": "2023-11-06T17:08:05Z",
          "updatedAt": "2023-11-06T17:08:05Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "So the proposal here is to say that the client including the \"webtransport\" upgrade token is sufficient. \r\n\r\n- For version negotiation we cannot offer multiple upgrade tokens (yet). \r\n- Moving it to the request might be interesting as an idea, but the issue with that is that we change the meaning of certain frames and you need the entire HTTP/3 connection to agree on what the stream formats are. \r\n- Especially if we're trying to avoid having the server have to buffer some of the frames, that seems sub-optimal.\r\n\r\nThe alternative is that the server has to buffer until it gets SETTINGS.\r\n\r\nFundamentally, it seems like if we want to avoid buffering, but we also need the server to have a piece of information from the client, the only way to ensure that we don't have to buffer is to ensure that the information from the client arrives atomically with the thing that we'd be buffering.\r\n\r\nEditor's meeting led us to one way to tackle this:\r\n1. Client never sends a SETTING indicating what it supports. \r\n2. Server sends a SETTING indicating every version that it supports. \r\n3. We commit to changing the code points for all special WT frames, etc. with each version.\r\n4. The server can always tell based on what's coming in what version it's talking, and it can enforce that we talk a single version on each connection.\r\n5. The server only has to buffer things that it would have to buffer today (i.e. no waiting for SETTINGS, but you do have to buffer if you get in STREAM frames for a WT session that isn't yet open, just like today).\r\n\r\n@vasilvv took an action to identify why we rejected this in the past.\r\n\r\nSame story for #143.",
          "createdAt": "2024-01-10T00:01:58Z",
          "updatedAt": "2024-01-10T00:01:58Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in editor's meeting, @vasilvv cleared previous concerns.",
          "createdAt": "2024-01-23T23:50:05Z",
          "updatedAt": "2024-01-23T23:50:05Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting. Plan is to write one PR that resolves #135, #140, #141, and #143. That PR would say:\r\n* client MUST wait for server settings\r\n* endpoints MUST send SETTINGS_H3_DATAGRAM (however servers that want to validate this MUST need to take into account the fact that the request might arrive before the client's SETTINGS)\r\n* client no longer sends the WEBTRANSPORT_MAX_SESSIONS setting\r\n* Add a \"Considerations for future versions of WebTransport\" section that explain that if a future version of WebTransport changes the syntax of the request, it'll need to change the Upgrade Token. Similarly, changes to stream formats will require changes to the Unidirectional Stream Type and Bidirectional Stream Signal Value.",
          "createdAt": "2024-01-24T00:04:31Z",
          "updatedAt": "2024-01-24T00:04:31Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm very happy with this solution, thank you @DavidSchinazi!\r\n\r\n> * endpoints MUST send SETTINGS_H3_DATAGRAM (however servers that want to validate this MUST need to take into account the fact that the request might arrive before the client's SETTINGS)\r\n\r\nIs it valid for a server implementation to do this validation retroactively? A server could first accept the WebTransport session assuming that the client's settings will be valid, and if / once the settings are received, it performs the required checks and kills the QUIC connection if the client didn't offer SETTINGS_H3_DATAGRAM.",
          "createdAt": "2024-01-24T02:58:30Z",
          "updatedAt": "2024-01-24T02:58:30Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "That's a good point - yeah from my perspective (as individual contributor) I'd say that it's totally OK for the server to accept the request and reply with 200 before it receives the client's settings, and then abort the stream or connection when it receives the settings if SETTINGS_H3_DATAGRAM is missing",
          "createdAt": "2024-01-24T21:51:17Z",
          "updatedAt": "2024-01-24T21:51:17Z"
        }
      ]
    },
    {
      "number": 142,
      "id": "I_kwDOCvK98s5158kK",
      "title": "SETTINGS_WEBTRANSPORT_MAX_SESSIONS safety",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/142",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "MAX_SESSIONS is an HTTP/2-style limit. The spec currently says:\r\n> The server MUST NOT close the connection if the client opens sessions exceeding this limit, as the client and the server do not have a consistent view of how many sessions are open due to the asynchronous nature of the protocol; instead, it MUST reset all of the CONNECT streams it is not willing to process with the HTTP_REQUEST_REJECTED status defined in [[HTTP3](https://ietf-wg-webtrans.github.io/draft-ietf-webtrans-http3/draft-ietf-webtrans-http3.html#HTTP3)].\r\n\r\nDoes this make us vulnerable to Rapid Reset-style attacks?",
      "createdAt": "2023-11-06T01:52:56Z",
      "updatedAt": "2024-01-23T23:57:57Z",
      "closedAt": "2024-01-23T23:57:56Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This feels like the usual case where an HTTP/2 client might try and open more request streams than a server would allow. Each request over the concurrency limit must be reset. The client and server can have a different view of what the limit is due to SETTINGS racing. \r\n\r\nPer HTTP/2 security considerations, a server should provide defenses against protocol behaviour abuse; such as counting how many streams it resets (for any reason). Resetting a CONNECT stream due to MAX_SESSIONS limits seems like another variant. So maybe all we need to do is highlight this in the security considerations (maybe even just by citation).",
          "createdAt": "2023-11-06T02:03:34Z",
          "updatedAt": "2023-11-06T02:03:34Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that at least in this case, the client may exceed MAX_SESSIONS, but it is still bound by MAX_STREAMS for the overall request limit, which potentially limits amount of damage.\r\n\r\n> such as counting how many streams it resets (for any reason)\r\n\r\nThat would be really bad for WebTransport though, since it's perfectly valid for application to reset data streams as much as it needs.",
          "createdAt": "2023-11-06T02:07:30Z",
          "updatedAt": "2023-11-06T02:07:30Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That would be really bad for WebTransport though, since it's perfectly valid for application to reset data streams as much as it needs.\r\n\r\nCorrect. The server needs to be smarter and consider the context of each reset, such as count the number of CONNECT requests rejected because the MAX_SESSIONS value didn't permit the stream. Counting valid uses of reset might be useful but acting on it (by closing a connection) can damage legitimate uses. ",
          "createdAt": "2023-11-06T02:21:44Z",
          "updatedAt": "2023-11-06T02:22:15Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in editor's meeting: \r\n\r\nWe need _some_ bound to enable you to prevent WT (or a single session) from using up all of the streams. However, the fact that this is running over HTTP/3 means that all of these are governed by HTTP/3 stream limits, which is already safe against rapid-reset style attacks. Put another way, you could just as effectively attack this with many GET requests as with attempts to open WT sessions.\r\n\r\nKeeping a WT session from using all the streams is something for a WT-over-H3 flow control design to accomplish, but it's not needed as a security boundary to protect against this style of attack.",
          "createdAt": "2024-01-23T23:57:56Z",
          "updatedAt": "2024-01-23T23:57:56Z"
        }
      ]
    },
    {
      "number": 143,
      "id": "I_kwDOCvK98s51_XVf",
      "title": "What does the server do if it receives a WebTransport request before the client's SETTINGS",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/143",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ekinnear"
      ],
      "labels": [
        "has pull request"
      ],
      "body": "As discussed in #139 and during the WG session at IETF 118, it is possible for the server to receives a WebTransport request before the client's SETTINGS. In that scenario, there are multiple options possible\r\n* have the server respond to the webtransport request assuming that the client supports webtransport\r\n* have the server buffer this request until it receives the client's SETTINGS\r\n* have the server buffer all bidirectional stream data until it receives the client's SETTINGS\r\n\r\nIt was raised during the meeting that the latter options might make servers vulnerable to malicious clients that send many requests without ever sending SETTINGS.\r\n\r\nWe need to specify how the server behaves in this scenario",
      "createdAt": "2023-11-06T16:21:20Z",
      "updatedAt": "2024-03-04T23:57:37Z",
      "closedAt": "2024-03-04T23:57:37Z",
      "comments": [
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in editor's meeting:\r\n\r\n- Practically, if you support more than one WT version, you have to buffer CONNECT requests, until you know which version you're going to use (this arrives in the client's SETTINGS). The CONNECT itself might, in some WT version, contain information that depends on the WT version in use.\r\n- When a new stream arrives, you have to parse far enough into it to determine that it's: \r\n    - a WebTransport stream\r\n    - the WebTransport session ID, so that you can tell if you have already received the CONNECT request/stream\r\n\r\nPossible position: Therefore, you already have a buffering point on the server, so anything that we do around the client's SETTINGS arriving won't make a significant difference.\r\n\r\nServer's that only support a single WT version can assume that it's that, or you can apply rules from all supported versions. If we're being careful in the future when we define new versions, we might take care to ensure that WT session IDs and the surrounding items stay at the front so that you don't have to determine the version before you know what to do with the stream. Even if we do that, it doesn't tackle whether or not the CONNECT request has version-dependent headers.\r\n\r\nOne option is to say that we have an invariant across versions that all WT streams start with the type and the session ID. We could potentially choose to include some indication of the version in the CONNECT request (either in :protocol or in a separate header, and then sort out all of the issues that arise if you send conflicting versions which should be possible but gross). All that would buy us is the ability to respond to incoming CONNECT requests _for WT versions that don't need non-default SETTINGS values_ and that also don't have a separate header in CONNECT requests that would carry such information.",
          "createdAt": "2023-11-29T00:01:28Z",
          "updatedAt": "2023-11-29T00:31:48Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "(speaking as individual contributor) We also have the ability to change the Upgrade Token, Unidirectional Stream Type, and Bidirectional Stream Signal Value. If a future version of WebTransport wants to change the wire format of streams (change the session ID at the start) or of the request (reuse an existing header to mean something else) then all it needs to do is change the corresponding value. That completely removes the need to wait for client settings.",
          "createdAt": "2023-11-29T00:43:53Z",
          "updatedAt": "2023-11-29T00:43:53Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in editor's meeting. Plan is to write one PR that resolves #135, #140, #141, and #143. That PR would say:\r\n* client MUST wait for server settings\r\n* endpoints MUST send SETTINGS_H3_DATAGRAM (however servers that want to validate this MUST need to take into account the fact that the request might arrive before the client's SETTINGS)\r\n* client no longer sends the WEBTRANSPORT_MAX_SESSIONS setting\r\n* Add a \"Considerations for future versions of WebTransport\" section that explain that if a future version of WebTransport changes the syntax of the request, it'll need to change the Upgrade Token. Similarly, changes to stream formats will require changes to the Unidirectional Stream Type and Bidirectional Stream Signal Value.",
          "createdAt": "2024-01-24T00:04:35Z",
          "updatedAt": "2024-01-24T00:04:35Z"
        }
      ]
    },
    {
      "number": 147,
      "id": "I_kwDOCvK98s5_aQLr",
      "title": "CLOSE_WEBTRANSPORT_SESSION and connection termination ",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/147",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "afrind"
      ],
      "labels": [
        "ready for PR"
      ],
      "body": "Section 5 rightly points out the caveats with trying to close a session in unison with a connection \r\n\r\n> In some scenarios, an endpoint might want to send a CLOSE_WEBTRANSPORT_SESSION with detailed close information and then immediately close the underlying QUIC connection. If the endpoint were to do both of those simultaneously, the peer could potentially receive the CONNECTION_CLOSE before receiving the CLOSE_WEBTRANSPORT_SESSION, thus never receiving the application error data contained in the latter. To avoid this, the endpoint SHOULD wait until all of the data on the CONNECT stream is acknowledged before sending the CONNECTION_CLOSE; this gives CLOSE_WEBTRANSPORT_SESSION properties similar to that of the QUIC CONNECTION_CLOSE mechanism as a best-effort mechanism of delivering application close metadata.\r\n\r\nThis text has some problems though. \r\n\r\nIt seems to assume that implementations would surface QUIC stream data acknowledgments, that's not a strict requirement of QUIC.\r\n\r\nI'm not sure it accomodates intermediaries. The capsule is end-to-end, so even if the data is delivered to the next hop, there is not guarantee that the end peer really received it.\r\n\r\nStream data transport acknowledgment does not guarantee that applications even read the data. \r\n\r\nAre the recommendations really that useful for the use case stated? If an endpoint wants to close both things simultaneously, it could just send the CONNECTION_CLOSE with a Webtransport error code and the reason phrase can hold the details. The capsule is superfluous in this case. The capsulebis most useful when an endpoint wants to close the session independent of the connection.",
      "createdAt": "2024-02-15T23:01:00Z",
      "updatedAt": "2024-06-11T22:14:23Z",
      "closedAt": "2024-06-11T22:14:23Z",
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Or maybe, if we want solution that is fully intermediary safe, then there should be a close ack capsule?",
          "createdAt": "2024-02-15T23:09:02Z",
          "updatedAt": "2024-02-15T23:09:02Z"
        },
        {
          "author": "bwoebi",
          "authorAssociation": "NONE",
          "body": "Can we just require the peer to instead close the CONNECT stream upon receipt of the CLOSE_WEBTRANSPORT_SESSION capsule? That way the peer will definitely have received it on the application layer.\r\nAnd the initiating side of the close may move ahead with closing the whole connection upon receipt of the stream close.",
          "createdAt": "2024-02-16T11:35:53Z",
          "updatedAt": "2024-02-16T11:52:27Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in editor's meeting: \r\n- Can send CLOSE_WEBTRANSPORT_SESSION and not do anything more\r\n- When you receive CLOSE_WT_SESSION, you close the CONNECT stream\r\n- If you wanted to close the QUIC tunnel, you wait until all CONNECT streams are closed, then take down the tunnel\r\n\r\nIn other words, stream ending in both directions is sufficient.\r\nWe already have some similar text around session termination, we can probably pull that up and make it consistent.\r\n\r\nNeed to be careful since they could also have chosen to close the session independently. This is probably okay because if the other side went away, we may not care.",
          "createdAt": "2024-03-05T23:10:51Z",
          "updatedAt": "2024-03-05T23:13:32Z"
        }
      ]
    },
    {
      "number": 150,
      "id": "I_kwDOCvK98s6BXMwc",
      "title": "Negotiation of flow control",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/150",
      "state": "OPEN",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "vasilvv"
      ],
      "labels": [
        "ready for PR"
      ],
      "body": "As mentioned by @marten-seemann [on the list](https://mailarchive.ietf.org/arch/msg/webtransport/JP3KS1rRTMQwQoGfht2GlCxtAZk/), making flow control optional requires the ability to negotiate it. We should add that to the protocol, using HTTP headers or SETTINGS.",
      "createdAt": "2024-03-05T23:38:05Z",
      "updatedAt": "2024-06-12T15:46:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My preference is to make it non-optional.  Negotiation is - at least in engineering time for our implementation - roughly equivalent in expense to adding some more flow control.  As a browser, of course, we're probably on the hook to implement anyway.",
          "createdAt": "2024-06-11T22:08:35Z",
          "updatedAt": "2024-06-11T22:36:38Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in editor's meeting: Flip back the other way and have the client send MAX_SESSIONS, if either end is >1 Flow Control is happening, if either side is just 1, no flow control, if 0, no WT.",
          "createdAt": "2024-06-11T22:42:28Z",
          "updatedAt": "2024-06-11T22:42:28Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "(Can locally set the limits really high when you see 1 from the other side, which causes you to ignore all other frames)",
          "createdAt": "2024-06-11T22:43:36Z",
          "updatedAt": "2024-06-11T22:43:36Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "How does adding the ability to negotiate flow control-off in some cases help?  ",
          "createdAt": "2024-06-12T15:46:54Z",
          "updatedAt": "2024-06-12T15:46:54Z"
        }
      ]
    },
    {
      "number": 152,
      "id": "I_kwDOCvK98s6CnKmd",
      "title": "putting all flow control capsules on the control stream introduces head-of-line blocking",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/152",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current proposal (https://datatracker.ietf.org/doc/draft-thomson-webtrans-session-limit/) for transmitting flow control messages serializes the capsules onto the WebTransport control stream. Since the control stream is a QUIC stream, this means that these messages suffer from HoL blocking in the case of packet loss.\r\n\r\nDepending on the usage pattern of the WebTransport application, this will matter more or less.\r\n\r\nIt would be nice to figure out a solution that doesn't suffer from HoL blocking.",
      "createdAt": "2024-03-18T06:02:09Z",
      "updatedAt": "2024-05-14T23:14:25Z",
      "closedAt": "2024-05-14T23:14:25Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: we discussed this in the room at IETF 119. Rough consensus in room was that head of line blocking was not a critical issue in this scenario and we could ignore this for now. Current plan is to close this with no action.",
          "createdAt": "2024-03-18T13:46:26Z",
          "updatedAt": "2024-03-18T13:46:26Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "As chair: In the two months since this was opened, we haven't seen any new information pointing to this being a real problem. We're therefore confirming the rough consensus that the WG doesn't see this as a blocking issue. I'm therefore closing this issue.",
          "createdAt": "2024-05-14T23:14:25Z",
          "updatedAt": "2024-05-14T23:14:25Z"
        }
      ]
    },
    {
      "number": 153,
      "id": "I_kwDOCvK98s6DYbtO",
      "title": "Does the client really need to send SETTINGS_ENABLE_CONNECT_PROTOCOL?",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/153",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready for PR"
      ],
      "body": "With #149, the draft now says:\r\n> To use WebTransport over HTTP/3, clients MUST send the SETTINGS_ENABLE_CONNECT_PROTOCOL setting with a value of \"1\".\r\n\r\nI don't understand why this is necessary. SETTINGS_ENABLE_CONNECT_PROTOCOL allows the client to send Extended CONNECT requests. Why does the client need to declare that it supports the Extended CONNECT protocol if it can just send an Extended CONNECT request?\r\n\r\nMy understanding of RFC 8441 is that it's not required:\r\n> Upon receipt of SETTINGS_ENABLE_CONNECT_PROTOCOL with a value of 1, a client MAY use the Extended CONNECT as defined in this document when creating new streams.  Receipt of this parameter by a server does not have any impact.\r\n\r\n---\r\n\r\nNote the similarities to a similar discussion we had about SETTINGS_WEBTRANSPORT_MAX_SESSIONS, where we concluded that it's not necessary for the client to send this setting.\r\n\r\n",
      "createdAt": "2024-03-24T07:14:37Z",
      "updatedAt": "2024-04-16T22:26:07Z",
      "closedAt": "2024-04-16T22:26:07Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "(speaking as individual contributor) I think Marten's right, we only need `SETTINGS_ENABLE_CONNECT_PROTOCOL` from server to client.",
          "createdAt": "2024-03-24T07:17:29Z",
          "updatedAt": "2024-03-24T07:17:54Z"
        }
      ]
    },
    {
      "number": 155,
      "id": "I_kwDOCvK98s6DYdfZ",
      "title": "What happens if the client doesn't enable HTTP datagrams?",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/155",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "afrind"
      ],
      "labels": [
        "ready for PR"
      ],
      "body": "With #149, the server is not required to wait for the client's HTTP/3 SETTINGS anymore:\r\n> Servers should also note that CONNECT requests to establish new WebTransport sessions, in addition to other messages, may arrive before this SETTING is received (see [Section 4.5](https://ietf-wg-webtrans.github.io/draft-ietf-webtrans-http3/draft-ietf-webtrans-http3.html#buffering-incoming)).\r\n\r\nWe should specify what happens if the client sends invalid SETTINGS (e.g. by not enabling HTTP datagrams). There are two options:\r\n1. Kill the underlying QUIC connection. We should probably define an HTTP/3 error code for this.\r\n2. Kill the WebTransport session(s). It's not clear how to do this, since the CLOSE_WEBTRANSPORT_SESSION capsule only carries an application error, and there's currently no way to send a (web-) transport error. If we decide to do flow control in WebTransport, this seems like something we'll need to add anyway though.",
      "createdAt": "2024-03-24T07:41:41Z",
      "updatedAt": "2024-08-20T22:19:21Z",
      "closedAt": "2024-08-20T22:19:21Z",
      "comments": []
    },
    {
      "number": 156,
      "id": "I_kwDOCvK98s6DYeDA",
      "title": "inconsistent behavior when receiving CLOSE_WEBTRANSPORT_SESSION",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/156",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready for PR"
      ],
      "body": "This probably doesn't matter in practice, but it seems inconsistent to FIN the stream upon receipt of the CLOSE_WEBTRANSPORT_SESSION capsule. For example, the receiver might be in the middle of sending a CLOSE_WEBTRANSPORT_SESSION themselves (and blocked on flow control, for example). Semantically, FIN would imply that transmitting on this stream finished successfully.\r\n\r\n> An endpoint that sends a CLOSE_WEBTRANSPORT_SESSION capsule MUST immediately send a FIN. The endpoint MAY send a STOP_SENDING to indicate it is no longer reading from the CONNECT stream. The recipient MUST close the stream upon receiving a FIN.\r\n\r\nInstead, the receiver should reset the stream.\r\n",
      "createdAt": "2024-03-24T07:49:16Z",
      "updatedAt": "2024-04-16T22:31:02Z",
      "closedAt": "2024-04-16T22:31:02Z",
      "comments": []
    },
    {
      "number": 157,
      "id": "I_kwDOCvK98s6ELjnd",
      "title": "define a reliable way to signal the session close reason",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/157",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft suggests to wait until all data on the CONNECT stream was acknowledged in order to ensure that the CLOSE_WEBTRANSPORT_SESSION capsule was consumed.\r\n\r\nThis is problematic for 2 reasons:\r\n1. It\u2019s a layering violation. The WebTransport layer might not have access to the acknowledgment state of the QUIC layer.\r\n2. Receiving an ACK for a packet containing a STREAM frames doesn\u2019t mean that the stream data was delivered to the application. It only means that the QUIC layer received the data, but it might still be sitting in a buffer there and be discarded when the CONNECTION_CLOSE is received.\r\n\r\nInstead, we could define a CLOSE_WEBTRANSPORT_SESSION_ACK capsule to acknowledge the CLOSE_WEBTRANSPORT_SESSION capsule. This would make delivery of the close reason completely reliable.",
      "createdAt": "2024-04-01T06:23:57Z",
      "updatedAt": "2024-04-01T21:08:37Z",
      "closedAt": "2024-04-01T21:08:37Z",
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Didn't we already decide at some point before that you \"ack\" closes by closing the local send side of the control stream in response?",
          "createdAt": "2024-04-01T16:27:51Z",
          "updatedAt": "2024-04-01T16:27:51Z"
        },
        {
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks like this is a duplicate of #147. Sorry I missed the original issue.",
          "createdAt": "2024-04-01T21:08:37Z",
          "updatedAt": "2024-04-01T21:08:37Z"
        }
      ]
    },
    {
      "number": 158,
      "id": "I_kwDOCvK98s6ES9pY",
      "title": "0-RTT restrictions",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/158",
      "state": "CLOSED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently the draft says:\r\n> However, WebTransport-related SETTINGS parameters may be retained from the previous session as described in Section 7.2.4.2 of [[HTTP3](https://ietf-wg-webtrans.github.io/draft-ietf-webtrans-http3/draft-ietf-webtrans-http3.html#HTTP3)]. If the server accepts 0-RTT, the server MUST NOT reduce the limit of maximum open WebTransport sessions from the one negotiated during the previous session; such change would be deemed incompatible, and MUST result in a H3_SETTINGS_ERROR connection error.\r\n\r\nI'm surprised by this requirement. Since WebTransport can't be dialed in 0-RTT anyway, what's the point of saving any WebTransport-related settings when doing 0-RTT. Since we have to wait for handshake completion anyway, we might as well start from a clean slate (let the server decide what SETTINGS to use on the new connection).",
      "createdAt": "2024-04-02T04:56:44Z",
      "updatedAt": "2024-06-11T22:14:10Z",
      "closedAt": "2024-06-11T22:14:10Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "(speaking as individual) this is pretty standard for 0-RTT handling of settings. There's nothing preventing the client from ignoring 0-RTT settings. And the server can remember by hard-coding the value in software or configuration. I'd prefer we keep this consistent with every other settings, as this would be the first one requiring special handling. Propose to close with no action.",
          "createdAt": "2024-04-16T22:33:26Z",
          "updatedAt": "2024-04-16T22:33:26Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Unless we have other places where we say that a client MUST NOT remember a SETTING for 0-RTT, I'd be hesitant to introduce one here just because it's not useful. Saying that you can't do 0-RTT and then punish someone for using the limits that you previously expressed is good, even if in this case it's just an artifact of the mechanism that we used to communicate those limits to the client (which happens to get saved for 0-RTT).",
          "createdAt": "2024-04-16T22:34:17Z",
          "updatedAt": "2024-04-16T22:34:17Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: any further thoughts here? Without strong motivation, it seems like the best path forward is to keep consistency with other settings. Unless there are objections, we'll close this issue with no action.",
          "createdAt": "2024-05-14T23:15:47Z",
          "updatedAt": "2024-05-14T23:15:47Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: due to lack of interest, closing with no action",
          "createdAt": "2024-06-11T22:14:10Z",
          "updatedAt": "2024-06-11T22:14:10Z"
        }
      ]
    },
    {
      "number": 159,
      "id": "I_kwDOCvK98s6FIZV5",
      "title": "WebTransport-Subprotocols-Available -handling of list ordering and duplicates",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/159",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "martinthomson"
      ],
      "labels": [
        "ready for PR"
      ],
      "body": "> Both WebTransport-Subprotocols-Available and WebTransport-Subprotocol are Structured Fields [[RFC8941](https://ietf-wg-webtrans.github.io/draft-ietf-webtrans-http3/draft-ietf-webtrans-http3.html#RFC8941)]. WebTransport-Subprotocols-Available is a List of Tokens, and WebTransport-Subprotocol is a Token.\r\n\r\nA list would allow duplicate entries and could have ordering significance, we probably want some explicit statement about how to handle those. ",
      "createdAt": "2024-04-09T14:24:16Z",
      "updatedAt": "2024-08-20T22:12:08Z",
      "closedAt": "2024-08-20T22:12:08Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "(speaking as individual) +1, a few explicit statements would help. I'd suggest we disallow repetition, and have the ordering convey the client's preference",
          "createdAt": "2024-04-16T22:35:56Z",
          "updatedAt": "2024-04-16T22:35:56Z"
        }
      ]
    },
    {
      "number": 164,
      "id": "I_kwDOCvK98s6L6sWd",
      "title": "WT-Available-Protocols IANA registration",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/164",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "martinthomson"
      ],
      "labels": [
        "ready for PR"
      ],
      "body": "Nothing in the IANA considerations section for this.  We should do that.",
      "createdAt": "2024-06-11T22:36:06Z",
      "updatedAt": "2024-07-24T18:58:11Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 167,
      "id": "I_kwDOCvK98s6NAT0u",
      "title": "Do we need DRAIN_WEBTRANSPORT_SESSION? ",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/167",
      "state": "OPEN",
      "author": "aboba",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "ekinnear"
      ],
      "labels": [],
      "body": "Reference: https://github.com/w3c/webtransport/issues/436\r\n\r\nIn WebTransport API Issue 436, Erik and Martin have made an argument for why client-initiated drain (via `DRAIN_WEBTRANSPORT_SESSION`) is not compelling. \r\n\r\nDo we buy this argument, and if so, does it apply to server-initiated drain as well?  ",
      "createdAt": "2024-06-21T04:05:07Z",
      "updatedAt": "2024-07-29T16:30:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "The reason for a server-initiated drain is that a reverse HTTP proxy can receive a GOAWAY for one of its backend connections, and it should be able to forward that information to its clients.",
          "createdAt": "2024-06-21T06:01:10Z",
          "updatedAt": "2024-06-21T06:01:10Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed at IETF 120. We want to keep this capsule. We want to allow sending it in both directions at the IETF level (W3C API could restrict that). The explanation of what to do when you receive it is vague for potentially good reasons, but that might need clarification.",
          "createdAt": "2024-07-25T23:31:36Z",
          "updatedAt": "2024-07-25T23:31:36Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A question still remains about the meaning of \"endpoint\" and \"application\" in [WebTransport over HTTP/3 Section 4.6](https://ietf-wg-webtrans.github.io/draft-ietf-webtrans-http3/draft-ietf-webtrans-http3.html#name-interaction-with-http-3-goa):\r\n\r\n\"After sending or receiving either a DRAIN_WEBTRANSPORT_SESSION capsule or a HTTP/3 GOAWAY frame, an endpoint MAY continue using the session and MAY open new streams. The signal is intended for the application using WebTransport, which is expected to attempt to gracefully terminate the session as soon as possible.\"\r\n\r\nDoes \"endpoint\" in the first sentence refer to the user agent? If so, the first sentence would allow (but not require or recommend) that the browser be able to open new streams even after sending or receiving DRAIN_WEBTRANSPORT_SESSION.  Is making the behavior optional in the best interest of developers?  For example, if a client sends DRAIN_WEBTRANSPORT_SESSION to a server, is it ok for one server to allow the client to open new streams, and another server to refuse to do so? \r\n\r\nIn the second sentence, does \"application\" refer to the user agent or the Javascript application?  If it refers to the user agent, the UA is \"expected to attempt to gracefully terminate\" which would seem to imply an action on the part of the UA (e.g. prohibiting creation of new streams).  If \"application\" refers to the Javascript application, then it is the JS applicaiton that is \"expected to attempt to gracefully terminate\", not the browser. That seems more compatible with an API that doesn't enforce restrictions after sending or receiving DRAIN_WEBTRANSPORT_SESSION. ",
          "createdAt": "2024-07-26T23:13:12Z",
          "updatedAt": "2024-07-26T23:21:43Z"
        },
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought `endpoint` would be defined in either webtrans over h3 or the overview, but alas it is not.  Keep in mind that from the perspective of this draft, we do not distinguish a user-agent and JS application.\r\n\r\nThe MAY is there to indicate what the endpoint is allowed to do.  It can make more streams.  Therefore the other endpoint really ought not to treat new streams in a drained session as an error. Do we need a normative MUST NOT/SHOULD NOT?\r\n\r\n",
          "createdAt": "2024-07-29T16:30:49Z",
          "updatedAt": "2024-07-29T16:30:49Z"
        }
      ]
    },
    {
      "number": 170,
      "id": "I_kwDOCvK98s6S_BqB",
      "title": "Exporters and TLS proxies",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/170",
      "state": "CLOSED",
      "author": "yaroslavros",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Historically client-side APIs in browsers such as JavaScript and WASM never had access to TLS exporter.\r\nAs far as I know exposure of TLS exporter in WebTransport would be the first precedent for in-browser code.\r\n\r\nA TLS proxy between client and server implemented in a form of a Secure Web Gateway, a NGFW or a generic SSE service will result in exporter difference on client and server side. Applications that rely on exporter consistency to negotiate common cryptographic context will be always broken by any TLS proxy that decrypts/re-encrypts QUIC.\r\n\r\nIn recent history there were few TLS developments that relied on end-to-end encryption. They were broken badly by TLS proxies to the extend that these standards are no longer used on public internet: HPKP (RFC7469) and Token Binding (RFC8471). Here are relevant Chromium discussions about removal of these features as they backfired: https://groups.google.com/a/chromium.org/g/blink-dev/c/he9tr7p3rZ8/ and https://groups.google.com/a/chromium.org/g/blink-dev/c/OkdLUyYmY1E/\r\n\r\nAs I mentioned on the IETF120 WebTransport meeting, I would strongly suggest not to expose TLS exporters in client API as it will lead to inconsistent user experience depending on presence of a TLS proxy. These issues will be quite hard to troubleshoot for application developers as TLS proxies are typically deployed on client side.\r\n\r\nI believe that a better design pattern for applications that do not trust HTTP/3 security and require a common shared secret over WebTransport channel would be to run own KEM within the WebTransport or leverage HPKE.",
      "createdAt": "2024-08-14T14:21:00Z",
      "updatedAt": "2024-08-14T18:46:05Z",
      "closedAt": "2024-08-14T18:46:04Z",
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "We're adding key exporters at the IETF layer in service of the W3C API. Since these concerns are about the fact that we're offering exporters (as opposed to the implementation details), this should be discussed in the corresponding W3C issue: https://github.com/w3c/webtransport/issues/411. I'm closing this issue, we can continue the discussion there",
          "createdAt": "2024-08-14T18:46:05Z",
          "updatedAt": "2024-08-14T18:46:05Z"
        }
      ]
    },
    {
      "number": 171,
      "id": "I_kwDOCvK98s6XYywf",
      "title": "Incorrect statement about H3 GOAWAY",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/171",
      "state": "OPEN",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-http3-10#section-4.6 states\r\n\r\n> A client receiving GOAWAY cannot initiate CONNECT requests for new WebTransport sessions if the stream identifier is equal to or greater than the indicated stream ID.\r\n\r\nHowever this is slightly incorrect, RFC 9114 states \r\n\r\n> Endpoints MUST NOT initiate new requests or promise new pushes on the connection after receipt of a [GOAWAY](https://www.rfc-editor.org/rfc/rfc9114#frame-goaway) frame from the peer.\r\n\r\nIn other words, it doesn't matter what ID you receive in the GOAWAY, the client cannot send new CONNECT requests after a GOAWAY has been received.\r\n",
      "createdAt": "2024-09-21T01:02:19Z",
      "updatedAt": "2024-09-21T01:02:19Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 172,
      "id": "I_kwDOCvK98s6XfrTR",
      "title": "Should subprotocol negotiation be mandatory?",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/172",
      "state": "OPEN",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In QUIC we made ALPN mandatory to avoid protocol confusion attacks. Should the new mechanism we're introducing for WebTransport be mandatory as well?",
      "createdAt": "2024-09-23T06:14:41Z",
      "updatedAt": "2024-09-24T01:53:00Z",
      "closedAt": null,
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "We've considered that, but there is already shipped code out there that predates us having those.\r\n\r\nAlso, HTTP resources are identified by URIs, which are different from QUIC endpoints (that only have host and port), so the risk level for those is different.",
          "createdAt": "2024-09-24T01:52:59Z",
          "updatedAt": "2024-09-24T01:52:59Z"
        }
      ]
    },
    {
      "number": 173,
      "id": "I_kwDOCvK98s6Xfrnu",
      "title": "Finish renaming subprotocols",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/173",
      "state": "CLOSED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "ekinnear"
      ],
      "labels": [],
      "body": "We decided to use `protocol` instead of `subprotocol`, so finish renaming it everywhere, even in prose about the feature. This will now be consistent across H2, H3, and the overview document.",
      "createdAt": "2024-09-23T06:15:39Z",
      "updatedAt": "2024-10-21T21:53:17Z",
      "closedAt": "2024-10-21T21:53:17Z",
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI0MzQ3MDEz",
      "title": "Refactor the spec to actually send the origin to the server",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/1",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-10-03T18:24:20Z",
      "updatedAt": "2019-10-05T14:09:47Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "master",
      "baseRefOid": "b63401f4fb1571a5ba86257f9500ddcb04dba967",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "stream2",
      "headRefOid": "eeaac8c28b34cfb71fa59dbccdc4ada5eb856d45",
      "closedAt": "2019-10-04T20:00:30Z",
      "mergedAt": "2019-10-04T20:00:30Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "463cd5c2a6adc48ea89b577d898922a127d7ce0a"
      },
      "comments": [
        {
          "author": "flano-yuki",
          "authorAssociation": "NONE",
          "body": "What is the uri-scheme used in an origin?\r\n( It may be discussed as a separate issue.\r\n",
          "createdAt": "2019-10-04T05:40:56Z",
          "updatedAt": "2019-10-04T05:40:56Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> What is the uri-scheme used in an origin?\r\n> ( It may be discussed as a separate issue.\r\n\r\nWell, the origin sent here is the origin of the webpage that created QuicTransport; so, for instance, if `https://website.example/webapp` connects using QuicTransport to `quic-server.example:443`, the origin  send would be `https://website.example`.\r\n\r\nI don't think a QuicTransport connection can be an origin by itself.  We are currently considering giving it its own URL scheme, but a URL can only act as an origin if a user can [navigate](https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigate) to it, or if the URL has storage attached to it (which QuicTransport doesn't, since it doesn't support HTTP cookies).",
          "createdAt": "2019-10-04T19:21:11Z",
          "updatedAt": "2019-10-04T19:21:11Z"
        },
        {
          "author": "flano-yuki",
          "authorAssociation": "NONE",
          "body": "I misunderstood the URI schema as that of QuicTransport itself \ud83d\ude47 \r\nYour kind explanation made me understand.\r\n\r\nthanks ",
          "createdAt": "2019-10-05T14:09:47Z",
          "updatedAt": "2019-10-05T14:09:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDY2Mzkx",
          "commit": {
            "abbreviatedOid": "c22d4b2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I like the new concept, comments are mostly minor",
          "createdAt": "2019-10-03T18:29:13Z",
          "updatedAt": "2019-10-03T18:37:30Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "To get this to turn into a link, I think you want `{{QUIC-TRANSPORT}}` with a definition similar to what's in draft-ietf-quic-tls.",
              "createdAt": "2019-10-03T18:29:13Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            },
            {
              "originalPosition": 19,
              "body": "Is endpoint a defined term in IETF land?",
              "createdAt": "2019-10-03T18:29:49Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            },
            {
              "originalPosition": 32,
              "body": "I'd personally prefer `wq-01` to match the QUIC docs",
              "createdAt": "2019-10-03T18:30:21Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            },
            {
              "originalPosition": 32,
              "body": "I'm confused by this MUST NOT establish - if the server rejects the value it fails the handshake and closes the connection right?",
              "createdAt": "2019-10-03T18:31:09Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            },
            {
              "originalPosition": 39,
              "body": "I wouldn't call this a handshake message because it could be interpreted as meaning QUIC/TLS handshake",
              "createdAt": "2019-10-03T18:31:40Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            },
            {
              "originalPosition": 50,
              "body": "QUIC notation is in bits, not bytes. Also, can't we make these varints?",
              "createdAt": "2019-10-03T18:32:25Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            },
            {
              "originalPosition": 43,
              "body": "We probably need a way to convey the end of the sequence. For example\r\n- number of pairs up front\r\n- total length up front\r\n- FIN sent after the last one",
              "createdAt": "2019-10-03T18:33:44Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            },
            {
              "originalPosition": 73,
              "body": "It's probably simplest to ban duplicate keys like QUIC transport parameters, as this flexibility adds risk",
              "createdAt": "2019-10-03T18:34:25Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            },
            {
              "originalPosition": 93,
              "body": "How is the origin encoded? (see RFC6454 section 6)",
              "createdAt": "2019-10-03T18:36:08Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDcxOTMw",
          "commit": {
            "abbreviatedOid": "c22d4b2"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T18:39:06Z",
          "updatedAt": "2019-10-03T18:39:06Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "It's already a link, though.",
              "createdAt": "2019-10-03T18:39:06Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDcyMjg5",
          "commit": {
            "abbreviatedOid": "c22d4b2"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T18:39:44Z",
          "updatedAt": "2019-10-03T18:39:45Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Well, quic-transport-23 defines it and uses it 460 times.",
              "createdAt": "2019-10-03T18:39:45Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg0NjQ4",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:01:30Z",
          "updatedAt": "2019-10-03T19:01:30Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I actually changed it to `wq-vvv-01`, since this is not a WG draft.",
              "createdAt": "2019-10-03T19:01:30Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg0ODY5",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:01:55Z",
          "updatedAt": "2019-10-03T19:01:55Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I changed it to \"MUST close\".  FWIW, this is just a restatement of quic-transport requirement.",
              "createdAt": "2019-10-03T19:01:55Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg0OTc0",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:02:06Z",
          "updatedAt": "2019-10-03T19:02:06Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Removed word \"handshake\".",
              "createdAt": "2019-10-03T19:02:06Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg1NTkw",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:03:07Z",
          "updatedAt": "2019-10-03T19:03:07Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Fixed the bytes one.  I've considered making those varints, but my concern was that not all QUIC libraries expose the varint parser to the applications, thus making this potentially harder to implement.",
              "createdAt": "2019-10-03T19:03:07Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg1ODM4",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:03:33Z",
          "updatedAt": "2019-10-03T19:03:33Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "It's meant to be FIN.  Spelled this out more clearly.",
              "createdAt": "2019-10-03T19:03:33Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg1OTAy",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:03:39Z",
          "updatedAt": "2019-10-03T19:03:40Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Done.",
              "createdAt": "2019-10-03T19:03:39Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg1OTc5",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:03:49Z",
          "updatedAt": "2019-10-03T19:03:49Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "I already say that below.",
              "createdAt": "2019-10-03T19:03:49Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg4OTkz",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:09:28Z",
          "updatedAt": "2019-10-03T19:09:28Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Huh, weird",
              "createdAt": "2019-10-03T19:09:28Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg5MjQy",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:09:52Z",
          "updatedAt": "2019-10-03T19:09:53Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "SGTM",
              "createdAt": "2019-10-03T19:09:53Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDg5NjU1",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:10:40Z",
          "updatedAt": "2019-10-03T19:10:40Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Varints take about 10 lines of code to implement, I think they're worth the flexibility",
              "createdAt": "2019-10-03T19:10:40Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MDkzMTA2",
          "commit": {
            "abbreviatedOid": "5751e2d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:17:12Z",
          "updatedAt": "2019-10-03T19:17:13Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Where? Section 6 of RFC6454 proposes multiple different encodings",
              "createdAt": "2019-10-03T19:17:12Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MTAyMzk3",
          "commit": {
            "abbreviatedOid": "4f8edd5"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-03T19:35:01Z",
          "updatedAt": "2019-10-03T19:35:02Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Ah, good point.  Clarified that.",
              "createdAt": "2019-10-03T19:35:01Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MjY5NDU3",
          "commit": {
            "abbreviatedOid": "4f8edd5"
          },
          "author": "flano-yuki",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-04T05:31:41Z",
          "updatedAt": "2019-10-04T05:31:41Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I think variable length fields are indicated by an asterisk\r\n(as https://quicwg.org/base-drafts/draft-ietf-quic-transport.html#notational-conventions",
              "createdAt": "2019-10-04T05:31:41Z",
              "updatedAt": "2019-10-04T19:07:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3NjY2MDc4",
          "commit": {
            "abbreviatedOid": "eeaac8c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-04T19:08:30Z",
          "updatedAt": "2019-10-04T19:08:31Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Indeed.  Thanks for pointing this out.",
              "createdAt": "2019-10-04T19:08:30Z",
              "updatedAt": "2019-10-04T19:08:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMyMjc2ODQ4",
      "title": "Add a URL scheme requirement",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/5",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This defines a new URL scheme for QuicTransport, and clarifies the use\r\nof \"https\" for Http3Transport.",
      "createdAt": "2019-10-24T23:08:21Z",
      "updatedAt": "2019-10-25T22:24:47Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "master",
      "baseRefOid": "cddcd8a7f206065b01ceb4951927fb3cda72fa43",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "url-scheme",
      "headRefOid": "ff7276c3d55df0593e65eae5e2a3dac5ae615ce8",
      "closedAt": "2019-10-25T22:24:47Z",
      "mergedAt": "2019-10-25T22:24:47Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "7506e4c3ea2ffa4819286b9b404d67773ff55dfe"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTExODMw",
          "commit": {
            "abbreviatedOid": "e004b71"
          },
          "author": "pthatcherg",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T23:09:58Z",
          "updatedAt": "2019-10-24T23:12:39Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "transprot => transport",
              "createdAt": "2019-10-24T23:09:58Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 22,
              "body": "path-abempty is never used in the ABNF below.",
              "createdAt": "2019-10-24T23:10:57Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 45,
              "body": "This note would be a little more clear if moved up 1 paragraph.",
              "createdAt": "2019-10-24T23:12:29Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTE0MDEw",
          "commit": {
            "abbreviatedOid": "e004b71"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T23:18:01Z",
          "updatedAt": "2019-10-24T23:18:20Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Fixed here and in another place I made the same typo.",
              "createdAt": "2019-10-24T23:18:01Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 22,
              "body": "Fixed.",
              "createdAt": "2019-10-24T23:18:09Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 45,
              "body": "Done.",
              "createdAt": "2019-10-24T23:18:14Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTEyMTQ4",
          "commit": {
            "abbreviatedOid": "e004b71"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-10-24T23:11:04Z",
          "updatedAt": "2019-10-24T23:18:44Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "nit: I'd say HTTP/3 because not all versions of HTTP require TLS",
              "createdAt": "2019-10-24T23:11:04Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 19,
              "body": "typo: transprot",
              "createdAt": "2019-10-24T23:11:23Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 22,
              "body": "I think you want `{{CSP}}` to make sure the links work in all output formats",
              "createdAt": "2019-10-24T23:12:08Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 5,
              "body": "nit: extra space before {",
              "createdAt": "2019-10-24T23:12:27Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 18,
              "body": "uses *the* ...",
              "createdAt": "2019-10-24T23:12:53Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 22,
              "body": "`path-abempty` is defined but not used",
              "createdAt": "2019-10-24T23:13:28Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 32,
              "body": "typo abemtpy ?",
              "createdAt": "2019-10-24T23:14:14Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 35,
              "body": "add: and MUST NOT send non-empty values",
              "createdAt": "2019-10-24T23:14:59Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 42,
              "body": "I don't think we've defined what a user is. Perhaps replace this with `If the port value is 0, the user agent MUST fail the connection attempt immediately.`",
              "createdAt": "2019-10-24T23:17:20Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            },
            {
              "originalPosition": 47,
              "body": "Remove this sentence, as IANA won't allocate one until we ask.",
              "createdAt": "2019-10-24T23:18:04Z",
              "updatedAt": "2019-10-24T23:53:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTIzMzk1",
          "commit": {
            "abbreviatedOid": "ff7276c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T23:55:15Z",
          "updatedAt": "2019-10-24T23:55:15Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "I'm not sure what you mean here.  We do not provide any way to send those in the protocol.",
              "createdAt": "2019-10-24T23:55:15Z",
              "updatedAt": "2019-10-24T23:55:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTIzNTM3",
          "commit": {
            "abbreviatedOid": "ff7276c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T23:55:48Z",
          "updatedAt": "2019-10-24T23:55:48Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I think I've defined `client` to mean what I meant here, so I just replaced it with that.",
              "createdAt": "2019-10-24T23:55:48Z",
              "updatedAt": "2019-10-24T23:55:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTIzNjc2",
          "commit": {
            "abbreviatedOid": "ff7276c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T23:56:27Z",
          "updatedAt": "2019-10-24T23:56:27Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I'm not entirely sure what the difference here is, but it seems to work either way.",
              "createdAt": "2019-10-24T23:56:27Z",
              "updatedAt": "2019-10-24T23:56:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTI0MjQ4",
          "commit": {
            "abbreviatedOid": "ff7276c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T23:58:54Z",
          "updatedAt": "2019-10-24T23:58:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Apparently I've not been consistent about those.  Changed to two spaces everywhere for consistency.",
              "createdAt": "2019-10-24T23:58:54Z",
              "updatedAt": "2019-10-24T23:58:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTU2ODIz",
          "commit": {
            "abbreviatedOid": "ff7276c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T02:39:53Z",
          "updatedAt": "2019-10-25T02:39:53Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Good point.",
              "createdAt": "2019-10-25T02:39:53Z",
              "updatedAt": "2019-10-25T02:39:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTY5MDg1",
          "commit": {
            "abbreviatedOid": "ff7276c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-25T03:41:09Z",
          "updatedAt": "2019-10-25T03:43:54Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Might as well be consistent and use `{{`",
              "createdAt": "2019-10-25T03:41:56Z",
              "updatedAt": "2019-10-25T03:43:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3MzY1NDcw",
          "commit": {
            "abbreviatedOid": "ff7276c"
          },
          "author": "pthatcherg",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-25T18:02:14Z",
          "updatedAt": "2019-10-25T18:02:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM0NDczNzIz",
      "title": "Add support for path and query in QuicTransport URIs.",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/6",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-10-30T19:35:55Z",
      "updatedAt": "2019-10-31T18:22:45Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "master",
      "baseRefOid": "7506e4c3ea2ffa4819286b9b404d67773ff55dfe",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "uri-path",
      "headRefOid": "09cd2b18275ad3afc091a9938f678e9038d74c78",
      "closedAt": "2019-10-31T18:22:45Z",
      "mergedAt": "2019-10-31T18:22:45Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "950282754dde74032945d42fa913fb62c325589d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NDk3NjEz",
          "commit": {
            "abbreviatedOid": "8161cdf"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-30T20:25:25Z",
          "updatedAt": "2019-10-30T20:26:25Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "typo: followed by",
              "createdAt": "2019-10-30T20:25:25Z",
              "updatedAt": "2019-10-31T18:21:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 7,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1NjI0Mzc0",
      "title": "dschinazi editorial pass on overview",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/7",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-01T21:29:39Z",
      "updatedAt": "2019-11-03T22:22:31Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "master",
      "baseRefOid": "f0cc5755b330b3a18720bea5084b3cb1653f3f28",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "ds_editorial_overview",
      "headRefOid": "55a0b1303183e5bb2cbfd7a2d92d5eefd3d6af26",
      "closedAt": "2019-11-03T22:16:49Z",
      "mergedAt": "2019-11-03T22:16:49Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "8df84701de43933fcf3735310fba37ecf3a57cb4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzA3MDUy",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T21:35:13Z",
          "updatedAt": "2019-11-01T21:42:08Z",
          "comments": [
            {
              "originalPosition": 330,
              "body": "I think \"HTTP-based authentication\" does not actually include all of the things that we want to not support (e.g. prompt-based client auth).",
              "createdAt": "2019-11-01T21:35:13Z",
              "updatedAt": "2019-11-01T21:42:08Z"
            },
            {
              "originalPosition": 281,
              "body": "I was actually mostly worried about stream data.",
              "createdAt": "2019-11-01T21:35:38Z",
              "updatedAt": "2019-11-01T21:42:08Z"
            },
            {
              "originalPosition": 145,
              "body": "That's a transport property.  The feature I was trying to define here are \"supports streams\" and \"support datagrams\".",
              "createdAt": "2019-11-01T21:40:55Z",
              "updatedAt": "2019-11-01T21:42:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzUxMTI0",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-02T02:11:23Z",
          "updatedAt": "2019-11-02T02:11:24Z",
          "comments": [
            {
              "originalPosition": 330,
              "body": "What do you mean by \"prompt-based client auth\" ? What non-HTTP-based authentications are there?",
              "createdAt": "2019-11-02T02:11:24Z",
              "updatedAt": "2019-11-02T02:11:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzUxMTU5",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-02T02:12:01Z",
          "updatedAt": "2019-11-02T02:12:02Z",
          "comments": [
            {
              "originalPosition": 281,
              "body": "Nagle has value, I don't think we should argue against Nagle without a more detailed explanation",
              "createdAt": "2019-11-02T02:12:02Z",
              "updatedAt": "2019-11-02T02:12:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzUxMjYx",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-02T02:14:10Z",
          "updatedAt": "2019-11-02T02:14:11Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "I don't understand the difference",
              "createdAt": "2019-11-02T02:14:11Z",
              "updatedAt": "2019-11-02T02:14:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODQyOTg4",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-03T22:06:51Z",
          "updatedAt": "2019-11-03T22:06:51Z",
          "comments": [
            {
              "originalPosition": 330,
              "body": "TLS client auth (the one where user gets a prompt).",
              "createdAt": "2019-11-03T22:06:51Z",
              "updatedAt": "2019-11-03T22:06:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODQzMzc5",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-03T22:13:54Z",
          "updatedAt": "2019-11-03T22:13:55Z",
          "comments": [
            {
              "originalPosition": 281,
              "body": "Nagle does have value, and I'm pretty sure it's negative for ~all latency-sensitive applications we're targeting with this, at least without explicit controls.",
              "createdAt": "2019-11-03T22:13:55Z",
              "updatedAt": "2019-11-03T22:13:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODQzNzgz",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-03T22:21:06Z",
          "updatedAt": "2019-11-03T22:21:06Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "It's a difference between \"what you can do with transport\" and \"how the transport will do it\".  I agree it's not clear, so I just deleted that definition from the list.",
              "createdAt": "2019-11-03T22:21:06Z",
              "updatedAt": "2019-11-03T22:21:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODQzODA5",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-03T22:21:36Z",
          "updatedAt": "2019-11-03T22:21:37Z",
          "comments": [
            {
              "originalPosition": 281,
              "body": "Not all streams are latency-sensitive in a latency-sensitive application though",
              "createdAt": "2019-11-03T22:21:36Z",
              "updatedAt": "2019-11-03T22:21:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODQzODY0",
          "commit": {
            "abbreviatedOid": "55a0b13"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-03T22:22:30Z",
          "updatedAt": "2019-11-03T22:22:31Z",
          "comments": [
            {
              "originalPosition": 330,
              "body": "WebTransport runs over TLS or QUIC so it has no reason not to support TLS client auth?",
              "createdAt": "2019-11-03T22:22:30Z",
              "updatedAt": "2019-11-03T22:22:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 8,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1NjMzNTUz",
      "title": "dschinazi editorial pass on QuicTransport",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/8",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-01T21:56:59Z",
      "updatedAt": "2019-11-03T22:35:17Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "master",
      "baseRefOid": "f0cc5755b330b3a18720bea5084b3cb1653f3f28",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "ds_editorial_quic",
      "headRefOid": "d98124f2a293b6ae22fee4f6b74a36116f830ff2",
      "closedAt": "2019-11-03T22:35:17Z",
      "mergedAt": "2019-11-03T22:35:17Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "8304e2c0d84735d33bb37bc03e7d9e65a7b96c23"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzE5OTQ3",
          "commit": {
            "abbreviatedOid": "77e4e63"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Please bring the backticks back.",
          "createdAt": "2019-11-01T22:17:21Z",
          "updatedAt": "2019-11-01T22:21:43Z",
          "comments": [
            {
              "originalPosition": 296,
              "body": "QuicTransport ALPN value",
              "createdAt": "2019-11-01T22:17:21Z",
              "updatedAt": "2019-11-03T00:51:05Z"
            },
            {
              "originalPosition": 21,
              "body": "I actually have trouble understanding this sentence now.",
              "createdAt": "2019-11-01T22:21:05Z",
              "updatedAt": "2019-11-03T00:51:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzk1MDEy",
          "commit": {
            "abbreviatedOid": "d98124f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-03T00:51:23Z",
          "updatedAt": "2019-11-03T00:51:24Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Fixed",
              "createdAt": "2019-11-03T00:51:23Z",
              "updatedAt": "2019-11-03T00:51:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwNzk1MDEz",
          "commit": {
            "abbreviatedOid": "d98124f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-03T00:51:30Z",
          "updatedAt": "2019-11-03T00:51:30Z",
          "comments": [
            {
              "originalPosition": 296,
              "body": "Fixed",
              "createdAt": "2019-11-03T00:51:30Z",
              "updatedAt": "2019-11-03T00:51:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1OTgzNzg1",
      "title": "dschinazi editorial pass on Http3Transport",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/9",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-03T01:48:54Z",
      "updatedAt": "2019-11-03T22:40:49Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "master",
      "baseRefOid": "f0cc5755b330b3a18720bea5084b3cb1653f3f28",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "ds_editorial_h3",
      "headRefOid": "ca177b74cfc969e47665410a2a2888ff7cf87840",
      "closedAt": "2019-11-03T22:40:49Z",
      "mergedAt": "2019-11-03T22:40:49Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "41cdacc0b477c2f43d761538327720660c60097f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc5Njg1NTIy",
      "title": "Refactor client indication into a full header exchange",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/18",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We currently use 16-bit integers for header names.  There probably won't\r\never be more than 65,000 headers, but this does not let users add their\r\nown custom headers easily.  Thus, this commit changes uint16 to string.\r\n\r\nWe currently provide a way for a server to explicitly reject client's\r\norigin, but no way to explicitly accept it.  This commit solves this by\r\nturning the client indication stream into a bidirectional handshake\r\nstream.  Server confirms the handshake by sending a FIN on its end of\r\nthe handshake stream.",
      "createdAt": "2020-09-04T13:26:39Z",
      "updatedAt": "2020-09-23T20:22:43Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "master",
      "baseRefOid": "77936a2df618dfa4d10c8f73d05acf7dfb40ba14",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "bidi-headers",
      "headRefOid": "2c92455b066d42767a554f87b998adb46ba1e2ea",
      "closedAt": "2020-09-23T20:22:43Z",
      "mergedAt": "2020-09-23T20:22:43Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "f36ba9e4a8de56f2fc418eca9416c9828325e41a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNzY0MjYz",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-04T15:45:21Z",
          "updatedAt": "2020-09-04T16:16:47Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "The QuicTransport Header is very similar to HTTP/3 SETTINGS because it is an object that can contain a sequence of key-value pairs. I think it would help to present the QuicTransport Header in a similar way as in https://tools.ietf.org/html/draft-ietf-quic-http-29#section-7.2.4\r\n\r\nFor instance\r\n\r\n```\r\nHeader {\r\n     Header Name Length (16),\r\n     Header Name (..),\r\n     Header Value Length (16),\r\n     Header Value (..),\r\n}\r\n\r\nQuicTransport Headers {\r\n     Header (..) ...,\r\n   }\r\n```",
              "createdAt": "2020-09-04T15:48:49Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            },
            {
              "originalPosition": 115,
              "body": "Given the bulleted description of the handshake and this section, it is a little unclear what you expect the server to do. For instance, consider a client cannot send the complete block because the server's initial bidi flow control window is too small. Is the expectation that a Server Application will read data from the QUIC stream (giving flow control credit back to client) and buffer the block in the application layer until the client completes? \r\n\r\nIt seems unfortunate if a client can force a server to buffer up to 1,048,576 bytes. Yes the server can hangup, but it would have to wait until the application-imposed limit was reached. It might be healthier for the block to begin with a total length field. That allows a server to early abort.",
              "createdAt": "2020-09-04T16:13:48Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            },
            {
              "originalPosition": 145,
              "body": "With the current format and defined fields, this means just sending an empty STREAM frame with FIN?",
              "createdAt": "2020-09-04T16:16:33Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDc5OTUw",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "kixelated",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T20:44:58Z",
          "updatedAt": "2020-09-08T20:54:57Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "How does the client know that a connection close was due to an unaccepted origin? If it receives a CONNECTION_CLOSE prior to receiving a FIN on stream 0?\r\n\r\nThe problem is that there are many sources of CONNECTION_CLOSE errors. The server could close the connection due to an invalid path or it just decided to immediately terminate the connection. In either case, the client will receive a QUIC application close and will incorrectly assume that it was due to an invalid origin.\r\n\r\nTo correctly identify invalid origins, there should be an explicit and retransmitted signal. Either an \"invalid origin\" response message (on stream 0)  or CONNECTION_CLOSE error code.",
              "createdAt": "2020-09-08T20:44:59Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NTA0NjQ1",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T21:27:22Z",
          "updatedAt": "2020-09-08T21:27:22Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "You could also abort the stream with a RESET_STREAM in this case. That way you wouldn't even need an error code (although it would help) in order to detect the case where the origin exchange is pass/fail.",
              "createdAt": "2020-09-08T21:27:22Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NTE3MzY4",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "kixelated",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-08T21:52:19Z",
          "updatedAt": "2020-09-08T21:52:19Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Yeah, `RESET_STREAM` would be nice with or without error codes. It's better than CONNECTION_CLOSE because it can be reliable and does not infringe upon the application error code space.",
              "createdAt": "2020-09-08T21:52:19Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NDY0Njgy",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I think that we should stay as close to HTTP headers as possible here, to simplify the relationship between QuicTransport and HttpTransport. We could then say that JavaScript MUST NOT be able to set headers that start with a colon to enforce a separation in the namespace.",
          "createdAt": "2020-09-09T23:17:23Z",
          "updatedAt": "2020-09-09T23:22:12Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Why is this more restrictive than HTTP headers? Couldn't we use the same rules as HTTP/2 headers for simplicity?",
              "createdAt": "2020-09-09T23:17:23Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            },
            {
              "originalPosition": 105,
              "body": "Additional implementation-specific limits can lead to interop issues. Could we instead say that servers MUST accept headers up to that length?",
              "createdAt": "2020-09-09T23:18:42Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            },
            {
              "originalPosition": 210,
              "body": "Could we instead use the HTTP headers registry?",
              "createdAt": "2020-09-09T23:20:53Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5NjI1MDU3",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "yutakahirano",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T13:28:48Z",
          "updatedAt": "2020-09-16T13:29:50Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Shouldn't this be lower-cased?",
              "createdAt": "2020-09-16T13:28:49Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            },
            {
              "originalPosition": 157,
              "body": "Shouldn't this be lower-cased?",
              "createdAt": "2020-09-16T13:29:04Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDUzMTk0",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:06:49Z",
          "updatedAt": "2020-09-16T22:06:50Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "I don't believe anything in the current text of the PR precludes the server from processing headers as they come in, and, say, rejecting based on incorrect origin as soon as it parses the origin.  The requirement is to not _accept_ the headers until they're complete.\r\n\r\nWe could add a size in front, but this would have a downside of forcing the client to buffer all of the headers to compute the size in advance.",
              "createdAt": "2020-09-16T22:06:49Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDUzMjM3",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:06:56Z",
          "updatedAt": "2020-09-16T22:06:57Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Correct.",
              "createdAt": "2020-09-16T22:06:56Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDU1MTYx",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:11:07Z",
          "updatedAt": "2020-09-16T22:11:08Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "This is actually based on [the most restrictive interpretation of HTTP header name restrictions](https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#rfc.section.5.3.p.6).",
              "createdAt": "2020-09-16T22:11:07Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDU1NTc5",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:12:08Z",
          "updatedAt": "2020-09-16T22:12:09Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "We could, but in practice implementations will inevitable impose their own limit, and we can't preemptively enforce this, so I don't think it makes sense.",
              "createdAt": "2020-09-16T22:12:08Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDYxNzY4",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:26:25Z",
          "updatedAt": "2020-09-16T22:26:26Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "The ambiguity here is \" MUST NOT process any application data before receiving the entirety of the headers\". Its ambiguous because this is an application mapping and its all application data. I think what you mean is that the server MUST not process any received data on streams other than 0, or process any datagrams.\r\n\r\nBased on the defined fields so far, I don't see needing a length upfront as a real problem for clients. HTTP/2 and HTTP/3 require a length in HEADERS. What use case really needs such client behaviour?",
              "createdAt": "2020-09-16T22:26:26Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDYyNDEz",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:27:52Z",
          "updatedAt": "2020-09-16T22:27:52Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "I'm a bit weary of that because the \"Internet Message Header\" registry is currently already overloaded, and from what I understand it's currently being reorganized, so I would wait here.",
              "createdAt": "2020-09-16T22:27:52Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDYyOTAy",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:29:02Z",
          "updatedAt": "2020-09-16T22:29:03Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "I'm following the HTTP convention here where headers look like \"Content-Type\", even though on the wire, HTTP/2 and HTTP/3 encode those as all-lowercase.",
              "createdAt": "2020-09-16T22:29:02Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDYyOTM5",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:29:06Z",
          "updatedAt": "2020-09-16T22:29:07Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "I'm following the HTTP convention here where headers look like \"Content-Type\", even though on the wire, HTTP/2 and HTTP/3 encode those as all-lowercase.",
              "createdAt": "2020-09-16T22:29:07Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDY0MTYz",
          "commit": {
            "abbreviatedOid": "28ce14c"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:32:06Z",
          "updatedAt": "2020-09-16T22:32:06Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "This seems just like the setting for MAX_HEADER_LIST size. Unfortunately that setting has legacy baggage from decades of HTTP deployment. It seems with a new application protocol, the server could defe a limit thats enforceable. That helps cut down the memory commitment and is interoperable. Exchanging such a setting might require something ALPS-like though.",
              "createdAt": "2020-09-16T22:32:06Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDY4MzAy",
          "commit": {
            "abbreviatedOid": "4cb570f"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-16T22:42:42Z",
          "updatedAt": "2020-09-16T22:42:42Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Oooh, that's an interesting syntax. Done.",
              "createdAt": "2020-09-16T22:42:42Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMTM0NDY5",
          "commit": {
            "abbreviatedOid": "4cb570f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-17T00:26:48Z",
          "updatedAt": "2020-09-17T00:26:48Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "I do think that we should resolve those potential interop issues - and we can enforce this by using padding right?",
              "createdAt": "2020-09-17T00:26:48Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMTM2NTY5",
          "commit": {
            "abbreviatedOid": "4cb570f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-17T00:28:13Z",
          "updatedAt": "2020-09-17T00:28:14Z",
          "comments": [
            {
              "originalPosition": 210,
              "body": "I'm not sure if I understand why the reorganization of [the registry](https://www.iana.org/assignments/message-headers/message-headers.xhtml) would cause us to not use it",
              "createdAt": "2020-09-17T00:28:13Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMTM4Mjkw",
          "commit": {
            "abbreviatedOid": "4cb570f"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-17T00:29:20Z",
          "updatedAt": "2020-09-17T00:29:21Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "I think sticking to HTTP semantics would be best. Adding a reference to that link SGTM as a way to suggest folks use this subset.",
              "createdAt": "2020-09-17T00:29:21Z",
              "updatedAt": "2020-09-22T23:27:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzOTEzNDA5",
          "commit": {
            "abbreviatedOid": "2c92455"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T23:30:26Z",
          "updatedAt": "2020-09-22T23:30:26Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Re ambiguity, thanks for pointing this out! This should be fixed.\r\n\r\nRe header size, I agree we should do something about this, but not sure I like explicit size, given that it's redundant otherwise.  HTTP/2 and HTTP/3 do always have size, but that's because neither sends headers on a dedicated stream, so they need header block size for delineation.  I've filed #20 to track this.",
              "createdAt": "2020-09-22T23:30:26Z",
              "updatedAt": "2020-09-22T23:30:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzOTEzNTk3",
          "commit": {
            "abbreviatedOid": "2c92455"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-22T23:30:55Z",
          "updatedAt": "2020-09-22T23:30:56Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "I don't think we want to send one megabyte worth of padding.  I've filed #20 to track this.",
              "createdAt": "2020-09-22T23:30:55Z",
              "updatedAt": "2020-09-22T23:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1MDE4OTAz",
          "commit": {
            "abbreviatedOid": "2c92455"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T20:22:21Z",
          "updatedAt": "2020-09-23T20:22:21Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Those are good points.  I wrote my thoughts on them in #15 ",
              "createdAt": "2020-09-23T20:22:21Z",
              "updatedAt": "2020-09-23T20:22:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE4MDc0NDE1",
      "title": "Update WebTransport over HTTP/3 to be more in sync with HTTP/2",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/21",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This replaces a distinct Session ID mechanism with using stream ID of\r\nthe CONNECT stream as a Session ID.\r\n\r\nThe transport parameter used to opt into WebTransport is replaced with\r\na SETTINGS value.",
      "createdAt": "2020-11-09T22:20:53Z",
      "updatedAt": "2021-01-20T19:52:20Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "master",
      "baseRefOid": "79723d48c9a955dcf5a450c29d0bfe9bc35dbd1b",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "h3-update",
      "headRefOid": "0935b9843c73d58566a01b695198d47ae2165ff8",
      "closedAt": "2021-01-20T19:52:20Z",
      "mergedAt": "2021-01-20T19:52:20Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "7ed396b083c090b310c253b6d784746ab048172a"
      },
      "comments": [
        {
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "body": "I was reviewing the H2 WT draft, and I now wonder if \"connect stream\" is really the best terminology.  Is \"session stream\" more representative of what it is -- a stream that represents the WebTransport Session?  CONNECT just happens to be the method used to open the stream.",
          "createdAt": "2020-11-11T00:12:39Z",
          "updatedAt": "2020-11-11T00:12:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzAzODQ3",
          "commit": {
            "abbreviatedOid": "b63defd"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-09T22:24:08Z",
          "updatedAt": "2020-11-09T22:26:29Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "The text mentions QUIC DATAGRAMs but this reference is h3 DATAGRAMS - I think the distinction is important",
              "createdAt": "2020-11-09T22:24:09Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            },
            {
              "originalPosition": 146,
              "body": "This goes against the design of draft-schinazi-quic-h3-datagram. Should we use the same mechanism as CONNECT-UDP to allow multiplexing CONNECT-UDP and WebTransport over the same h3 connection?",
              "createdAt": "2020-11-09T22:25:52Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            },
            {
              "originalPosition": 178,
              "body": "Can we pick a value in the 4-byte encoding range to allow folks to test interop?",
              "createdAt": "2020-11-09T22:26:25Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzMzODky",
          "commit": {
            "abbreviatedOid": "8f49cbd"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-09T23:22:31Z",
          "updatedAt": "2020-11-09T23:22:32Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "We should!  Wanna update CONNECT-UDP draft to use stream IDs?",
              "createdAt": "2020-11-09T23:22:32Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzM0MDIz",
          "commit": {
            "abbreviatedOid": "8f49cbd"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-09T23:22:49Z",
          "updatedAt": "2020-11-09T23:22:49Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "note that this is the 8-byte encoding not 4-byte :) Also please add the value to the [registry](https://github.com/quicwg/base-drafts/wiki/Temporary-IANA-Registry)",
              "createdAt": "2020-11-09T23:22:49Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzM0NDkz",
          "commit": {
            "abbreviatedOid": "8f49cbd"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-09T23:23:55Z",
          "updatedAt": "2020-11-09T23:23:55Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "No, CONNECT-UDP relies on having separate namespaces for streams and DATAGRAM flow IDs. This feature is used by [the quic-proxy extension](https://tools.ietf.org/html/draft-pauly-masque-quic-proxy-00)",
              "createdAt": "2020-11-09T23:23:55Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzM4NzAz",
          "commit": {
            "abbreviatedOid": "8f49cbd"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-09T23:33:10Z",
          "updatedAt": "2020-11-09T23:33:10Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "I think it would be ok to have the same flow ID vendor work independent of the semantic usage of the connected stream right?",
              "createdAt": "2020-11-09T23:33:10Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzQ3Mzk5",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-09T23:53:04Z",
          "updatedAt": "2020-11-09T23:53:05Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "I am not convinced CONNECT-UDP actually relies on this property, at least the draft you link does not seem to explicitly discuss why that is required.",
              "createdAt": "2020-11-09T23:53:04Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzUxMjEy",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-10T00:02:34Z",
          "updatedAt": "2020-11-10T00:02:35Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "@vasilvv I think you're asking a similar question to the one I posed on https://github.com/ietf-wg-masque/draft-ietf-masque-connect-udp/issues/16",
              "createdAt": "2020-11-10T00:02:34Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2Nzc1MDg5",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-10T01:04:14Z",
          "updatedAt": "2020-11-10T01:04:15Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "@vasilvv if you look at the [Example section](https://tools.ietf.org/html/draft-pauly-masque-quic-proxy-00#section-6) you'll see that multiple CONNECT-UDP requests with this extension can share a flow ID",
              "createdAt": "2020-11-10T01:04:14Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2Nzk0NDY2",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-10T01:55:17Z",
          "updatedAt": "2020-11-10T01:55:18Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "I read that, I just don't see why they need to share it.",
              "createdAt": "2020-11-10T01:55:17Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2ODAwODgy",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-10T02:14:05Z",
          "updatedAt": "2020-11-10T02:14:05Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "It's about shared lifetimes - it allows multiple requests to come and go and the underlying flow ID to remain valid - otherwise as the older flow IDs get removed you could end up with dropped datagrams. This also allows using smaller encodings for flow ID varints which adds up over time",
              "createdAt": "2020-11-10T02:14:05Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2ODkzMzM1",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-10T06:31:09Z",
          "updatedAt": "2020-11-10T06:31:09Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "I'm confused.  You have to keep the stream up for the duration of associated connection ID's lifetime anyways, since once the stream is gone, so are the mappings.\r\n\r\nDoes the varint thing matter?  I thought the entire point of draft-pauly-masque-quic-proxy is to bring 99% of the traffic outside the DATAGRAMs.",
              "createdAt": "2020-11-10T06:31:09Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NTM1Mzgw",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-10T19:24:32Z",
          "updatedAt": "2020-11-10T19:24:33Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "You keep the stream open for its part of the mapping, but you can think of the flow ID as being reference counted by all the streams that use it.\r\n\r\nConceptually, HTTP/3 DATAGRAM Flow IDs have their own namespace similar to how HTTP/3 Push IDs have their own namespace distinct from the Stream ID namespace.",
              "createdAt": "2020-11-10T19:24:33Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI3NjU0OTYz",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-10T22:20:36Z",
          "updatedAt": "2020-11-10T22:20:37Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "This all sounds like unnecessary complexity to me.  If you don't keep separate flow IDs, you don't need to reference-count them in first place.",
              "createdAt": "2020-11-10T22:20:36Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5MDEzNDg3",
          "commit": {
            "abbreviatedOid": "de5fdc2"
          },
          "author": "ianswett",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks Victor, switching to SETTINGs definitely makes sense.  Let's all talk about flow Ids sometime as well.",
          "createdAt": "2021-01-15T07:42:45Z",
          "updatedAt": "2021-01-15T07:48:46Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nsend a SETTINGS_ENABLE_WEBTRANSPORT setting in order to indicate that they\r\n```\r\n\r\nI'd argue H3 settings aren't really negotiated.",
              "createdAt": "2021-01-15T07:42:45Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            },
            {
              "originalPosition": 146,
              "body": "Let's talk about this on VC sometime, since I'd like to walk through all the pros and cons here.",
              "createdAt": "2021-01-15T07:48:15Z",
              "updatedAt": "2021-01-20T19:44:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyNTcwMTAz",
          "commit": {
            "abbreviatedOid": "0935b98"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-20T19:44:33Z",
          "updatedAt": "2021-01-20T19:44:33Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "Let's merge this as-is for now, and update when with have consensus in the h3datagram draft.",
              "createdAt": "2021-01-20T19:44:33Z",
              "updatedAt": "2021-01-20T19:44:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU5Nzc4MTA2",
      "title": "Add negotiation for pooling support",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/25",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-22T07:36:55Z",
      "updatedAt": "2021-07-28T22:32:39Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "1410f0de42c905511f3a6e91119b1d59ee01619e",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "negotiation",
      "headRefOid": "806411919eb82c199854e6fc69ffad8a92cd5abf",
      "closedAt": "2021-07-28T22:32:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A different way to design this would be to say that the setting advertises the maximum number of Http3Transport sessions that the endpoint is willing to support. The maximum number in any session is then the minimum of the client and server value. E.g. if either side sends 0, its off. If either side sends > 0 its on but pooling only works if both send > 1. ",
          "createdAt": "2021-01-26T01:36:09Z",
          "updatedAt": "2021-01-26T01:36:56Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@LPardue your design wouldn't allow a server to say \"I'd like either HTTP or WT, but not both on the same connection\" though, right?",
          "createdAt": "2021-01-26T01:49:04Z",
          "updatedAt": "2021-01-26T01:49:04Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, I might have enterd on the wrong axis of thinking about pooling as sharing one connection for WebTransport only, not mixing with conventional HTTP/3. Although, I'm not sure I follow how the proposal here satisfies the \"\"I'd like either HTTP or WT, but not both on the same connection\" either.",
          "createdAt": "2021-01-26T02:07:31Z",
          "updatedAt": "2021-01-26T02:07:31Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@LPardue In my understanding, this PR doesn't handle the \"I'd like either HTTP or WT, but not both on the same connection\" use-case. And I think that's what some folks were asking for.",
          "createdAt": "2021-01-26T02:38:07Z",
          "updatedAt": "2021-01-26T02:38:07Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "It sounds like calling C=2 \"exclusive\" was a mistake.  Renamed it.",
          "createdAt": "2021-01-27T18:59:17Z",
          "updatedAt": "2021-01-27T18:59:17Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Abandoning per discussion on #34.",
          "createdAt": "2021-07-28T22:32:39Z",
          "updatedAt": "2021-07-28T22:32:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1OTI5MTMy",
          "commit": {
            "abbreviatedOid": "3737f37"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I don't think this proposal works when the server sends its SETTINGS first",
          "createdAt": "2021-01-26T01:05:25Z",
          "updatedAt": "2021-01-26T01:15:08Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "```suggestion\r\n* Supported (\"1\") indicates that the server supports WebTransport over HTTP/3.\r\n```",
              "createdAt": "2021-01-26T01:05:25Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n* Supported (\"1\") indicates that the client supports WebTransport over HTTP/3\r\n```",
              "createdAt": "2021-01-26T01:05:41Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            },
            {
              "originalPosition": 12,
              "body": "We need to state somewhere that if SETTINGS_ENABLE_WEBTRANSPORT is not sent, its value is implicitly set to the default of 0.",
              "createdAt": "2021-01-26T01:10:16Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            },
            {
              "originalPosition": 37,
              "body": "This doesn't handle the case where client sends 0 and server sends 2. Why not simply say: if any endpoint sent 0 then WebTransport is not supported on this connection - which means clients MUST NOT send the special CONNECT request, and servers MUST fail it with a certain error.",
              "createdAt": "2021-01-26T01:12:08Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            },
            {
              "originalPosition": 56,
              "body": "What's the point of having the client tell the server whether it wants to be exclusive or not?",
              "createdAt": "2021-01-26T01:14:42Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NjU5NjEy",
          "commit": {
            "abbreviatedOid": "5e2d5ff"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T18:52:25Z",
          "updatedAt": "2021-01-26T18:52:26Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "No, it handles it with a connection error (third bullet point).",
              "createdAt": "2021-01-26T18:52:25Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NjYwMDM0",
          "commit": {
            "abbreviatedOid": "5e2d5ff"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T18:52:53Z",
          "updatedAt": "2021-01-26T18:52:53Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "It's not about whether it's exclusive or not, it's about whether the client intends to send a WebTransport request or not.",
              "createdAt": "2021-01-26T18:52:53Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NjYxMzYz",
          "commit": {
            "abbreviatedOid": "b53003a"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T18:54:32Z",
          "updatedAt": "2021-01-26T18:54:33Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Fixed.",
              "createdAt": "2021-01-26T18:54:32Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2Nzc0NjM4",
          "commit": {
            "abbreviatedOid": "b53003a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I still don't understand how this works. How does the server know what value to send?",
          "createdAt": "2021-01-26T21:25:57Z",
          "updatedAt": "2021-01-26T21:28:00Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\ndepends on which endpoint is sending the setting.\r\n```",
              "createdAt": "2021-01-26T21:25:57Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2NzgxOTM4",
          "commit": {
            "abbreviatedOid": "b53003a"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-26T21:36:19Z",
          "updatedAt": "2021-01-26T21:47:37Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Does this mean the client has to have a request in mind before sending the SETTING?  Is pre-connecting allowed?",
              "createdAt": "2021-01-26T21:36:19Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            },
            {
              "originalPosition": 42,
              "body": "Echoing @DavidSchinazi's earlier point -- this makes it challenging to run a web server and an exclusive-only web transport server on the same address/port.  The server can send SETTINGS in 0.5-RTT, and it won't know if the client is going to send 0 (HTTP) or 2 (WT).  Alternately, the server can wait to receive the client SETTINGS before sending its own, but that's suboptimal for other reasons.",
              "createdAt": "2021-01-26T21:43:42Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            },
            {
              "originalPosition": 42,
              "body": "Somewhat related is that there is a completely incompatible set of modes here -- C=1, S=2.  These clients can't talk at all, even if the client would prefer pooled connections but would settle for exclusive ones.",
              "createdAt": "2021-01-26T21:46:45Z",
              "updatedAt": "2021-01-27T18:41:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NjUxOTQx",
          "commit": {
            "abbreviatedOid": "8064119"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T18:46:24Z",
          "updatedAt": "2021-01-27T18:46:24Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Sure, as long as you're fine with the resulting connection being usable for a single WebTransport.",
              "createdAt": "2021-01-27T18:46:24Z",
              "updatedAt": "2021-01-27T18:46:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NjU2ODY4",
          "commit": {
            "abbreviatedOid": "8064119"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T18:52:25Z",
          "updatedAt": "2021-01-27T18:52:26Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I'm confused.  I don't think you can run a non-exclusive server and and exclusive server on the same port without multiplexing by something like ALPN.\r\n\r\nIf the client prefers pooled version, it can send C=1.  C=1, S=1 results in pooled WebTransport, C=1, S=2 results in exclusive WebTransport.",
              "createdAt": "2021-01-27T18:52:26Z",
              "updatedAt": "2021-01-27T18:52:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3NjYyOTUw",
          "commit": {
            "abbreviatedOid": "8064119"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-27T18:59:56Z",
          "updatedAt": "2021-01-27T18:59:57Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Per the text and the table, C=1, S=2 is an error.",
              "createdAt": "2021-01-27T18:59:56Z",
              "updatedAt": "2021-01-27T18:59:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0NjMzMjYzMTg0",
      "title": "Support buffering for streams on both sides.",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/44",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #28, #29.",
      "createdAt": "2021-05-07T18:58:25Z",
      "updatedAt": "2021-05-14T03:18:03Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "03bf845d5f7ee477d699094f920f1384f216b082",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "buffering",
      "headRefOid": "06bda259ad04abadda75aa636ec9f25a1c0036af",
      "closedAt": "2021-05-14T03:18:03Z",
      "mergedAt": "2021-05-14T03:18:02Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "18b4468aaeaf3d748c628cad8dc6d3cf061ad778"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @afrind @kixelated",
          "createdAt": "2021-05-07T19:00:35Z",
          "updatedAt": "2021-05-07T19:00:35Z"
        },
        {
          "author": "kixelated",
          "authorAssociation": "NONE",
          "body": "Looks great!",
          "createdAt": "2021-05-07T19:35:02Z",
          "updatedAt": "2021-05-07T19:35:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU0ODY3MTE3",
          "commit": {
            "abbreviatedOid": "5e987db"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-07T20:57:55Z",
          "updatedAt": "2021-05-07T20:58:30Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "This makes it sounds like the limit is 1 data stream and 1 datagram.  I think you want to say the client can send any number of any type.",
              "createdAt": "2021-05-07T20:57:55Z",
              "updatedAt": "2021-05-11T19:04:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU3MTAyMDc0",
          "commit": {
            "abbreviatedOid": "379c57d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-11T19:04:33Z",
          "updatedAt": "2021-05-11T19:04:34Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Good point. Fixed.",
              "createdAt": "2021-05-11T19:04:33Z",
              "updatedAt": "2021-05-11T19:04:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU3MTM3NjI2",
          "commit": {
            "abbreviatedOid": "379c57d"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-11T19:42:30Z",
          "updatedAt": "2021-05-11T19:43:01Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "s/has/receives/",
              "createdAt": "2021-05-11T19:42:30Z",
              "updatedAt": "2021-05-11T19:43:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4MTg5MDIz",
          "commit": {
            "abbreviatedOid": "39a09bd"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-12T17:36:25Z",
          "updatedAt": "2021-05-12T17:36:25Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Fixed.",
              "createdAt": "2021-05-12T17:36:25Z",
              "updatedAt": "2021-05-12T17:36:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4MjU0NDg3",
          "commit": {
            "abbreviatedOid": "39a09bd"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-12T18:37:05Z",
          "updatedAt": "2021-05-12T18:37:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NTA0NDkz",
          "commit": {
            "abbreviatedOid": "39a09bd"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-13T01:11:21Z",
          "updatedAt": "2021-05-13T01:12:14Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nstream or a datagram without a corresponding session.  Similarly, a client may\r\n```",
              "createdAt": "2021-05-13T01:11:21Z",
              "updatedAt": "2021-05-13T01:12:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQxMzY0NjM5",
      "title": "Redefine server-initiated bidi streams",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/46",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This matches agreement at the last interim.  We should separate this\r\ninto a different draft, but for now this will make the draft match\r\nimplementation.",
      "createdAt": "2021-05-11T18:39:17Z",
      "updatedAt": "2021-05-17T18:12:36Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "03bf845d5f7ee477d699094f920f1384f216b082",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "server-initiated",
      "headRefOid": "8861683a9a260a009c64ebb1e341854a6550bba5",
      "closedAt": "2021-05-17T18:12:36Z",
      "mergedAt": "2021-05-17T18:12:36Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "edfd9e379f71f0bf3e62c67c78efe1d99e050a06"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Partially addresses #23.\r\n\r\ncc @kixelated @afrind",
          "createdAt": "2021-05-11T18:40:31Z",
          "updatedAt": "2021-05-11T18:40:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU3MTMyMTY2",
          "commit": {
            "abbreviatedOid": "6f150c5"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-11T19:40:46Z",
          "updatedAt": "2021-05-11T19:40:47Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "I think maybe all you need to say is \r\n\r\n```\r\nThe only allowed HTTP/3 frame on a WebTransport bidirectional stream is WEBTRANSPORT_STREAM.\r\n```\r\n\r\nI don't see a lot of value here saying that some other document might specify something else.",
              "createdAt": "2021-05-11T19:40:47Z",
              "updatedAt": "2021-05-11T19:40:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NDg3Mzk5",
          "commit": {
            "abbreviatedOid": "6f150c5"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T00:20:56Z",
          "updatedAt": "2021-05-13T00:21:29Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I would suggest instead allowing all HTTP/3 frame types, and saying that clients MUST silently ignore all frame types except for WEBTRANSPORT_STREAM. That'll enable future extensibility without requiring a SETTING. This will also make it easier to split this into its own draft.",
              "createdAt": "2021-05-13T00:20:56Z",
              "updatedAt": "2021-05-13T00:21:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU4NTc3MDMx",
          "commit": {
            "abbreviatedOid": "6f150c5"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T04:36:47Z",
          "updatedAt": "2021-05-13T04:36:47Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "But this frame is a TV frame (not TLV), so it's defined to take up the entire stream?  \r\n\r\nTo get more extensibility, we could have server-initiated bidi stream carry a 'Stream Type', like uni streams, followed by a series of HTTP/3 frames.  WebTransport would then define its TV frame that converts the stream to unframed, and other types of server-initiated bidi streams could use TLV or TV frames.",
              "createdAt": "2021-05-13T04:36:47Z",
              "updatedAt": "2021-05-13T04:36:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5MDk3MDE3",
          "commit": {
            "abbreviatedOid": "6f150c5"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T16:46:00Z",
          "updatedAt": "2021-05-13T16:46:00Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "The frame being TV means that it needs to be the *last* frame on a stream. It doesn't need to be the *only* frame on a stream. All I'm saying is that server-initiated bidi streams can carry any and all h3 frames, and when they see a WEBTRANSPORT_STREAM frame then the rest of the stream is taken over. Just like client-initiated bidi streams.",
              "createdAt": "2021-05-13T16:46:00Z",
              "updatedAt": "2021-05-13T16:46:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5MTAxNDk2",
          "commit": {
            "abbreviatedOid": "6f150c5"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T16:51:16Z",
          "updatedAt": "2021-05-13T16:51:16Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "The frame is currently defined to be both first (sets the type to WT) and last (it's TV).  \r\n\r\nI'm suggesting you might want to split those two functions, and all streams (except client-initiated bidi) start with a stream type, followed by frames.\r\n\r\nEDIT: Push streams are a stream type followed by the Push ID followed by frames.  So much for symmetry.  Maybe Type+Preface+Frames?",
              "createdAt": "2021-05-13T16:51:16Z",
              "updatedAt": "2021-05-13T16:53:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5MTA1ODk2",
          "commit": {
            "abbreviatedOid": "6f150c5"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T16:56:31Z",
          "updatedAt": "2021-05-13T16:56:31Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I don't think we want to allow _all_ frame types. In particular, allowing HEADERS to be sent and but dropped at the receiver seems like a good way to break QPACK (see https://datatracker.ietf.org/doc/html/draft-ietf-quic-qpack-21#section-2.2.2.1). Opening things up for other frames types, especially new extension frames, seems ok though.",
              "createdAt": "2021-05-13T16:56:31Z",
              "updatedAt": "2021-05-13T16:56:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5MTI4MzE2",
          "commit": {
            "abbreviatedOid": "6f150c5"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T17:22:50Z",
          "updatedAt": "2021-05-13T17:22:50Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "@afrind what does \"sets the type\" mean? bidi streams don't have a type. It makes sense to allow extension frames before jumping into WT.\r\n\r\n@LPardue that's a good point, maybe not all frames, but definitely extensions",
              "createdAt": "2021-05-13T17:22:50Z",
              "updatedAt": "2021-05-13T17:22:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5MTM3Mjc1",
          "commit": {
            "abbreviatedOid": "6f150c5"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T17:33:17Z",
          "updatedAt": "2021-05-13T17:33:17Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "@DavidSchinazi : This draft defines a frame with two fields - one is the frame type, which serves multiple functions, and the session ID.  As written, sending this frame identifies the stream as a WT stream (semantics governed by this draft), associates this stream with a WT session, and converts the stream to unframed.\r\n\r\nFor general server bidi-stream extension semantics, I prefer we send a single 'type' field (not a frame type) to identify the semantics of the stream, followed by frames.  Then this draft would be slightly different:\r\n\r\n```\r\n[ Stream Type=WT Server-Init Bidi Stream ] [ Frame Type=WT_STREAM | Session ID ]\r\n```\r\n\r\n@LPardue : I don't think we should disallow any QPACK bearing frames in extensions, any more than H2 forbid HPACK bearing frames.  You just have to ensure that the peer has expressed support for the extension before using the dynamic table.  The static table is always OK.",
              "createdAt": "2021-05-13T17:33:17Z",
              "updatedAt": "2021-05-13T17:33:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5MTUzNTM2",
          "commit": {
            "abbreviatedOid": "6f150c5"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-13T17:53:11Z",
          "updatedAt": "2021-05-13T17:53:12Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "oh I'm not trying to prevent new things that can carry QPACK, I just think you'll want to couple that with a negotiation that makes it explicit the other end would respect the rules. Discarding HEADERS seems like an odd choice of behaviour to enable.",
              "createdAt": "2021-05-13T17:53:11Z",
              "updatedAt": "2021-05-13T17:53:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5NTUxNDQ3",
          "commit": {
            "abbreviatedOid": "8861683"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-14T06:16:17Z",
          "updatedAt": "2021-05-14T06:16:17Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "It sounds like this question needs further discussion.  I am leaving the frame-based version here to get us to a draft we can interop on, but we can continue this discussion on issue #23 (and at the upcoming interim).",
              "createdAt": "2021-05-14T06:16:17Z",
              "updatedAt": "2021-05-14T06:16:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5NTUxNjcz",
          "commit": {
            "abbreviatedOid": "8861683"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-14T06:16:51Z",
          "updatedAt": "2021-05-14T06:16:51Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Made text more vague; let's discuss this further on #23 and at the upcoming interim.",
              "createdAt": "2021-05-14T06:16:51Z",
              "updatedAt": "2021-05-14T06:16:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjU5OTU1MjYz",
          "commit": {
            "abbreviatedOid": "8861683"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-14T15:31:54Z",
          "updatedAt": "2021-05-14T15:31:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0NjY3NTE1MjMx",
      "title": "Add Alan Frindell and Eric Kinnear as editors",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/51",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-10T23:17:57Z",
      "updatedAt": "2021-07-19T19:07:38Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "c18cc8de9a3c8a58372a418df5827dbb16e0124a",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "new-editors",
      "headRefOid": "836e54982a521b4d0e6e786cbbddda49178fe913",
      "closedAt": "2021-07-19T19:07:38Z",
      "mergedAt": "2021-07-19T19:07:38Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "27b761d071f1adf2c258535d7d56a742f8ddd8f5"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "@afrind @ekinnear Please review.",
          "createdAt": "2021-06-10T23:19:01Z",
          "updatedAt": "2021-06-10T23:19:01Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks great, thanks @vasilvv!",
          "createdAt": "2021-06-10T23:21:16Z",
          "updatedAt": "2021-06-10T23:21:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjgyMDkwNTM3",
          "commit": {
            "abbreviatedOid": "836e549"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-11T17:53:22Z",
          "updatedAt": "2021-06-11T17:53:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5NjgxNTAy",
          "commit": {
            "abbreviatedOid": "836e549"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T15:21:53Z",
          "updatedAt": "2021-07-19T15:21:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg5NTI4MDcz",
      "title": "Clarify the value range of SETTINGS_ENABLE_WEBTRANSPORT",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/52",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-14T02:31:50Z",
      "updatedAt": "2021-07-19T19:07:57Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "c18cc8de9a3c8a58372a418df5827dbb16e0124a",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "settings-value-range",
      "headRefOid": "a4c27b349787dc193bd11b4f052e5446c7ea8f73",
      "closedAt": "2021-07-19T19:07:57Z",
      "mergedAt": "2021-07-19T19:07:57Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "40a1f0efe8151a5d9aff747a9e4b56f6c139cbc5"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @jlaine who pointed out to me we never specified the allowed value range",
          "createdAt": "2021-07-14T02:35:22Z",
          "updatedAt": "2021-07-14T02:35:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2NDQ0ODU3",
          "commit": {
            "abbreviatedOid": "b570561"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-14T15:50:22Z",
          "updatedAt": "2021-07-14T15:50:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2NDQ5MDMy",
          "commit": {
            "abbreviatedOid": "b570561"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-14T15:54:07Z",
          "updatedAt": "2021-07-14T15:54:07Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n\"1\", with \"0\" being the default; an endpoint that receives a value other\r\nthan \"0\" or \"1\" MUST close the connection with the H3_SETTINGS_ERROR error\r\n```",
              "createdAt": "2021-07-14T15:54:07Z",
              "updatedAt": "2021-07-14T15:54:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5NjgzODc2",
          "commit": {
            "abbreviatedOid": "a4c27b3"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T15:23:58Z",
          "updatedAt": "2021-07-19T15:23:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 55,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk5MDU1NzA1",
      "title": "Close connection on an invalid session ID received.",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/55",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #32.",
      "createdAt": "2021-07-28T22:29:43Z",
      "updatedAt": "2021-09-08T19:38:25Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "40a1f0efe8151a5d9aff747a9e4b56f6c139cbc5",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "issue32",
      "headRefOid": "9b46ef2f271c34ff2a94e54ba40a48ac60787825",
      "closedAt": "2021-09-08T19:38:25Z",
      "mergedAt": "2021-09-08T19:38:25Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "d7418ab83edcb53b29195810cd74509190601dab"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk5MDc5OTg5",
      "title": "Require the server to wait for SETTINGS",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/56",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Requires the server to defer the processing of any incoming WebTransport\r\nsessions until the relevant settings have been received from the client.\r\nThis makes versioning WebTransport extension possible.\r\n\r\nFixes #39.",
      "createdAt": "2021-07-28T23:34:44Z",
      "updatedAt": "2021-09-08T19:38:54Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "53b776165e6779ed5a12001987a663bb2110d224",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "issue39",
      "headRefOid": "7360feb7a90daf3117ad7fe2eab6d99cee34abc5",
      "closedAt": "2021-09-08T19:38:54Z",
      "mergedAt": "2021-09-08T19:38:54Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "a15c097a16067f59ae5b18daa49351915a8d428c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 57,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk5MDk4MjA3",
      "title": "Remove the text about initial_max_bidi_streams",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/57",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This requirement has been irrelevant since quicwg/base-drafts#2773",
      "createdAt": "2021-07-29T00:32:38Z",
      "updatedAt": "2021-09-08T19:39:46Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "53b776165e6779ed5a12001987a663bb2110d224",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "max-bidi-streams-server",
      "headRefOid": "588d4d3b826ec3b46523a3292fe300d5fa8b90a0",
      "closedAt": "2021-09-08T19:39:46Z",
      "mergedAt": "2021-09-08T19:39:46Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "179907e1b796b88c1820de3631c5be809ec057b0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk5MTAwNTUw",
      "title": "Replace 200 status code with 2xx",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/58",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This makes our behavior consistent with the regular CONNECT method.\r\n\r\nFixes #42.",
      "createdAt": "2021-07-29T00:39:58Z",
      "updatedAt": "2021-09-08T19:39:59Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "53b776165e6779ed5a12001987a663bb2110d224",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "issue42",
      "headRefOid": "58807ccc148390d97a5650aacce1a870ed328e85",
      "closedAt": "2021-09-08T19:39:59Z",
      "mergedAt": "2021-09-08T19:39:59Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "2c9f3eb92328a93c1e15081bd8573310aba011b4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE4NTM1NTQ1",
          "commit": {
            "abbreviatedOid": "58807cc"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-29T21:07:48Z",
          "updatedAt": "2021-07-29T21:07:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk5MTY5NDQ5",
      "title": "Allocate HTTP/3 error codes for use by the WebTransport application",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/59",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #40.",
      "createdAt": "2021-07-29T03:12:34Z",
      "updatedAt": "2021-09-08T19:39:31Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "53b776165e6779ed5a12001987a663bb2110d224",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "issue40",
      "headRefOid": "3a7ddabeb5a1c15f5a3aea46a34ff44d733f7e1e",
      "closedAt": "2021-09-08T19:39:31Z",
      "mergedAt": "2021-09-08T19:39:30Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "ba2a502bdbfd761657bdb4c8046950f696ee9eb7"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @martinthomson",
          "createdAt": "2021-07-29T03:23:43Z",
          "updatedAt": "2021-07-29T03:23:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE4NTM2Njc3",
          "commit": {
            "abbreviatedOid": "26ba75c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-29T21:09:17Z",
          "updatedAt": "2021-07-29T21:13:43Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "How about avoiding `//` syntax that not everyone knows:\r\n```suggestion\r\n        return first + n + floor(n / 0x1e)\r\n```",
              "createdAt": "2021-07-29T21:09:17Z",
              "updatedAt": "2021-07-29T21:13:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0NzM3Nzgz",
          "commit": {
            "abbreviatedOid": "26ba75c"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-06T22:08:03Z",
          "updatedAt": "2021-08-06T22:08:03Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Great to have pseudocode, is there a chance we could explain _how_ someone is expected to account for those (i.e. do you just consider those invalid/taken already or shift by that much each time you pass an already reserved one) in text so that when people get to the pseudocode they know what behavior they're supposed to be seeing?",
              "createdAt": "2021-08-06T22:08:03Z",
              "updatedAt": "2021-08-06T22:08:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0NzM4MDI0",
          "commit": {
            "abbreviatedOid": "26ba75c"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-06T22:08:38Z",
          "updatedAt": "2021-08-06T22:08:38Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Is the client (or the server) expected to be aware of the presence of intermediaries for this?",
              "createdAt": "2021-08-06T22:08:38Z",
              "updatedAt": "2021-08-06T22:08:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM2OTQ5NTAz",
          "commit": {
            "abbreviatedOid": "3a7ddab"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-24T08:29:49Z",
          "updatedAt": "2021-08-24T08:29:50Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "You account by shifting.  Clarified that.",
              "createdAt": "2021-08-24T08:29:49Z",
              "updatedAt": "2021-08-24T08:29:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM2OTUxMTE2",
          "commit": {
            "abbreviatedOid": "3a7ddab"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-24T08:31:28Z",
          "updatedAt": "2021-08-24T08:31:28Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I think the way I'd put it is that the web application (i.e. the combination of client and server) has to be aware of lack of intermediaries to rely on those.",
              "createdAt": "2021-08-24T08:31:28Z",
              "updatedAt": "2021-08-24T08:31:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3MzQzMzE4",
          "commit": {
            "abbreviatedOid": "3a7ddab"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-24T15:00:16Z",
          "updatedAt": "2021-08-24T15:00:16Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Having the application be aware of intermediaries sounds like a brittle design, as the presence of intermediaries might be out of the control of the application developer",
              "createdAt": "2021-08-24T15:00:16Z",
              "updatedAt": "2021-08-24T15:00:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk5ODcwMTg4",
      "title": "Add a mechanism to close a session with an error message",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/60",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #41.",
      "createdAt": "2021-07-29T22:06:27Z",
      "updatedAt": "2021-10-19T05:21:08Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "4e5ea2f203a40db42f82aa33979c09e100fd432b",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "issue41",
      "headRefOid": "aa9a445c69eb6f929383dcb8af5e27cf3c544b84",
      "closedAt": "2021-10-19T05:21:08Z",
      "mergedAt": "2021-10-19T05:21:08Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "e6bc3bba81c93f7dcf22d3676583654946f8f886"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "@DavidSchinazi @ekinnear @afrind Updated the PR; please take another look.",
          "createdAt": "2021-09-08T19:58:21Z",
          "updatedAt": "2021-09-08T19:58:21Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I think I addressed all issues; please tell me if I'm missing anything, if not, I'll merge this soon.\r\n\r\ncc @DavidSchinazi @ekinnear @afrind ",
          "createdAt": "2021-09-21T23:43:09Z",
          "updatedAt": "2021-09-21T23:43:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE4NjAxNjUz",
          "commit": {
            "abbreviatedOid": "15d7335"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-29T23:09:15Z",
          "updatedAt": "2021-07-29T23:13:28Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Why not 62-bit like everything else?",
              "createdAt": "2021-07-29T23:09:15Z",
              "updatedAt": "2021-07-29T23:13:28Z"
            },
            {
              "originalPosition": 38,
              "body": "I don't think this FIN is required, and it may prevent adding extensions after it. I'd change this to a SHOULD.",
              "createdAt": "2021-07-29T23:10:32Z",
              "updatedAt": "2021-07-29T23:13:28Z"
            },
            {
              "originalPosition": 39,
              "body": "\"any data\" - on what stream? Also, what does this requirement accomplish?",
              "createdAt": "2021-07-29T23:11:11Z",
              "updatedAt": "2021-07-29T23:13:28Z"
            },
            {
              "originalPosition": 47,
              "body": "s/close/closed/\r\n\r\nMight be simpler for the higher layers to say error code zero instead of without an error code.\r\nSimilarly, error string is \"\".",
              "createdAt": "2021-07-29T23:12:43Z",
              "updatedAt": "2021-07-29T23:13:28Z"
            },
            {
              "originalPosition": 34,
              "body": "What's the purpose of this message? Is it exposed to JavaScript?",
              "createdAt": "2021-07-29T23:13:18Z",
              "updatedAt": "2021-07-29T23:13:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIwNTkzMDIz",
          "commit": {
            "abbreviatedOid": "15d7335"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-02T21:05:38Z",
          "updatedAt": "2021-08-02T21:05:38Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I think I'd leave this as a MUST.  Any extensions ought to go before the CLOSE_WEBTRANSPORT_SESSION.",
              "createdAt": "2021-08-02T21:05:38Z",
              "updatedAt": "2021-08-02T21:05:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI0NzM2ODM0",
          "commit": {
            "abbreviatedOid": "15d7335"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-06T22:05:32Z",
          "updatedAt": "2021-08-06T22:05:32Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "To add to this, is that \"any data\" on the stream, or any frames on/about it?",
              "createdAt": "2021-08-06T22:05:32Z",
              "updatedAt": "2021-08-06T22:05:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI4MTk5ODA4",
          "commit": {
            "abbreviatedOid": "15d7335"
          },
          "author": "yutakahirano",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-12T05:46:04Z",
          "updatedAt": "2021-08-12T05:46:15Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Should we explicitly state it's a UTF-8 encoded string? I see that in CONNECTION_CLOSE. https://datatracker.ietf.org/doc/html/rfc9000#section-19.19",
              "createdAt": "2021-08-12T05:46:04Z",
              "updatedAt": "2021-08-12T05:46:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM2OTkxOTQ2",
          "commit": {
            "abbreviatedOid": "15d7335"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-24T09:11:57Z",
          "updatedAt": "2021-08-24T09:11:57Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I agree with Alan here.",
              "createdAt": "2021-08-24T09:11:57Z",
              "updatedAt": "2021-08-24T09:11:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM2OTkzMTcy",
          "commit": {
            "abbreviatedOid": "15d7335"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-24T09:13:15Z",
          "updatedAt": "2021-08-24T09:13:16Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I sent an email to the list about this.",
              "createdAt": "2021-08-24T09:13:15Z",
              "updatedAt": "2021-08-24T09:13:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3MzQzOTIx",
          "commit": {
            "abbreviatedOid": "15d7335"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-24T15:00:44Z",
          "updatedAt": "2021-08-24T15:00:44Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I can live with this",
              "createdAt": "2021-08-24T15:00:44Z",
              "updatedAt": "2021-08-24T15:00:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM5Mzk5OTAz",
          "commit": {
            "abbreviatedOid": "15d7335"
          },
          "author": "yutakahirano",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-26T12:19:11Z",
          "updatedAt": "2021-08-26T12:19:17Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": " - What happens when one endpoint sends a RESET_STREAM? Is it a protocol violation, or \"unclean\" session termination?\r\n - What happens when one endpoint sends a STOP_SENDING on the CONNECT stream? ",
              "createdAt": "2021-08-26T12:19:11Z",
              "updatedAt": "2021-08-26T12:19:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ5NTU0ODUx",
          "commit": {
            "abbreviatedOid": "be74957"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-08T19:52:36Z",
          "updatedAt": "2021-09-08T19:52:36Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Changed to 32-bit per list discussion.",
              "createdAt": "2021-09-08T19:52:36Z",
              "updatedAt": "2021-09-08T19:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ5NTU1MzMz",
          "commit": {
            "abbreviatedOid": "be74957"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-08T19:53:10Z",
          "updatedAt": "2021-09-08T19:53:11Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "This is to enforce the requirement in the previous statement.  Clarified the text.",
              "createdAt": "2021-09-08T19:53:10Z",
              "updatedAt": "2021-09-08T19:53:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ5NTU2MDYz",
          "commit": {
            "abbreviatedOid": "b20692b"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-08T19:54:04Z",
          "updatedAt": "2021-09-08T19:54:04Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Done.",
              "createdAt": "2021-09-08T19:54:04Z",
              "updatedAt": "2021-09-08T19:54:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ5NTU2NTY3",
          "commit": {
            "abbreviatedOid": "b20692b"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-08T19:54:39Z",
          "updatedAt": "2021-09-08T19:54:39Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Clarified that this is UTF-8.",
              "createdAt": "2021-09-08T19:54:39Z",
              "updatedAt": "2021-09-08T19:54:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ5NTU5MjYz",
          "commit": {
            "abbreviatedOid": "b20692b"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-08T19:57:52Z",
          "updatedAt": "2021-09-08T19:57:52Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Those are all included in the \"closed\" term.",
              "createdAt": "2021-09-08T19:57:52Z",
              "updatedAt": "2021-09-08T19:57:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzQ5NTczMDM4",
          "commit": {
            "abbreviatedOid": "b20692b"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Overall looks good modulo removal of the length and some nits",
          "createdAt": "2021-09-08T20:14:42Z",
          "updatedAt": "2021-09-08T20:17:42Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Since capsules contain a length and are therefore self-terminating, you can remove the `Application Error Message Length` field as it is redundant. That would also better match other existing capsules.",
              "createdAt": "2021-09-08T20:14:42Z",
              "updatedAt": "2021-09-08T20:17:42Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nA WebTransport session over HTTP/3 is considered terminated when either\r\n```",
              "createdAt": "2021-09-08T20:15:37Z",
              "updatedAt": "2021-09-08T20:17:42Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\n  it, and MUST NOT exceed 1024 bytes.\r\n```",
              "createdAt": "2021-09-08T20:15:55Z",
              "updatedAt": "2021-09-08T20:17:42Z"
            },
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nH3_MESSAGE_ERROR.  The recipient MUST close the stream upon receiving a FIN.\r\n```",
              "createdAt": "2021-09-08T20:16:16Z",
              "updatedAt": "2021-09-08T20:17:42Z"
            },
            {
              "originalPosition": 47,
              "body": "```suggestion\r\nclosed with an error code of 0 and an empty error string.\r\n```",
              "createdAt": "2021-09-08T20:17:16Z",
              "updatedAt": "2021-09-08T20:17:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s4tUeXR",
          "commit": {
            "abbreviatedOid": "de18692"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good modulo one small nit",
          "createdAt": "2021-09-21T23:46:35Z",
          "updatedAt": "2021-09-21T23:47:32Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "nit: we changed the reference name in #62 \r\n```suggestion\r\nan HTTP capsule {{HTTP-DATAGRAM}} of type CLOSE_WEBTRANSPORT_SESSION (0x2843).\r\n```",
              "createdAt": "2021-09-21T23:46:35Z",
              "updatedAt": "2021-09-21T23:47:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s4tUeYW",
          "commit": {
            "abbreviatedOid": "de18692"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Just minor nits, looking good!",
          "createdAt": "2021-09-21T23:46:44Z",
          "updatedAt": "2021-09-21T23:49:39Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Any particular reason for the choice of length? Just trying to stay under QUIC minimum sizes?",
              "createdAt": "2021-09-21T23:46:44Z",
              "updatedAt": "2021-09-21T23:49:39Z"
            },
            {
              "originalPosition": 42,
              "body": "So this isn't an error? Or we think it might be, but we're trying to be more gentle? \r\nOr we expect it to actually happen in real life if there's a high enough RTT?",
              "createdAt": "2021-09-21T23:49:19Z",
              "updatedAt": "2021-09-21T23:49:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s4tUi7q",
          "commit": {
            "abbreviatedOid": "de18692"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-22T00:35:33Z",
          "updatedAt": "2021-09-22T00:38:50Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Should we be more explicit that either peer closes the write half of the stream or you think it's implied?",
              "createdAt": "2021-09-22T00:35:33Z",
              "updatedAt": "2021-09-22T00:38:50Z"
            },
            {
              "originalPosition": 42,
              "body": "Maybe this bit of text belongs above (around line 369) and be made generic to the case when a peer sends a FIN (without CLOSE_WEBTRANSPORT_SESSION) as well?",
              "createdAt": "2021-09-22T00:38:48Z",
              "updatedAt": "2021-09-22T00:38:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s4t3LzL",
          "commit": {
            "abbreviatedOid": "eedab84"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-02T00:14:25Z",
          "updatedAt": "2021-10-02T00:14:26Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Not in particular, just trying to place some bound on the string length, and 1024 seemed like a reasonable number.",
              "createdAt": "2021-10-02T00:14:25Z",
              "updatedAt": "2021-10-02T00:14:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s4t3L1W",
          "commit": {
            "abbreviatedOid": "eedab84"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-02T00:15:21Z",
          "updatedAt": "2021-10-02T00:15:21Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Well, there isn't really an \"error\" when it comes to closing things (since you're closing them anyways).  But yes, in general, (0, \"\") is the close code unless specified otherwise.",
              "createdAt": "2021-10-02T00:15:21Z",
              "updatedAt": "2021-10-02T00:15:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s4ubxUp",
          "commit": {
            "abbreviatedOid": "a18c179"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-13T19:59:30Z",
          "updatedAt": "2021-10-13T19:59:30Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I reworded this to make it explicit that either peer closing it in either way means it's terminated.",
              "createdAt": "2021-10-13T19:59:30Z",
              "updatedAt": "2021-10-13T19:59:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s4ucG2X",
          "commit": {
            "abbreviatedOid": "a18c179"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-13T21:47:59Z",
          "updatedAt": "2021-10-13T21:51:51Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Should we say MUST NOT open new streams as well?",
              "createdAt": "2021-10-13T21:47:59Z",
              "updatedAt": "2021-10-13T21:51:51Z"
            },
            {
              "originalPosition": 32,
              "body": "This would match HTTP-DATAGRAM better:\r\n```suggestion\r\nCLOSE_WEBTRANSPORT_SESSION Capsule {\r\n  Type (i) = CLOSE_WEBTRANSPORT_SESSION,\r\n  Length (i),\r\n  Application Error Code (32),\r\n  Application Error Message (..8192),\r\n}\r\n```",
              "createdAt": "2021-10-13T21:49:54Z",
              "updatedAt": "2021-10-13T21:51:51Z"
            },
            {
              "originalPosition": 35,
              "body": "Maybe add a sentence explaining the limit?",
              "createdAt": "2021-10-13T21:50:23Z",
              "updatedAt": "2021-10-13T21:51:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s4uqJOO",
          "commit": {
            "abbreviatedOid": "3740b34"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-19T05:18:24Z",
          "updatedAt": "2021-10-19T05:18:24Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Done.",
              "createdAt": "2021-10-19T05:18:24Z",
              "updatedAt": "2021-10-19T05:18:32Z"
            }
          ]
        }
      ]
    },
    {
      "number": 62,
      "id": "PR_kwDOCvK98s4r_s9U",
      "title": "Keep track of latest changes in HTTP Datagrams",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/62",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR keeps WebTransport in sync with the latest changes in draft-ietf-masque-h3-datagram.",
      "createdAt": "2021-09-21T00:44:18Z",
      "updatedAt": "2021-09-21T22:26:25Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "2c9f3eb92328a93c1e15081bd8573310aba011b4",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "datagram_format_type",
      "headRefOid": "8c788d6ecf20131c566cdb219d4e0959d5870816",
      "closedAt": "2021-09-21T22:26:25Z",
      "mergedAt": "2021-09-21T22:26:25Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "4e5ea2f203a40db42f82aa33979c09e100fd432b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 64,
      "id": "PR_kwDOCvK98s4tmMTc",
      "title": "Describe negotiating different draft versions.",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/64",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change both describes the existing mechanism (SETTINGS).  It also\r\nadds a header in the unlikely scenario that we would need to change\r\ncapsule stream format (instead of just defining new capsules).",
      "createdAt": "2021-10-25T00:48:29Z",
      "updatedAt": "2021-10-25T21:51:56Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "e6bc3bba81c93f7dcf22d3676583654946f8f886",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "negotiation-2",
      "headRefOid": "8b4aaf5fd1cb051a809115084c5f452da245dceb",
      "closedAt": "2021-10-25T21:51:56Z",
      "mergedAt": "2021-10-25T21:51:56Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "fb770979c9e49deac4168b3b0ffb8ea3cbd53bb6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s4u_PkV",
          "commit": {
            "abbreviatedOid": "5aa3fa1"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T16:06:43Z",
          "updatedAt": "2021-10-25T16:06:48Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I'd recommend adding a note defining what happens when multiple drafts are supported, [like we have in HTTP Datagrams](https://datatracker.ietf.org/doc/html/draft-ietf-masque-h3-datagram#section-5.1).\r\n\r\n",
              "createdAt": "2021-10-25T16:06:43Z",
              "updatedAt": "2021-10-25T16:06:48Z"
            },
            {
              "originalPosition": 21,
              "body": "Should this text be written such that it doesn't need to be updated every time the draft is reved? Also, what does the server do with this information? Does it pick one? Does it echo which one it picked?",
              "createdAt": "2021-10-25T16:06:45Z",
              "updatedAt": "2021-10-25T16:06:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s4vAAbZ",
          "commit": {
            "abbreviatedOid": "139922d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T19:32:50Z",
          "updatedAt": "2021-10-25T19:32:50Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Done.",
              "createdAt": "2021-10-25T19:32:50Z",
              "updatedAt": "2021-10-25T19:32:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s4vADb6",
          "commit": {
            "abbreviatedOid": "139922d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T19:46:49Z",
          "updatedAt": "2021-10-25T19:46:49Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I do want us to manually bump the header name, since I don't expect the format change every version.\r\n\r\nAdded a server reply.",
              "createdAt": "2021-10-25T19:46:49Z",
              "updatedAt": "2021-10-25T19:46:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s4vADrC",
          "commit": {
            "abbreviatedOid": "139922d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T19:47:55Z",
          "updatedAt": "2021-10-25T19:49:32Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "What does highest version mean?",
              "createdAt": "2021-10-25T19:47:55Z",
              "updatedAt": "2021-10-25T19:49:32Z"
            },
            {
              "originalPosition": 23,
              "body": "Having the version number in the draft is a recipe for forgetting to change this",
              "createdAt": "2021-10-25T19:49:20Z",
              "updatedAt": "2021-10-25T19:49:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s4vAEn4",
          "commit": {
            "abbreviatedOid": "8b4aaf5"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T19:52:22Z",
          "updatedAt": "2021-10-25T19:52:23Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Replaced with \"most recent\".",
              "createdAt": "2021-10-25T19:52:23Z",
              "updatedAt": "2021-10-25T19:52:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s4vAExn",
          "commit": {
            "abbreviatedOid": "8b4aaf5"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T19:53:04Z",
          "updatedAt": "2021-10-25T19:53:05Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Well, the hope is that we won't have to change it unless we make wire-incompatible changes to the capsules.",
              "createdAt": "2021-10-25T19:53:05Z",
              "updatedAt": "2021-10-25T19:53:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s4vAR4o",
          "commit": {
            "abbreviatedOid": "8b4aaf5"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T20:45:24Z",
          "updatedAt": "2021-10-25T20:45:24Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "The whole purpose of this is to allow that kind of breaking change. It'll just be odd to have draft-06 use Draft02",
              "createdAt": "2021-10-25T20:45:24Z",
              "updatedAt": "2021-10-25T20:45:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s4vAUWE",
          "commit": {
            "abbreviatedOid": "8b4aaf5"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-25T20:57:00Z",
          "updatedAt": "2021-10-25T20:57:01Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I don't see anything weird?  We're already not rotating a codepoint for the SETTINGS frame.",
              "createdAt": "2021-10-25T20:57:00Z",
              "updatedAt": "2021-10-25T20:57:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s4vAWPR",
          "commit": {
            "abbreviatedOid": "8b4aaf5"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-25T21:05:53Z",
          "updatedAt": "2021-10-25T21:05:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 69,
      "id": "PR_kwDOCvK98s4z-0du",
      "title": "Update to draft-ietf-masque-h3-datagram-06",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/69",
      "state": "MERGED",
      "author": "DavidSchinazi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR updates draft-ietf-webtrans-http3 to account for the MASQUE HTTP Datagram Design Team changes that landed in draft-ietf-masque-h3-datagram-06.\r\n\r\nFixes #54.",
      "createdAt": "2022-03-05T00:36:27Z",
      "updatedAt": "2022-03-05T01:56:49Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "fb770979c9e49deac4168b3b0ffb8ea3cbd53bb6",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "http_datagram_design_team",
      "headRefOid": "9f0db4cf5dc50362b7429aaf1a14ce773ed6f6cf",
      "closedAt": "2022-03-05T01:56:49Z",
      "mergedAt": "2022-03-05T01:56:48Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "aeca2763f462ea8058ea569cec5c60bc5ee0c495"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 74,
      "id": "PR_kwDOCvK98s46af1Q",
      "title": "Add SETTINGS_MAX_WEBTRANSPORT_SESSIONS settings parameter",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/74",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also bump the protocol wire vesrion\r\n\r\nFixes #34",
      "createdAt": "2022-06-27T12:51:18Z",
      "updatedAt": "2022-11-04T04:14:13Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "5d4ccbcf997a1043ddd222bf77da4907803d5d06",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "new-setting",
      "headRefOid": "88596bf9c641fb1fbada0fb3cf80e43a230ae5d1",
      "closedAt": "2022-11-04T04:14:13Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Additionally, this PR addresses #34 but not #22 so it shouldn't be marked as fixing #22.",
          "createdAt": "2022-06-27T16:26:40Z",
          "updatedAt": "2022-06-27T16:26:40Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> Additionally, this PR addresses #34 but not #22 so it shouldn't be marked as fixing #22.\r\n\r\nI thought we've agreed at some point that this is all we want in terms of solving #22?",
          "createdAt": "2022-06-28T06:11:51Z",
          "updatedAt": "2022-06-28T06:11:51Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Additionally, this PR addresses #34 but not #22 so it shouldn't be marked as fixing #22.\r\n> \r\n> I thought we've agreed at some point that this is all we want in terms of solving #22?\r\n\r\nI don't recall that (but I could be misremembering), do you have a reference to point me to?",
          "createdAt": "2022-06-28T21:53:10Z",
          "updatedAt": "2022-06-28T21:53:10Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> > > Additionally, this PR addresses #34 but not #22 so it shouldn't be marked as fixing #22.\r\n> > \r\n> > \r\n> > I thought we've agreed at some point that this is all we want in terms of solving #22?\r\n> \r\n> I don't recall that (but I could be misremembering), do you have a reference to point me to?\r\n\r\nI checked the meeting notes for the design team, and it looks like we decided the opposite of what I remember, so it looks like I'm the one misremembering here.",
          "createdAt": "2022-06-30T13:07:00Z",
          "updatedAt": "2022-06-30T13:07:00Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Superseded by #86.",
          "createdAt": "2022-11-04T04:14:13Z",
          "updatedAt": "2022-11-04T04:14:13Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s48z1ZL",
          "commit": {
            "abbreviatedOid": "74d838d"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-27T13:42:09Z",
          "updatedAt": "2022-06-27T13:42:20Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nand the server do not have a consistent view of how many sessions are open due\r\n```",
              "createdAt": "2022-06-27T13:42:10Z",
              "updatedAt": "2022-06-27T13:42:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s480vRE",
          "commit": {
            "abbreviatedOid": "74d838d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-27T16:26:02Z",
          "updatedAt": "2022-06-27T16:26:02Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I thought we were going to only have one setting since SETTINGS_MAX_WEBTRANSPORT_SESSIONS=0 means the same as \"WebTransport not supported\".",
              "createdAt": "2022-06-27T16:26:02Z",
              "updatedAt": "2022-06-27T16:26:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s483ZLQ",
          "commit": {
            "abbreviatedOid": "74d838d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-28T06:10:53Z",
          "updatedAt": "2022-06-28T06:10:54Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "We can't do that at this point, since only the server sends SETTINGS_MAX_WEBTRANSPORT_SESSIONS, and we need a setting from the client to do version negotiation.",
              "createdAt": "2022-06-28T06:10:54Z",
              "updatedAt": "2022-06-28T06:10:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s488lCD",
          "commit": {
            "abbreviatedOid": "74d838d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-28T21:51:31Z",
          "updatedAt": "2022-06-28T21:51:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Can't we use only the header for VN and drop the setting? If anyone is implementing draft versions with an intermediary they can parse the headers.",
              "createdAt": "2022-06-28T21:51:31Z",
              "updatedAt": "2022-06-28T21:51:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s49FdvN",
          "commit": {
            "abbreviatedOid": "74d838d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-30T13:07:41Z",
          "updatedAt": "2022-06-30T13:07:41Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "From what I remember from the way our code works, that would work poorly, so I'm hesitant to do that.",
              "createdAt": "2022-06-30T13:07:41Z",
              "updatedAt": "2022-06-30T13:07:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s49MmRg",
          "commit": {
            "abbreviatedOid": "3814c0a"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Seems good, will also pull into the design team branch and also for H2 as well (also including IANA considerations for the setting).",
          "createdAt": "2022-07-02T01:45:17Z",
          "updatedAt": "2022-07-02T03:20:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s49MmeZ",
          "commit": {
            "abbreviatedOid": "74d838d"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-02T01:55:06Z",
          "updatedAt": "2022-07-02T01:55:06Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This is written such that MAX_WEBTRANSPORT_SESSIONS is only sent by the server, do we want to have enable_webtransport (or version) still be sent by both/the client, or do we think that using the upgrade token indicates support on the part of the client? (And is that easy enough to handle in code)",
              "createdAt": "2022-07-02T01:55:06Z",
              "updatedAt": "2022-07-02T01:55:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s49MnWz",
          "commit": {
            "abbreviatedOid": "3814c0a"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-02T02:45:05Z",
          "updatedAt": "2022-07-02T02:45:06Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "(Just to disambiguate \"status\")\r\n```suggestion\r\nerror code defined in [HTTP3].\r\n```",
              "createdAt": "2022-07-02T02:45:05Z",
              "updatedAt": "2022-07-02T02:45:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s49M8bR",
          "commit": {
            "abbreviatedOid": "3814c0a"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-03T03:16:01Z",
          "updatedAt": "2022-07-03T03:17:06Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "it's formally this\r\n\r\n```suggestion\r\nCONNECT streams it is not willing to process with the `H3_REQUEST_REJECTED`\r\n```",
              "createdAt": "2022-07-03T03:16:01Z",
              "updatedAt": "2022-07-03T03:17:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 75,
      "id": "PR_kwDOCvK98s46avTn",
      "title": "Add a reset error code for closing streams due to session closure",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/75",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-06-27T13:44:44Z",
      "updatedAt": "2022-07-06T16:26:44Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "5d4ccbcf997a1043ddd222bf77da4907803d5d06",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "error-code-gone",
      "headRefOid": "7db006d11083b11cee6d47dc79281a7dc92dc72f",
      "closedAt": "2022-07-06T16:26:44Z",
      "mergedAt": "2022-07-06T16:26:43Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "bf112a8a2ad97b90e23ed162a00a46f2f3c020a3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s480_GT",
          "commit": {
            "abbreviatedOid": "55bd31b"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-27T17:16:06Z",
          "updatedAt": "2022-06-27T17:16:07Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "note that reset only affects the write side of the stream, we also need to abort reading. Here's example text from RFC 9114:\r\n\r\n\r\n> Implementations SHOULD cancel requests by abruptly terminating any directions of a stream that are still open. To do so, an implementation resets the sending parts of streams and aborts reading on the receiving parts of streams; see [Section 2.4](https://www.rfc-editor.org/rfc/rfc9000#section-2.4) of RFC 9000.",
              "createdAt": "2022-06-27T17:16:06Z",
              "updatedAt": "2022-06-27T17:16:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s49FtHl",
          "commit": {
            "abbreviatedOid": "55bd31b"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-30T13:46:27Z",
          "updatedAt": "2022-06-30T13:46:27Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Good point.  Clarified that.",
              "createdAt": "2022-06-30T13:46:27Z",
              "updatedAt": "2022-06-30T13:46:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s49HpQX",
          "commit": {
            "abbreviatedOid": "a026842"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-30T19:45:19Z",
          "updatedAt": "2022-06-30T19:45:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s49MmN7",
          "commit": {
            "abbreviatedOid": "a026842"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-02T01:42:48Z",
          "updatedAt": "2022-07-02T01:42:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s49M8dW",
          "commit": {
            "abbreviatedOid": "a026842"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-03T03:19:35Z",
          "updatedAt": "2022-07-03T03:19:35Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "since the text applies to both read and write, we can be more generic in the description\r\n\r\n```suggestion\r\n: WebTransport data stream aborted because the associated WebTransport session\r\n```",
              "createdAt": "2022-07-03T03:19:35Z",
              "updatedAt": "2022-07-03T03:19:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 76,
      "id": "PR_kwDOCvK98s46bJHZ",
      "title": "Clarify interactions with HTTP/3 GOAWAY",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/76",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #67",
      "createdAt": "2022-06-27T15:12:28Z",
      "updatedAt": "2022-06-30T13:03:29Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "5d4ccbcf997a1043ddd222bf77da4907803d5d06",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "goaway",
      "headRefOid": "4bbd33cb6c99d34414358a5bc2b2a76aeae4ed5d",
      "closedAt": "2022-06-30T13:03:29Z",
      "mergedAt": "2022-06-30T13:03:29Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "3a40254935745dff1682d87b14370c3b0d323392"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s481ART",
          "commit": {
            "abbreviatedOid": "4bbd33c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-27T17:19:54Z",
          "updatedAt": "2022-06-27T17:19:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s481d6f",
          "commit": {
            "abbreviatedOid": "4bbd33c"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-27T18:59:31Z",
          "updatedAt": "2022-06-27T18:59:31Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s481meh",
          "commit": {
            "abbreviatedOid": "4bbd33c"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-27T19:32:12Z",
          "updatedAt": "2022-06-27T19:32:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 79,
      "id": "PR_kwDOCvK98s47-bHM",
      "title": "Add a capsule to drain a WebTransport session",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/79",
      "state": "MERGED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #27",
      "createdAt": "2022-07-22T23:36:27Z",
      "updatedAt": "2023-02-25T00:46:44Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "177e2348da14bf6a76a8bd5637de3d69666120a2",
      "headRepository": "afrind/draft-ietf-webtrans-http3",
      "headRefName": "drain",
      "headRefOid": "dccc816655df103a2b5277e4f00c3d46df80933e",
      "closedAt": "2023-02-07T23:13:06Z",
      "mergedAt": "2023-02-07T23:13:06Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "9a060df91c98065251241a79ce55d30a0895edd5"
      },
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FYI, the API PR for a client receiving a DRAIN_WEBTRANSPORT_SESSION capsule is here: https://github.com/w3c/webtransport/pull/437\r\n\r\nA separate issue has been opened for the client sending a DRAIN_WEBTRANSPORT_SESSION capsule: https://github.com/w3c/webtransport/issues/436\r\n\r\nAfter receiving a DRAIN_WEBTRANSPORT_SESSION capsule from the server, the PR prevents the application from opening new unidirectional or bidirectional streams, but doesn't prevent it from continuing to send datagrams. Is that appropriate, or should the application treat receipt of the DRAIN_WEBTRANSPORT_SESSION capsule more like a hint (e.g. it probably shouldn't open new unidirectional or bidirectional streams but it's not prohibited from doing so)?",
          "createdAt": "2022-11-28T20:32:35Z",
          "updatedAt": "2022-11-28T22:20:48Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Section 4.6 of WebTransport over HTTP/3 (https://www.ietf.org/archive/id/draft-ietf-webtrans-http3-04.html#name-interaction-with-http-3-goa) now covers the HTTP/3 GOAWAY frame. When sent from the server -> client this indicates that client attempts to construct additional WebTransport objects will fail. \n\nDoes receipt of a GOAWAY frame need to be indicated to the application, or can it just deal with a (future) constructor error? \n\nThe DRAIN_WEBTRANSPORT_SESSION capsule PR has been merged, but the draft including the merged PR has not been published yet. ",
          "createdAt": "2023-02-25T00:46:43Z",
          "updatedAt": "2023-02-25T00:46:43Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s4-frnz",
          "commit": {
            "abbreviatedOid": "2102a77"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Overall looks good modulo one comment ",
          "createdAt": "2022-07-23T02:31:36Z",
          "updatedAt": "2022-07-23T02:32:08Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "\"Datagram flows\" is not a well-defined term. Is the intent to discourage all datagrams?",
              "createdAt": "2022-07-23T02:31:36Z",
              "updatedAt": "2022-07-23T02:32:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5FKmCd",
          "commit": {
            "abbreviatedOid": "2102a77"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-28T17:31:22Z",
          "updatedAt": "2022-10-28T17:31:25Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Perhaps the same note we have about max sessions that the endpoints don't agree on how many there are so please don't try to enforce the limit? Or even just reference that?",
              "createdAt": "2022-10-28T17:31:22Z",
              "updatedAt": "2022-10-28T17:31:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5FKmhc",
          "commit": {
            "abbreviatedOid": "2102a77"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-28T17:33:14Z",
          "updatedAt": "2022-10-28T17:33:14Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I agree it's not well defined.  The intent was to prevent the application from starting new work over this session, but to allow it to finish existing work.  I don't think we should prevent sending all datagrams -- @DavidSchinazi do you have any text suggestions?",
              "createdAt": "2022-10-28T17:33:14Z",
              "updatedAt": "2022-10-28T17:33:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5FKqzO",
          "commit": {
            "abbreviatedOid": "2102a77"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-28T17:49:31Z",
          "updatedAt": "2022-10-28T17:49:31Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "@ekinnear : I'm not following how the stream limit is related here?",
              "createdAt": "2022-10-28T17:49:31Z",
              "updatedAt": "2022-10-28T17:49:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5FLi2t",
          "commit": {
            "abbreviatedOid": "2102a77"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-28T20:04:55Z",
          "updatedAt": "2022-10-28T20:04:56Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Maybe use the text about existing work vs new work then?",
              "createdAt": "2022-10-28T20:04:55Z",
              "updatedAt": "2022-10-28T20:04:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5FnaPk",
          "commit": {
            "abbreviatedOid": "2102a77"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-04T05:20:21Z",
          "updatedAt": "2022-11-04T05:20:22Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I'm not actually sure we should give specific guidance here.  \"Stop opening new streams\" makes sense for HTTP/3, but different protocols may have different drain sequence.  We should probably just describe what it means.",
              "createdAt": "2022-11-04T05:20:21Z",
              "updatedAt": "2022-11-04T05:20:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5GBjP5",
          "commit": {
            "abbreviatedOid": "2102a77"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-09T22:00:38Z",
          "updatedAt": "2022-11-09T22:00:39Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Maybe something simple like:\r\n\r\n```\r\nTo drain a WebTransport session, either endpoint can send a DRAIN_WEBTRANSPORT_SESSION capsule.  \r\nAfter sending or receiving a DRAIN_WEBTRANSPORT_SESSION capsule, an endpoint MAY continue using the session but SHOULD attempt to gracefully terminate the session as soon as possible.\r\n```",
              "createdAt": "2022-11-09T22:00:38Z",
              "updatedAt": "2022-11-09T22:00:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5H-dfr",
          "commit": {
            "abbreviatedOid": "2102a77"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-07T00:20:03Z",
          "updatedAt": "2022-12-07T00:20:04Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Sorry, \r\n> An endpoint SHOULD NOT initiate new WebTransport streams or datagram flows after sending or receiving a DRAIN_WEBTRANSPORT_SESSION capsule.\r\n\r\nDo both sides agree on the ordering between a new stream coming in vs. a DRAIN_WEBTRANSPORT_SESSION capsule? If not, then we may want to note that so that people plan on having them happen in any order.",
              "createdAt": "2022-12-07T00:20:04Z",
              "updatedAt": "2022-12-07T00:20:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5IzEGi",
          "commit": {
            "abbreviatedOid": "2102a77"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-16T19:21:33Z",
          "updatedAt": "2022-12-16T19:21:33Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Comment from editors -- replace endpoint with client to make it clear there is no action from the user-agent.",
              "createdAt": "2022-12-16T19:21:33Z",
              "updatedAt": "2022-12-16T19:21:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 80,
      "id": "PR_kwDOCvK98s47_7yw",
      "title": "clarify when the client can open streams and send datagrams",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/80",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #73.",
      "createdAt": "2022-07-24T20:05:28Z",
      "updatedAt": "2022-10-28T20:02:37Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "bf112a8a2ad97b90e23ed162a00a46f2f3c020a3",
      "headRepository": "marten-seemann/draft-ietf-webtrans-http3",
      "headRefName": "optimistic-session-establishment",
      "headRefOid": "9ef6128db2915c6bb63186bf7ab03d3210a41a3b",
      "closedAt": "2022-10-28T20:02:37Z",
      "mergedAt": "2022-10-28T20:02:36Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "8e322fee7215b88ee535750de98ff6b8df891f8e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s4-gc0p",
          "commit": {
            "abbreviatedOid": "9ef6128"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "(no hats)",
          "createdAt": "2022-07-24T22:39:37Z",
          "updatedAt": "2022-07-24T22:39:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5FKqMx",
          "commit": {
            "abbreviatedOid": "9ef6128"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-28T17:47:07Z",
          "updatedAt": "2022-10-28T17:47:07Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5FKqWc",
          "commit": {
            "abbreviatedOid": "9ef6128"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-28T17:47:43Z",
          "updatedAt": "2022-10-28T17:47:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 82,
      "id": "PR_kwDOCvK98s481TWX",
      "title": "Spelling and grammar nits",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/82",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- s/an WebTransport/a WebTransport\r\n- spellings\r\n",
      "createdAt": "2022-08-08T18:17:35Z",
      "updatedAt": "2022-08-09T14:28:31Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "bf112a8a2ad97b90e23ed162a00a46f2f3c020a3",
      "headRepository": "LPardue/draft-ietf-webtrans-http3",
      "headRefName": "spell-n-gram",
      "headRefOid": "15699230f07039b5e694024ae92e096babc9aeb0",
      "closedAt": "2022-08-09T14:28:31Z",
      "mergedAt": "2022-08-09T14:28:31Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "8465b77561ae31c02dd6dc3686657b25499a30bd"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 83,
      "id": "PR_kwDOCvK98s481f5s",
      "title": "Candidate bidi stream types extension",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/83",
      "state": "CLOSED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR speaks to comments I made on #71 and #81. It's intended to sketch out how HTTP/3 could be extended to support bidirectional stream type signalling with a fallback to standard HTTP/3 handling (Section 6.1 of RFC 9114 behaviour).\r\n\r\nThis could be taken further to define the same stream type value for the uni and bid cases, and expand on  error handling etc",
      "createdAt": "2022-08-08T19:13:00Z",
      "updatedAt": "2023-02-21T23:15:03Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "bf112a8a2ad97b90e23ed162a00a46f2f3c020a3",
      "headRepository": "LPardue/draft-ietf-webtrans-http3",
      "headRefName": "h3-frame-begone",
      "headRefOid": "209bf47cc15fef756853c885a2a87f91d475eed3",
      "closedAt": "2023-02-21T23:15:02Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: declaring this PR as overcome by events and closing",
          "createdAt": "2023-02-21T23:15:02Z",
          "updatedAt": "2023-02-21T23:15:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s4_5IOe",
          "commit": {
            "abbreviatedOid": "209bf47"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-08-13T10:43:02Z",
          "updatedAt": "2022-08-13T10:43:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5AP3Sh",
          "commit": {
            "abbreviatedOid": "209bf47"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "(no hats) The overall shape here seems odd to me: if client-initiated bidi streams now start with a stream type, then we should define an \"HTTP Request\" stream type, and require that clients send that before their HTTP frames. We also need to make sure that no frames types can ever conflict with stream types otherwise there is confusion?",
          "createdAt": "2022-08-18T19:40:48Z",
          "updatedAt": "2022-08-18T19:44:34Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "```suggestion\r\nWebTransport Bidirectional Stream Header {\r\n```",
              "createdAt": "2022-08-18T19:40:48Z",
              "updatedAt": "2022-08-18T19:44:34Z"
            },
            {
              "originalPosition": 66,
              "body": "It took me a second to grok this, so I'd suggest clarifying the fact that WebTransport is now using HTTP/3's unidirectional stream types for bidirectional streams. Luckily the IANA registry is just called \"HTTP/3 Stream Types\" so we're good there but making this clearer would help.",
              "createdAt": "2022-08-18T19:42:05Z",
              "updatedAt": "2022-08-18T19:44:34Z"
            },
            {
              "originalPosition": 104,
              "body": "Now I'm confused, which of these is true?\r\n1. we are using unidirectional stream types for both uni and bidi streams\r\n2. we are creating a separate concept of bidi stream types",
              "createdAt": "2022-08-18T19:43:16Z",
              "updatedAt": "2022-08-18T19:44:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 86,
      "id": "PR_kwDOCvK98s5By87I",
      "title": "Capsule design team output [HTTP/3]",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/86",
      "state": "MERGED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Capsule design team output. Minimal changes to HTTP/3, which was already using capsules and is now joined by [HTTP/2](https://github.com/ietf-wg-webtrans/draft-webtransport-http2/pull/58).\r\n\r\nSame content as [draft PR](), thank you to those who have already reviewed!\r\n\r\nCloses #22\r\nCloses #34 \r\nCloses #66",
      "createdAt": "2022-10-29T08:03:05Z",
      "updatedAt": "2022-12-16T19:10:37Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "8e322fee7215b88ee535750de98ff6b8df891f8e",
      "headRepository": "ekinnear/draft-ietf-webtrans-http3",
      "headRefName": "capsule_design_team",
      "headRefOid": "2a70fb14d9a8082d2a765488405a4e3fa10a7643",
      "closedAt": "2022-12-16T19:10:11Z",
      "mergedAt": "2022-12-16T19:10:11Z",
      "mergedBy": "ekinnear",
      "mergeCommit": {
        "oid": "4f5f21a40c744521d289f754d773f150d30e3bee"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Does this actually close #22 with a no-op, or are we supposed to discuss that at 115?\r\n\r\nOtherwise LGTM.",
          "createdAt": "2022-11-04T04:15:20Z",
          "updatedAt": "2022-11-04T04:15:20Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "It closes #22 as a no-op with the exception of one bullet point that we did want to address, that got split out into #85, which we'll discuss at 115 separately from this PR.",
          "createdAt": "2022-11-06T15:06:48Z",
          "updatedAt": "2022-11-06T15:06:48Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "[Consensus declared](https://mailarchive.ietf.org/arch/msg/webtransport/shBK8WFsC9aWihBCy--e-7kKhRc/)",
          "createdAt": "2022-12-16T19:10:37Z",
          "updatedAt": "2022-12-16T19:10:37Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 87,
      "id": "PR_kwDOCvK98s5CL0a5",
      "title": "Clarify SETTINGS behavior for 0-RTT",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/87",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #45",
      "createdAt": "2022-11-04T05:31:36Z",
      "updatedAt": "2022-12-16T19:28:38Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "8e322fee7215b88ee535750de98ff6b8df891f8e",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "0rtt",
      "headRefOid": "2bd9a95725e7580fda3ffedb4036cb037ba9969b",
      "closedAt": "2022-12-16T19:28:38Z",
      "mergedAt": "2022-12-16T19:28:38Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "177e2348da14bf6a76a8bd5637de3d69666120a2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5FtpNK",
          "commit": {
            "abbreviatedOid": "7b7af2e"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM modulo one ambiguous point, cf comment",
          "createdAt": "2022-11-06T13:00:32Z",
          "updatedAt": "2022-11-06T13:00:49Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\n7.2.4.2 of [HTTP3].  If the server accepts 0-RTT, the server MUST NOT reduce the limit of\r\n```",
              "createdAt": "2022-11-06T13:00:32Z",
              "updatedAt": "2022-11-06T13:00:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5IzFrv",
          "commit": {
            "abbreviatedOid": "751ff0b"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-16T19:27:39Z",
          "updatedAt": "2022-12-16T19:27:40Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nClients cannot initiate WebTransport in 0-RTT packets, as the CONNECT method is not considered safe; see {{Section 10.9 of HTTP3}}. However, WebTransport-related SETTINGS\r\n```",
              "createdAt": "2022-12-16T19:27:39Z",
              "updatedAt": "2022-12-16T19:28:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 88,
      "id": "PR_kwDOCvK98s5CL20M",
      "title": "Add recommendation text for throttling",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/88",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #50.",
      "createdAt": "2022-11-04T05:48:24Z",
      "updatedAt": "2022-12-16T19:22:55Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "8e322fee7215b88ee535750de98ff6b8df891f8e",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "throttling",
      "headRefOid": "9eff286e0b2c4c64a732ad7ce066a3623d3afdc0",
      "closedAt": "2022-12-16T19:22:55Z",
      "mergedAt": "2022-12-16T19:22:55Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "193971ee7f1b81c417c80d8de1c628f9a49509c4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5FtpQH",
          "commit": {
            "abbreviatedOid": "b7ddc95"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-11-06T13:01:57Z",
          "updatedAt": "2022-11-06T13:03:52Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Avoid lower-case RFC 2119 keywords:\r\n```suggestion\r\nA client could attempt to exhaust resources by opening too many WebTransport\r\n```",
              "createdAt": "2022-11-06T13:01:57Z",
              "updatedAt": "2022-11-06T13:03:52Z"
            },
            {
              "originalPosition": 5,
              "body": "I don't understand this, who is the client if there is a user-agent in the picture?",
              "createdAt": "2022-11-06T13:03:45Z",
              "updatedAt": "2022-11-06T13:03:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5FtqbE",
          "commit": {
            "abbreviatedOid": "b7ddc95"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-11-06T13:37:39Z",
          "updatedAt": "2022-11-06T13:37:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "https://www.ietf.org/archive/id/draft-ietf-webtrans-overview-04.html#name-conventions-and-definitions-2",
              "createdAt": "2022-11-06T13:37:40Z",
              "updatedAt": "2022-11-06T13:37:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5Ftqfq",
          "commit": {
            "abbreviatedOid": "9eff286"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-11-06T13:39:44Z",
          "updatedAt": "2022-11-06T13:39:48Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Ah, thanks.",
              "createdAt": "2022-11-06T13:39:44Z",
              "updatedAt": "2022-11-06T13:39:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5IzETc",
          "commit": {
            "abbreviatedOid": "9eff286"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-16T19:22:18Z",
          "updatedAt": "2022-12-16T19:22:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 91,
      "id": "PR_kwDOCvK98s5Fq7AU",
      "title": "Remove SETTINGS_MAX_WEBTRANSPORT_SESSIONS",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/91",
      "state": "CLOSED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Doing this all together later, so keeping this out for now",
      "createdAt": "2022-12-16T19:45:34Z",
      "updatedAt": "2022-12-16T19:47:37Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "177e2348da14bf6a76a8bd5637de3d69666120a2",
      "headRepository": "ekinnear/draft-ietf-webtrans-http3",
      "headRefName": "ek/remove_max_sessions",
      "headRefOid": "8a77e902e4e82d3d0a2431b4010ed5adae454ef7",
      "closedAt": "2022-12-16T19:47:36Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "(Discussed with chairs and editors, we know there are outstanding changes, but leaving this for now)",
          "createdAt": "2022-12-16T19:47:36Z",
          "updatedAt": "2022-12-16T19:47:36Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 93,
      "id": "PR_kwDOCvK98s5JeSgF",
      "title": "Require sending SETTINGS_ENABLE_CONNECT_PROTOCOL",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/93",
      "state": "MERGED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #68",
      "createdAt": "2023-02-07T22:30:39Z",
      "updatedAt": "2023-02-07T23:10:07Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "177e2348da14bf6a76a8bd5637de3d69666120a2",
      "headRepository": "ekinnear/draft-ietf-webtrans-http3",
      "headRefName": "ek/connect_protocol_setting",
      "headRefOid": "66f1ad668bd3181d2936850dc3e3f56826a2b2c4",
      "closedAt": "2023-02-07T23:10:02Z",
      "mergedAt": "2023-02-07T23:10:02Z",
      "mergedBy": "ekinnear",
      "mergeCommit": {
        "oid": "2a5f61f496cd523bcf481ad53118b76ca94442b3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5Mxya8",
          "commit": {
            "abbreviatedOid": "66f1ad6"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-07T22:48:18Z",
          "updatedAt": "2023-02-07T22:48:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5Mxy9s",
          "commit": {
            "abbreviatedOid": "66f1ad6"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-07T22:50:47Z",
          "updatedAt": "2023-02-07T22:50:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 94,
      "id": "PR_kwDOCvK98s5KRpr4",
      "title": "Relax the Origin header requirement",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/94",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is vaguely based on the similar text in the WebSocket RFC.\r\n\r\nFixes #92.",
      "createdAt": "2023-02-18T22:14:08Z",
      "updatedAt": "2023-02-21T23:08:28Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "9a060df91c98065251241a79ce55d30a0895edd5",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "origin-opt",
      "headRefOid": "622947cb8efd67d9c2f81e809281c275e65bfdb5",
      "closedAt": "2023-02-21T23:08:25Z",
      "mergedAt": "2023-02-21T23:08:25Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "690fdc7ced73be95b00dde7ae2beb92f908b1031"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5Nw8fM",
          "commit": {
            "abbreviatedOid": "622947c"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Lgtm, totally makes sense to keep this for browsers.",
          "createdAt": "2023-02-18T23:13:00Z",
          "updatedAt": "2023-02-18T23:13:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5Nw8fY",
          "commit": {
            "abbreviatedOid": "622947c"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-18T23:13:17Z",
          "updatedAt": "2023-02-18T23:13:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5NyTmb",
          "commit": {
            "abbreviatedOid": "622947c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-20T03:58:43Z",
          "updatedAt": "2023-02-20T03:58:43Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5N-vr-",
          "commit": {
            "abbreviatedOid": "622947c"
          },
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-21T23:06:52Z",
          "updatedAt": "2023-02-21T23:06:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5N-v-K",
          "commit": {
            "abbreviatedOid": "622947c"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-21T23:08:21Z",
          "updatedAt": "2023-02-21T23:08:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 95,
      "id": "PR_kwDOCvK98s5KRsJ3",
      "title": "Document how to close both the session and the underlying connection",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/95",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is mostly based on what Chrome currently does in production.\r\n\r\nFixes #89.",
      "createdAt": "2023-02-18T23:20:56Z",
      "updatedAt": "2023-03-07T23:30:32Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "9a060df91c98065251241a79ce55d30a0895edd5",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "close-connection",
      "headRefOid": "68e503ddd1d21666b378404f4f4283793f288b22",
      "closedAt": "2023-03-07T23:30:31Z",
      "mergedAt": "2023-03-07T23:30:31Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "8e5f80789151c3f5e0853c0445454a41029f59fb"
      },
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed during editor's meeting, plan is to remove text about 3 PTO and note that delivering other open streams is best-effort. Also add rationale and mention that this aligns with what QUIC does - this message has similar delivery guarantees as the close_connection in QUIC",
          "createdAt": "2023-02-21T23:46:34Z",
          "updatedAt": "2023-02-21T23:46:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5Nx55t",
          "commit": {
            "abbreviatedOid": "b08a434"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "My first observation here is that we probably want to treat a closing signal akin to reliable, ordered application data in this context.  That is, we want to provide the same delivery guarantees for the close on the stream/session as the last message that is sent on a stream.\r\n\r\nTo that end, we might seek to retain connections until data is acknowledged.  That's a general requirement that is not specific to the close signal.  The only reason that close is special is twofold:\r\n\r\n1. It is highly desirable that close be infallible.  That is, the operation cannot fail.\r\n2. Closing a session is often followed by closing the connection.\r\n\r\nThough on the latter point, maybe it is better if a site is not directly aware of the closure of the underlying connection, any more than it is aware of the operation of a garbage collector.\r\n\r\nSo I don't think that this is the right framing for this change.  \r\n\r\nI'm split on what the right outcome might be.  If the goal is to execute a close that is infallible, then we probably shouldn't add any sort of reliability.  In that case, an application can execute its own shutdown, gaining any confirmation it needs with its own messages.  Close messages at this layer become best-effort.\r\n\r\n(This is orthogonal to the use of the close message for connection- and session-management purposes.  We've already decided that the session close message is useful, particularly in the case where you have multiple sessions sharing a connection.)\r\n\r\nAlternatively, we provide a shutdown capability that builds on the closing messages.  This can fail.  For this, I'm having trouble with is that acknowledgment state is not something that we guarantee at the application layer.  Maybe [this](https://quicwg.org/base-drafts/rfc9000.html#section-2.4-6) might be used to monitor for a state transition to the [Data Recvd](https://quicwg.org/base-drafts/rfc9000.html#fig-stream-send-states) state, but I'm not sure if this is something that can be reliably implemented.",
          "createdAt": "2023-02-20T00:53:40Z",
          "updatedAt": "2023-02-20T01:46:00Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\ninterval ({{!RFC9002, Section 6.2}}) elapses, before sending the\r\n```",
              "createdAt": "2023-02-20T00:53:40Z",
              "updatedAt": "2023-02-20T01:46:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5N-vac",
          "commit": {
            "abbreviatedOid": "b08a434"
          },
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-21T23:05:31Z",
          "updatedAt": "2023-02-21T23:05:31Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5N-wHM",
          "commit": {
            "abbreviatedOid": "b08a434"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-21T23:09:02Z",
          "updatedAt": "2023-02-21T23:09:16Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nwith detailed close information and then immediately close the underlying QUIC\r\n```",
              "createdAt": "2023-02-21T23:09:02Z",
              "updatedAt": "2023-02-21T23:09:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5PQeRi",
          "commit": {
            "abbreviatedOid": "68e503d"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-07T23:29:43Z",
          "updatedAt": "2023-03-07T23:29:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 96,
      "id": "PR_kwDOCvK98s5KRus6",
      "title": "Clarify the nature of WEBTRANSPORT_STREAM",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/96",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also ban sending it anywhere that's not the beginning of the stream.\r\n\r\nFixes #71\r\nPotentially also fixes #48 and #81",
      "createdAt": "2023-02-19T00:30:33Z",
      "updatedAt": "2023-02-21T23:10:57Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "9a060df91c98065251241a79ce55d30a0895edd5",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "unidi-stream",
      "headRefOid": "b397959b5c387e82488965e0a09d34e00d6d2a9b",
      "closedAt": "2023-02-21T23:10:57Z",
      "mergedAt": "2023-02-21T23:10:57Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "d59173ea15ea094eee81a3b2a35913fd26efa2c4"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @LPardue ",
          "createdAt": "2023-02-19T00:30:42Z",
          "updatedAt": "2023-02-19T00:30:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5N-wcg",
          "commit": {
            "abbreviatedOid": "b397959"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-21T23:10:41Z",
          "updatedAt": "2023-02-21T23:10:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5N-wfA",
          "commit": {
            "abbreviatedOid": "b397959"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-21T23:10:52Z",
          "updatedAt": "2023-02-21T23:10:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 97,
      "id": "PR_kwDOCvK98s5LF3aD",
      "title": "Clarify Frame Type Registration section",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/97",
      "state": "MERGED",
      "author": "nidhijaju",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This updates the IANA considerations section for Frame Type to match https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-http3-04#section-4.2, by including \"server-initiated\" in the type of bidirectional streams allowed by the `WEBTRANSPORT_STREAM` frame.",
      "createdAt": "2023-03-02T04:48:43Z",
      "updatedAt": "2023-03-02T06:44:27Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "d59173ea15ea094eee81a3b2a35913fd26efa2c4",
      "headRepository": "nidhijaju/draft-ietf-webtrans-http3",
      "headRefName": "clarify-frame-type-section",
      "headRefOid": "2da17b0b2f5aad12a57699799d2acab4086e53d7",
      "closedAt": "2023-03-02T06:44:27Z",
      "mergedAt": "2023-03-02T06:44:27Z",
      "mergedBy": "ekinnear",
      "mergeCommit": {
        "oid": "4b226708d571cc2bcfb84a05f1c633a5886a02ba"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5OvUxl",
          "commit": {
            "abbreviatedOid": "47e5b6f"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-02T04:50:17Z",
          "updatedAt": "2023-03-02T04:50:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5Ovnkx",
          "commit": {
            "abbreviatedOid": "47e5b6f"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-02T06:31:30Z",
          "updatedAt": "2023-03-02T06:31:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 98,
      "id": "PR_kwDOCvK98s5LLflq",
      "title": "Clarify status code for Origin verification",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/98",
      "state": "MERGED",
      "author": "bashi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In https://github.com/web-platform-tests/wpt/pull/38782, it was suggested that 403 status code should be used when Origin verification fails.",
      "createdAt": "2023-03-03T00:34:43Z",
      "updatedAt": "2023-03-04T00:05:36Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "4b226708d571cc2bcfb84a05f1c633a5886a02ba",
      "headRepository": "bashi/draft-ietf-webtrans-http3",
      "headRefName": "clarify-origin-check",
      "headRefOid": "86615747f1f48b1857990d65921251bf81f19d40",
      "closedAt": "2023-03-04T00:05:35Z",
      "mergedAt": "2023-03-04T00:05:35Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "c4ed3ed6f594d18491d7bbcac47cc4a618c5bc1d"
      },
      "comments": [
        {
          "author": "bashi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for suggestions! Applied.",
          "createdAt": "2023-03-03T06:57:04Z",
          "updatedAt": "2023-03-03T06:57:04Z"
        },
        {
          "author": "bashi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for reviews! If this looks good can someone merge this?",
          "createdAt": "2023-03-04T00:04:22Z",
          "updatedAt": "2023-03-04T00:04:22Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5O3MMy",
          "commit": {
            "abbreviatedOid": "377a299"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-03T04:44:33Z",
          "updatedAt": "2023-03-03T04:44:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5O3hjY",
          "commit": {
            "abbreviatedOid": "377a299"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looking good, thank you! Added a few suggestions to cause it to generate links to the actual sections referenced, even if it makes it a little more repetitive.",
          "createdAt": "2023-03-03T06:46:01Z",
          "updatedAt": "2023-03-03T06:52:14Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\ndoes not, it SHOULD reply with status code 404 ({{Section 15.5.5 of !HTTP=RFC9110}}).\r\n```",
              "createdAt": "2023-03-03T06:46:01Z",
              "updatedAt": "2023-03-03T06:52:14Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nSHOULD reply with status code 403 ({{Section 15.5.4 of HTTP}}).  If all checks pass, the\r\n```",
              "createdAt": "2023-03-03T06:46:23Z",
              "updatedAt": "2023-03-03T06:52:14Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\ncode, as defined in {{Section 15.3 of HTTP}}.\r\n```",
              "createdAt": "2023-03-03T06:46:42Z",
              "updatedAt": "2023-03-03T06:52:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5O76UT",
          "commit": {
            "abbreviatedOid": "0c27fb1"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Approved modulo one small change",
          "createdAt": "2023-03-03T17:19:43Z",
          "updatedAt": "2023-03-03T17:21:30Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nWhen the request contains the `Origin` header, the WebTransport server MUST verify\r\n```",
              "createdAt": "2023-03-03T17:19:43Z",
              "updatedAt": "2023-03-03T17:21:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 99,
      "id": "PR_kwDOCvK98s5Lgjro",
      "title": "Allow STOP_SENDING with CLOSE_WEBTRANSPORT_SESSION",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/99",
      "state": "MERGED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes: #78",
      "createdAt": "2023-03-07T19:30:48Z",
      "updatedAt": "2023-03-07T23:34:34Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "c4ed3ed6f594d18491d7bbcac47cc4a618c5bc1d",
      "headRepository": "afrind/draft-ietf-webtrans-http3",
      "headRefName": "stop-sending",
      "headRefOid": "7945301f86efce322fa15071541938c10eb83679",
      "closedAt": "2023-03-07T23:34:33Z",
      "mergedAt": "2023-03-07T23:34:33Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "a4db094590e43720ed278a2d3a9f6127483f4009"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5PQeg4",
          "commit": {
            "abbreviatedOid": "72a848f"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Fix the typo, raise an issue for the other thing.",
          "createdAt": "2023-03-07T23:30:56Z",
          "updatedAt": "2023-03-07T23:33:19Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nAn endpoint that sends a CLOSE_WEBTRANSPORT_SESSION capsule MUST immediately send\r\n```",
              "createdAt": "2023-03-07T23:30:56Z",
              "updatedAt": "2023-03-07T23:33:19Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nfrom the CONNECT stream.  The recipient MUST terminate the session upon receiving a\r\nFIN.  (what victor said about what terminating entails.) If any additional stream data is received on the CONNECT stream after\r\n```",
              "createdAt": "2023-03-07T23:32:49Z",
              "updatedAt": "2023-03-07T23:33:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 103,
      "id": "PR_kwDOCvK98s5LiJC2",
      "title": "Expand on HTTP/3 extension aspects",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/103",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "By switching from Frames to special signal values at byte position 0,\r\nwe are really extending HTTP/3 rules. So this is an attempt to paint\r\nthat out more cleanly and tidy up some loose ends or stale text in the\r\ndraft.\r\n\r\nThe outcome is that we make it clear that WebTransport streams never use\r\nframes. Instead, they are always a sequence of some preamble at the\r\nstart of a stream, followed by a session ID, followed by user-specified\r\nstream data. This makes it more obvious that endpoints should never send\r\n0x41 such that the peer could interpret it as being a frame on any\r\nframe-bearing stream (like the control stream). If you understand\r\nWebTransport but didn't enable it, then receiving 0x41 is also bad, so\r\nblow up.",
      "createdAt": "2023-03-08T02:31:01Z",
      "updatedAt": "2023-04-18T22:09:47Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "14774910fc88b98ec458d3b8081e7e72bdc47d8b",
      "headRepository": "LPardue/draft-ietf-webtrans-http3",
      "headRefName": "make-bidi-stream-more-of-an-extension",
      "headRefOid": "c701ab0c31da8c54be407bf47016b73d66e46e25",
      "closedAt": "2023-04-18T22:09:47Z",
      "mergedAt": "2023-04-18T22:09:47Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "44b8d1dec6082c8c2fe14fc6559a8ac628441b7b"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, noticed I can't actually merge this because conflicts.  I'll leave the comments instead.",
          "createdAt": "2023-03-13T21:02:12Z",
          "updatedAt": "2023-03-13T21:02:12Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "@vasilvv can you fix the conflict and then merge?",
          "createdAt": "2023-03-13T21:09:57Z",
          "updatedAt": "2023-03-13T21:09:57Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> @vasilvv can you fix the conflict and then merge?\r\n\r\nSince this is mostly editorial, I don't see the need to rush it.",
          "createdAt": "2023-03-13T21:15:59Z",
          "updatedAt": "2023-03-13T21:15:59Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed during editor's meeting, we'll merge this as-is and keep #107 open to track the diagrams.",
          "createdAt": "2023-04-18T22:09:28Z",
          "updatedAt": "2023-04-18T22:09:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5Pv21C",
          "commit": {
            "abbreviatedOid": "6c778c2"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM modulo the following:\r\n- I don't think the signal values make sense in a separate draft since their use is inherently tied to WebTransport.\r\n- Some minor wording things.\r\n\r\nI will merge this as-is and fix the editorial things in a follow-up commit.",
          "createdAt": "2023-03-13T21:01:20Z",
          "updatedAt": "2023-03-13T21:01:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5Pv5-F",
          "commit": {
            "abbreviatedOid": "6c778c2"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-13T21:11:02Z",
          "updatedAt": "2023-03-13T21:11:30Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Kind of sad to add a TODO here vs. just having an issue for it?",
              "createdAt": "2023-03-13T21:11:02Z",
              "updatedAt": "2023-03-13T21:11:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5Pv6Ol",
          "commit": {
            "abbreviatedOid": "6c778c2"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T21:11:55Z",
          "updatedAt": "2023-03-13T21:11:56Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "(Just if already fixing conflicts)",
              "createdAt": "2023-03-13T21:11:55Z",
              "updatedAt": "2023-03-13T21:11:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5Pv3Yd",
          "commit": {
            "abbreviatedOid": "6c778c2"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T21:03:07Z",
          "updatedAt": "2023-03-13T21:15:12Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "\"both support WebTransport over HTTP/3, including the necessary extensions to the HTTP/3 syntax\".",
              "createdAt": "2023-03-13T21:03:07Z",
              "updatedAt": "2023-03-13T21:15:12Z"
            },
            {
              "originalPosition": 65,
              "body": "I would prefer to use \"syntax\" instead of \"rules\" here and elsewhere.",
              "createdAt": "2023-03-13T21:06:25Z",
              "updatedAt": "2023-03-13T21:15:12Z"
            },
            {
              "originalPosition": 66,
              "body": "Note that the client may actually send the streams before establishing a transport -- what's required here is that the sender knows that the peer supports WT.",
              "createdAt": "2023-03-13T21:08:36Z",
              "updatedAt": "2023-03-13T21:15:12Z"
            },
            {
              "originalPosition": 77,
              "body": "I'm not sure the special values make sense in a separate draft, since they are WT specific.  The old TODO was referring to a separate draft for defining syntax of server-initiated bidi streams.",
              "createdAt": "2023-03-13T21:14:54Z",
              "updatedAt": "2023-03-13T21:15:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5Pv7TG",
          "commit": {
            "abbreviatedOid": "6c778c2"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T21:15:10Z",
          "updatedAt": "2023-03-13T21:15:15Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "This is effectively just porting the old TODO that existed into this. I agree it could actually be an issue, or just removed if we don't want to do it (as Victor suggested, making a standalone HTTP extension with no context seems a bit problematic)",
              "createdAt": "2023-03-13T21:15:10Z",
              "updatedAt": "2023-03-13T21:15:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5PwABr",
          "commit": {
            "abbreviatedOid": "6c778c2"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T21:29:35Z",
          "updatedAt": "2023-03-13T21:29:35Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Fair enough \ud83d\ude03 ",
              "createdAt": "2023-03-13T21:29:35Z",
              "updatedAt": "2023-03-13T21:29:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5PwE75",
          "commit": {
            "abbreviatedOid": "6c778c2"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T21:48:20Z",
          "updatedAt": "2023-03-13T21:48:21Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "RFC9114 doesn't declare stream types as syntax though. And the problem is you can send things with the correct byte layout but in the wrong order, which violates the rules set out in 9114 Section 4.1. Specifically, I used `rule(s)` as a direct reference to https://www.rfc-editor.org/rfc/rfc9114.html#section-4.1-7\r\n\r\n> Receipt of an invalid sequence of frames MUST be treated as a [connection error](https://www.rfc-editor.org/rfc/rfc9114.html#errors) of type [H3_FRAME_UNEXPECTED](https://www.rfc-editor.org/rfc/rfc9114.html#H3_FRAME_UNEXPECTED). In particular, a [DATA](https://www.rfc-editor.org/rfc/rfc9114.html#frame-data) frame before any [HEADERS](https://www.rfc-editor.org/rfc/rfc9114.html#frame-headers) frame, or a [HEADERS](https://www.rfc-editor.org/rfc/rfc9114.html#frame-headers) or [DATA](https://www.rfc-editor.org/rfc/rfc9114.html#frame-data) frame after the trailing [HEADERS](https://www.rfc-editor.org/rfc/rfc9114.html#frame-headers) frame, is considered invalid. Other frame types, especially unknown frame types, might be permitted subject to their own rules; see [Section 9](https://www.rfc-editor.org/rfc/rfc9114.html#extensions).\r\n\r\n",
              "createdAt": "2023-03-13T21:48:21Z",
              "updatedAt": "2023-03-13T21:48:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5PwFDB",
          "commit": {
            "abbreviatedOid": "6c778c2"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T21:48:48Z",
          "updatedAt": "2023-03-13T21:48:48Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "good point!",
              "createdAt": "2023-03-13T21:48:48Z",
              "updatedAt": "2023-03-13T21:48:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5PwGaE",
          "commit": {
            "abbreviatedOid": "6c778c2"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T21:54:26Z",
          "updatedAt": "2023-03-13T21:54:27Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Since you've said the TODO doesn't carry over I'll remove it. \r\n\r\nI tend to agree that trying to make this a generic HTTP/3 extension in the abstract is probably not going to help people but that is something the HTTP WG should be consulted on too. A TODO isn't a good way to track that process though.",
              "createdAt": "2023-03-13T21:54:26Z",
              "updatedAt": "2023-03-13T21:54:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5RUqQ0",
          "commit": {
            "abbreviatedOid": "c701ab0"
          },
          "author": "huitema",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-30T05:48:07Z",
          "updatedAt": "2023-03-30T05:48:08Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Shouldn't there be some curly braces, as in:\r\n~~~\r\nBidirectional Stream {\r\n    Signal Value (i) = 0x41,\r\n    Session ID (i),\r\n    Stream Body (..)\r\n}\r\n~~~",
              "createdAt": "2023-03-30T05:48:07Z",
              "updatedAt": "2023-03-30T05:48:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5RkP84",
          "commit": {
            "abbreviatedOid": "c701ab0"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-03T07:41:37Z",
          "updatedAt": "2023-04-03T07:41:37Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Indeed (both here and in the diagram above).",
              "createdAt": "2023-04-03T07:41:37Z",
              "updatedAt": "2023-04-03T07:41:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 104,
      "id": "PR_kwDOCvK98s5LiL0Q",
      "title": "DATAGRAMS is RFC",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/104",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-03-08T02:43:51Z",
      "updatedAt": "2023-03-08T17:16:36Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "a4db094590e43720ed278a2d3a9f6127483f4009",
      "headRepository": "LPardue/draft-ietf-webtrans-http3",
      "headRefName": "datagrams-is-rfc",
      "headRefOid": "8e6a319b71001110d679c1f31b07634a75af5748",
      "closedAt": "2023-03-08T17:16:35Z",
      "mergedAt": "2023-03-08T17:16:35Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "b96fd947d3b7edb94db91f38a95d16712625ca64"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5PVxzw",
          "commit": {
            "abbreviatedOid": "8e6a319"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-08T17:16:30Z",
          "updatedAt": "2023-03-08T17:16:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 105,
      "id": "PR_kwDOCvK98s5LzzUl",
      "title": "Rewrap",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/105",
      "state": "MERGED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Noticed we had a few oddly long lines, so I hit the rewrap button.",
      "createdAt": "2023-03-11T00:09:34Z",
      "updatedAt": "2023-03-11T01:27:55Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "b96fd947d3b7edb94db91f38a95d16712625ca64",
      "headRepository": "ekinnear/draft-ietf-webtrans-http3",
      "headRefName": "ek/rewrap",
      "headRefOid": "8ffe5f97a4c083c28364dfa8fd3d21af7b303c42",
      "closedAt": "2023-03-11T00:57:56Z",
      "mergedAt": "2023-03-11T00:57:56Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "e1f3ac91038cc5d2c913282cf49ea53664a0629e"
      },
      "comments": [
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "> What tool do you use that has a rewrap button?\r\n\r\nThis was Sublime, but many others will attempt to do the same :)",
          "createdAt": "2023-03-11T01:27:55Z",
          "updatedAt": "2023-03-11T01:27:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5Pni1z",
          "commit": {
            "abbreviatedOid": "03ca1bd"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "What tool do you use that has a rewrap button?",
          "createdAt": "2023-03-11T00:10:36Z",
          "updatedAt": "2023-03-11T00:10:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5Pnmyg",
          "commit": {
            "abbreviatedOid": "8ffe5f9"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-11T00:57:49Z",
          "updatedAt": "2023-03-11T00:57:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 106,
      "id": "PR_kwDOCvK98s5Lz1wG",
      "title": "Require SETTINGS_H3_DATAGRAM and max_datagram_frame_size TP",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/106",
      "state": "MERGED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Require SETTINGS_H3_DATAGRAM and max_datagram_frame_size TP\r\n\r\nCloses #84",
      "createdAt": "2023-03-11T00:33:57Z",
      "updatedAt": "2023-03-13T21:15:43Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "b96fd947d3b7edb94db91f38a95d16712625ca64",
      "headRepository": "ekinnear/draft-ietf-webtrans-http3",
      "headRefName": "ek/settings",
      "headRefOid": "dab097a9a157f2b186cc96f3d0fb02674ea198d3",
      "closedAt": "2023-03-13T20:46:06Z",
      "mergedAt": "2023-03-13T20:46:06Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "14774910fc88b98ec458d3b8081e7e72bdc47d8b"
      },
      "comments": [
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "> Would this be easier to process as a list rather than multiple separate requirements?\r\n\r\nInteresting thought. One way to do that replaces the entire section with this: \r\n```\r\nIn order to indicate support for WebTransport, both the client and the server\r\nneed to exchange a number of indicators enabling required protocol features.\r\nBoth the client and the server MUST send the following indicators, and MUST\r\nclose the connection with the H3_SETTINGS_ERROR error code if they receive a\r\nvalue other than the ones indicated here:\r\n\r\n- A max_datagram_frame_size QUIC transport parameter with a value greater than\r\n  0 (see {{Section 3 of !QUIC-DATAGRAM=RFC9221}}).\r\n\r\n- A SETTINGS_H3_DATAGRAM setting with a value set to 1 (see {{Section 2.1.1 of\r\n  HTTP-DATAGRAM}}).\r\n\r\n- A SETTINGS_MAX_WEBTRANSPORT_SESSIONS setting with a value greater than 0.\r\n\r\n- A SETTINGS_ENABLE_WEBTRANSPORT setting with a value set to 1.\r\n\r\nThe client MUST NOT send a WebTransport request until it has received the\r\nSETTINGS_ENABLE_WEBTRANSPORT setting with a value set to 1 from the server.\r\nSimilarly, the server MUST NOT process any incoming WebTransport requests until\r\nthe client settings have been received, as the client may be using a version of\r\nWebTransport that is different from the one used by the server.\r\n```\r\n\r\nThis is certainly more concise, although it does also remove some of the explanations that help people understand the various layers involved. Or perhaps we should include those same additional details but just turn those paragraphs into bullets?",
          "createdAt": "2023-03-13T17:28:25Z",
          "updatedAt": "2023-03-13T17:35:28Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "> The server shouldn't close the connection because it's legal for the client to not support datagrams if it only sends GETs and POSTs.\r\n\r\nWhile technically true, I thought we'd said that we wanted to require all the features all of the time, but agreed, let's take that to an editorial issue if needed.",
          "createdAt": "2023-03-13T21:07:03Z",
          "updatedAt": "2023-03-13T21:07:03Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "My point is that the server could support both regular HTTP and WebTransport.\r\n* If a client comes in without webtransport settings and only sends GETs, that's fine.\r\n* If a client comes in with webtransport settings and makes a webtransport request, that's fine.\r\n* If a client comes in without webtransport settings and makes a webtransport request, that's not fine. In that case the server needs to reject the webtransport request, not kill the connection.",
          "createdAt": "2023-03-13T21:13:11Z",
          "updatedAt": "2023-03-13T21:13:11Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, that makes more sense, thank you \ud83d\ude03 ",
          "createdAt": "2023-03-13T21:14:02Z",
          "updatedAt": "2023-03-13T21:14:14Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5Po4Bs",
          "commit": {
            "abbreviatedOid": "dab097a"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Would this be easier to process as a list rather than multiple separate requirements?",
          "createdAt": "2023-03-13T00:30:07Z",
          "updatedAt": "2023-03-13T00:30:07Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5Pu9ma",
          "commit": {
            "abbreviatedOid": "dab097a"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The list text in that comment isn't correct - the server shouldn't close the connection because it's legal for the client to not support datagrams if it only sends GETs and POSTs.\r\n\r\nHowever, the text in this PR is correct. I propose we land the PR as-is and can make editorial changes later.",
          "createdAt": "2023-03-13T18:27:17Z",
          "updatedAt": "2023-03-13T18:27:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5PvwGT",
          "commit": {
            "abbreviatedOid": "dab097a"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-13T20:42:52Z",
          "updatedAt": "2023-03-13T20:42:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 109,
      "id": "PR_kwDOCvK98s5NdZaR",
      "title": "Fix up references to setting names",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/109",
      "state": "MERGED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Fix up references to setting names\r\n\r\nFixes #108",
      "createdAt": "2023-04-03T07:15:59Z",
      "updatedAt": "2023-04-03T07:37:55Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "14774910fc88b98ec458d3b8081e7e72bdc47d8b",
      "headRepository": "ekinnear/draft-ietf-webtrans-http3",
      "headRefName": "ek/settings_names",
      "headRefOid": "432d9e9a705462d8797ec209e5b16b59be03394a",
      "closedAt": "2023-04-03T07:37:50Z",
      "mergedAt": "2023-04-03T07:37:50Z",
      "mergedBy": "ekinnear",
      "mergeCommit": {
        "oid": "aa9ddd3f7bd27ce21e41a4ad1f8f7748e2953d9f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5RkHP-",
          "commit": {
            "abbreviatedOid": "432d9e9"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-03T07:17:43Z",
          "updatedAt": "2023-04-03T07:17:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 113,
      "id": "PR_kwDOCvK98s5OfFg9",
      "title": "Discuss redirect handling",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/113",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #61",
      "createdAt": "2023-04-17T14:33:53Z",
      "updatedAt": "2023-04-24T05:00:12Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "aa9ddd3f7bd27ce21e41a4ad1f8f7748e2953d9f",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "redirects",
      "headRefOid": "0b0789632b87c1b8e7d29b0cdded05cab9ee8100",
      "closedAt": "2023-04-18T22:13:23Z",
      "mergedAt": "2023-04-18T22:13:22Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "b916be9f38aec71ce3ca36fd1e4bf9f7a17bc360"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5SyWb6",
          "commit": {
            "abbreviatedOid": "c125038"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-17T20:56:21Z",
          "updatedAt": "2023-04-17T20:56:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5S6QW2",
          "commit": {
            "abbreviatedOid": "c125038"
          },
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-18T22:11:30Z",
          "updatedAt": "2023-04-18T22:11:30Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5S6QbK",
          "commit": {
            "abbreviatedOid": "c125038"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-18T22:11:50Z",
          "updatedAt": "2023-04-18T22:11:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5S6QlL",
          "commit": {
            "abbreviatedOid": "c125038"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-18T22:12:40Z",
          "updatedAt": "2023-04-18T22:12:41Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nas the client could potentially already have sent data for the WebTransport\r\n```",
              "createdAt": "2023-04-18T22:12:41Z",
              "updatedAt": "2023-04-18T22:12:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5S6QmI",
          "commit": {
            "abbreviatedOid": "c125038"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-18T22:12:45Z",
          "updatedAt": "2023-04-18T22:12:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5TR2Me",
          "commit": {
            "abbreviatedOid": "0b07896"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Belated approval.",
          "createdAt": "2023-04-24T05:00:12Z",
          "updatedAt": "2023-04-24T05:00:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 114,
      "id": "PR_kwDOCvK98s5OfQ9Z",
      "title": "Be consistent about how we spell out integer divsion",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/114",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I am picking floor() here, since `//` can be confused with a C-style comment.",
      "createdAt": "2023-04-17T15:00:18Z",
      "updatedAt": "2023-04-18T22:14:06Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "aa9ddd3f7bd27ce21e41a4ad1f8f7748e2953d9f",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "division",
      "headRefOid": "b886358fcb5349465f426533fd7db2d39b0efa6b",
      "closedAt": "2023-04-18T22:14:05Z",
      "mergedAt": "2023-04-18T22:14:05Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "e3e5ba73075ac5e2b811f6c61abf680dcbd775b2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5SwFCp",
          "commit": {
            "abbreviatedOid": "b886358"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-17T15:05:02Z",
          "updatedAt": "2023-04-17T15:05:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5SyXay",
          "commit": {
            "abbreviatedOid": "b886358"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-17T20:59:39Z",
          "updatedAt": "2023-04-17T20:59:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5S6Qul",
          "commit": {
            "abbreviatedOid": "b886358"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-18T22:13:21Z",
          "updatedAt": "2023-04-18T22:13:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 115,
      "id": "PR_kwDOCvK98s5OfRKc",
      "title": "Extend the error space for reset codes to 32 bits",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/115",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #90.",
      "createdAt": "2023-04-17T15:00:48Z",
      "updatedAt": "2023-04-18T22:15:20Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "aa9ddd3f7bd27ce21e41a4ad1f8f7748e2953d9f",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "32bit-error-codes",
      "headRefOid": "93f0a64a555b02aa5836413b53019b60cc0900aa",
      "closedAt": "2023-04-18T22:15:20Z",
      "mergedAt": "2023-04-18T22:15:19Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "9e6d370832ac418c5adb388c9f25131fa9065dd3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5SwEuP",
          "commit": {
            "abbreviatedOid": "93f0a64"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-17T15:04:24Z",
          "updatedAt": "2023-04-17T15:04:28Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "This is not really normative. Maybe better: error codes are remapped \u2026",
              "createdAt": "2023-04-17T15:04:24Z",
              "updatedAt": "2023-04-17T15:04:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5SyXRR",
          "commit": {
            "abbreviatedOid": "93f0a64"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Text LGTM (though I didn't review the math to make sure the values line up)",
          "createdAt": "2023-04-17T20:59:09Z",
          "updatedAt": "2023-04-17T20:59:16Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5S1X9r",
          "commit": {
            "abbreviatedOid": "93f0a64"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I made the change in webtransport-go (https://github.com/quic-go/webtransport-go/pull/74) and it looks like the math is correct.",
          "createdAt": "2023-04-18T09:52:10Z",
          "updatedAt": "2023-04-18T09:52:10Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5S6Q0x",
          "commit": {
            "abbreviatedOid": "93f0a64"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-18T22:13:48Z",
          "updatedAt": "2023-04-18T22:13:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5S6RJY",
          "commit": {
            "abbreviatedOid": "93f0a64"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-18T22:15:03Z",
          "updatedAt": "2023-04-18T22:15:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 118,
      "id": "PR_kwDOCvK98s5OnvQ6",
      "title": "Update stream format diagrams",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/118",
      "state": "MERGED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Update stream format diagrams\r\n\r\nCloses #107",
      "createdAt": "2023-04-18T22:30:50Z",
      "updatedAt": "2023-04-18T22:50:46Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "9e6d370832ac418c5adb388c9f25131fa9065dd3",
      "headRepository": "ekinnear/draft-ietf-webtrans-http3",
      "headRefName": "ek/message_format",
      "headRefOid": "8b2057984f5c2a9d656a56fca811d6af749a95f6",
      "closedAt": "2023-04-18T22:38:47Z",
      "mergedAt": "2023-04-18T22:38:47Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "20470baa338590df23b8b1bd71954e6054fe79d4"
      },
      "comments": [
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "thanks!",
          "createdAt": "2023-04-18T22:50:45Z",
          "updatedAt": "2023-04-18T22:50:45Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5S6UX5",
          "commit": {
            "abbreviatedOid": "8b20579"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-18T22:31:57Z",
          "updatedAt": "2023-04-18T22:31:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 120,
      "id": "PR_kwDOCvK98s5Png7_",
      "title": "Make capsule protocol usage more explicit",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/120",
      "state": "MERGED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes: #112",
      "createdAt": "2023-05-02T19:48:28Z",
      "updatedAt": "2023-05-02T22:06:52Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "20470baa338590df23b8b1bd71954e6054fe79d4",
      "headRepository": "afrind/draft-ietf-webtrans-http3",
      "headRefName": "capsule-protocol",
      "headRefOid": "1428585c6d98d26613e9e3fcd424c8554d0fadf2",
      "closedAt": "2023-05-02T22:06:52Z",
      "mergedAt": "2023-05-02T22:06:52Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "71b4b009631d92884fe18da9a0260da335544559"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5UCWo2",
          "commit": {
            "abbreviatedOid": "fab0996"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-02T21:17:22Z",
          "updatedAt": "2023-05-02T21:17:22Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "As written this discourages the use of the header. Here's a proposal that avoids that issue:\r\n\r\n```suggestion\r\nHTTP-DATAGRAM}} is not required by WebTransport and can safely be ignored by WebTransport\r\n```",
              "createdAt": "2023-05-02T21:17:22Z",
              "updatedAt": "2023-05-02T21:17:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5UCigM",
          "commit": {
            "abbreviatedOid": "fab0996"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-02T22:06:21Z",
          "updatedAt": "2023-05-02T22:06:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5UCiix",
          "commit": {
            "abbreviatedOid": "1428585"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-02T22:06:35Z",
          "updatedAt": "2023-05-02T22:06:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 121,
      "id": "PR_kwDOCvK98s5PnpC2",
      "title": "Explain how Priority interacts with WebTransport sessions",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/121",
      "state": "MERGED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes: #102",
      "createdAt": "2023-05-02T20:15:35Z",
      "updatedAt": "2023-07-18T22:10:56Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "87fcae07d155c78927e744d783039afdec3b325e",
      "headRepository": "afrind/draft-ietf-webtrans-http3",
      "headRefName": "priorities-and-pooling",
      "headRefOid": "d3f1ccf19168295aa8777e214a11980c4e6003a7",
      "closedAt": "2023-07-18T22:10:54Z",
      "mergedAt": "2023-07-18T22:10:54Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "e50ed433aaca54adab5bc56df94b8e8d2064941d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5UCWwZ",
          "commit": {
            "abbreviatedOid": "1316894"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-02T21:17:49Z",
          "updatedAt": "2023-05-02T21:20:05Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\ndatagrams within a WebTransport session; such mechanisms can be defined by\r\n```",
              "createdAt": "2023-05-02T21:17:50Z",
              "updatedAt": "2023-05-02T21:20:05Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nThe Priority header ({{!RFC9218}}) MAY be set in a WebTransport\r\n```",
              "createdAt": "2023-05-02T21:18:20Z",
              "updatedAt": "2023-05-02T21:20:06Z"
            },
            {
              "originalPosition": 18,
              "body": "This example seems to prescribe an algorithm that can lead to starvation, was that intentional?",
              "createdAt": "2023-05-02T21:19:32Z",
              "updatedAt": "2023-05-02T21:20:06Z"
            },
            {
              "originalPosition": 21,
              "body": "We should define what a \"non-incremental priority\" is",
              "createdAt": "2023-05-02T21:19:58Z",
              "updatedAt": "2023-05-02T21:20:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5UCdBP",
          "commit": {
            "abbreviatedOid": "1316894"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-02T21:40:35Z",
          "updatedAt": "2023-05-02T21:40:35Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "+1",
              "createdAt": "2023-05-02T21:40:35Z",
              "updatedAt": "2023-05-02T21:40:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5UCeCw",
          "commit": {
            "abbreviatedOid": "1316894"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-02T21:45:10Z",
          "updatedAt": "2023-05-02T21:45:10Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "It seems like you're making new rules for RFC 9218 here. You don't mention the frame (which can only go in one direction) and you're too ambiguous about how these signals affect the dataflows. When a client sends the signal, what is the prioritization affecting (local streams or remote streams?) and vice versa. \r\n\r\nI'm also not sure how this is supposed to gel with the W3C WebTransport API that doesn't allow control over these fields.",
              "createdAt": "2023-05-02T21:45:10Z",
              "updatedAt": "2023-05-02T21:45:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5UCeRO",
          "commit": {
            "abbreviatedOid": "1316894"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-02T21:46:11Z",
          "updatedAt": "2023-05-02T21:46:12Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "This is a concrete example of the scheduling guidance in RFC 9218, at least as far as what we say a server should do. We can probably reference that section, which also describes the starvation issues.",
              "createdAt": "2023-05-02T21:46:11Z",
              "updatedAt": "2023-05-02T21:46:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5UCe72",
          "commit": {
            "abbreviatedOid": "1316894"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-02T21:49:15Z",
          "updatedAt": "2023-05-02T21:49:16Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "or even just a \"may be defined by other specifications\", which would keep the door open to defining an actual WebTransport signal.",
              "createdAt": "2023-05-02T21:49:15Z",
              "updatedAt": "2023-05-02T21:49:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5UCkPS",
          "commit": {
            "abbreviatedOid": "1316894"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-02T22:14:50Z",
          "updatedAt": "2023-05-02T22:14:50Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "If I'm understanding correctly, this is saying that you must prioritize everything associated with a given WebTransport session at the same level. Technically, that's not required since we broke out each stream into a \"native\" H3 stream, but that seems like more of a bug than a feature, since interleaving priorities between streams of different WebTransport sessions seems like a recipe for pain. Instead, we probably want to say that everything must stay within the session, that session has a fixed priority, and if you want to prioritize within the session, it's up to you to send the right data in the right order (see the W3C API for that).",
              "createdAt": "2023-05-02T22:14:50Z",
              "updatedAt": "2023-05-02T22:14:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5Wiqvb",
          "commit": {
            "abbreviatedOid": "1641fe4"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T22:37:10Z",
          "updatedAt": "2023-05-30T22:37:10Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "It's not just the recipient, consider the case where a client sends signal X and something coordinating with the server says Y, the server will likely pick Y due to https://www.rfc-editor.org/rfc/rfc9218.html#section-8\r\n\r\nThat's what's not clear here. In HTTP the interaction expectations were set out clearly. WebTransport is a bit different and we should make sure everyone understands that. \r\n\r\nSo as a concrete strawman, I'd phrase it something like this (and run into your second para example, which is fine as it is.\r\n\r\n```suggestion\r\nWebTransport sessions are initiated using the CONNECT method. While  {{Section\r\n11 of !RFC9218}} describes how extensible priorities can be applied to CONNECT,\r\nWebTransport extends the types of data that are exchanged in relation to the\r\nrequest and response, which requires additional considerations. WebTransport\r\nCONNECT requests and responses MAY contain the Priority header field  ({{Section\r\n5 of RFC9218}}); clients MAY reprioritize by sending PRIORITY_UPDATE frames\r\n({{Section 7 of RFC9218}}). In extension to {{RFC9218}}, it is RECOMMENDED that\r\nthe scheduling guidance in both {{Section 9 of RFC9218}} and {{Section 10 of\r\nRFC9218}} is applied by clients and servers for all data that they send in the\r\nenclosing WebTransport session, including Capsules, WebTransport streams and\r\ndatagrams. Note that the merging considerations given in {{Section 8 of\r\nRFC9218}} also apply. For example, a client that receives a response Priority\r\nheader field could alter its view of a WebTransport session priority and alter\r\nthe scheduling of outgoing data as a result. \r\n\r\nEndpoints that prioritize WebTransport sessions need to consider how they\r\ninteract with other sessions or requests on the same HTTP/3 connection.\r\n```",
              "createdAt": "2023-05-30T22:37:10Z",
              "updatedAt": "2023-05-30T22:37:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5Wis3C",
          "commit": {
            "abbreviatedOid": "1641fe4"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T22:46:24Z",
          "updatedAt": "2023-05-30T22:46:24Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Thanks, overall, your text is much better. \r\n\r\n> it is RECOMMENDED that the scheduling guidance in both {{Section 9 of RFC9218}} and {{Section 10 of RFC9218}} is applied by clients and servers for all data that they send in the enclosing WebTransport session, including Capsules, WebTransport streams and datagrams\r\n\r\nI think the bit I want to clarify is that prioritizing WebTransport streams or datagrams (which can be defined elsewhere) is only intended to prioritize them against other data in the same WebTransport session, and the Priority header is what prioritizes the session itself. \r\n\r\nAdmittedly, my text didn't convey this concept clearly either.",
              "createdAt": "2023-05-30T22:46:24Z",
              "updatedAt": "2023-05-30T22:46:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5WiuEh",
          "commit": {
            "abbreviatedOid": "1641fe4"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T22:51:05Z",
          "updatedAt": "2023-05-30T22:51:05Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "ah got it. I agree on the concept. I think we can highlight that with a little bit more iteration of the text in this section. \r\n\r\nThe key point that does need to be covered, if I understand your intent for whole-session priotization,  is that RFC 9218 Section 9 says client MAY apply signals, and in WebTransport you want to upgrade it to a SHOULD.",
              "createdAt": "2023-05-30T22:51:05Z",
              "updatedAt": "2023-05-30T22:51:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5WiwlY",
          "commit": {
            "abbreviatedOid": "1641fe4"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T22:59:27Z",
          "updatedAt": "2023-05-30T22:59:27Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Oh actually the key point was the 'dependent streams and datagrams get prioritized within the session and not across sessions'; asking the client to respect the server's preference on send with a SHOULD was more of a target of opportunity, and I could be convinced to leave it as a MAY.  I can contrive a use case where there are pooled sessions and the server wants to elevate the priority of one, or indicate a pooled POST is lower priority than some WT session, but a) I'm not sure how real they are and b) I don't know if the difference between MAY and SHOULD makes any difference.",
              "createdAt": "2023-05-30T22:59:27Z",
              "updatedAt": "2023-05-30T22:59:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5Wi0VK",
          "commit": {
            "abbreviatedOid": "1641fe4"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T23:13:57Z",
          "updatedAt": "2023-05-30T23:13:57Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "The concepts are tangential to me. I.e.\r\n\r\n1. A client SHOULD employ some form of prioritization when pooling (or else you might do something naive and cause starvation)\r\n2. If the form of prioritization is extensible priorities, a client SHOULD apply the scheduling guidance in section 9 when sending session data (a deviation from section 8, which was written to be interpreted very openly)\r\n3. A client can send a signal to indicate it's send priority to the origin (or intermediary)\r\n4. A server might want to consider the client priority signal but it doesn't have to\r\n5. A client might want to consider the server priority but it doesn't have to\r\n\r\n\r\n",
              "createdAt": "2023-05-30T23:13:57Z",
              "updatedAt": "2023-05-30T23:14:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5Zha-M",
          "commit": {
            "abbreviatedOid": "1641fe4"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-27T22:16:18Z",
          "updatedAt": "2023-06-27T22:16:18Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I would drop 4 & 5.",
              "createdAt": "2023-06-27T22:16:18Z",
              "updatedAt": "2023-06-27T22:16:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5alA7-",
          "commit": {
            "abbreviatedOid": "d3f1ccf"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2023-07-07T19:28:06Z",
          "updatedAt": "2023-07-07T19:28:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5a7VSy",
          "commit": {
            "abbreviatedOid": "d3f1ccf"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-12T04:51:31Z",
          "updatedAt": "2023-07-12T04:51:31Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5bjQj8",
          "commit": {
            "abbreviatedOid": "d3f1ccf"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-18T22:10:24Z",
          "updatedAt": "2023-07-18T22:10:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5bjQqe",
          "commit": {
            "abbreviatedOid": "d3f1ccf"
          },
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-18T22:10:56Z",
          "updatedAt": "2023-07-18T22:10:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 122,
      "id": "PR_kwDOCvK98s5PoFcm",
      "title": "Note the source of quarter stream ID",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/122",
      "state": "MERGED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Note the source of quarter stream ID\r\n\r\nCloses #110",
      "createdAt": "2023-05-02T22:27:22Z",
      "updatedAt": "2023-05-02T22:28:11Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "71b4b009631d92884fe18da9a0260da335544559",
      "headRepository": "ekinnear/draft-ietf-webtrans-http3",
      "headRefName": "ek/quarter_stream_id",
      "headRefOid": "aecefda6fdfc94462c8869b43ffba640243fd7a4",
      "closedAt": "2023-05-02T22:28:10Z",
      "mergedAt": "2023-05-02T22:28:10Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "17e992c029d99cc6b216078ea22c976e0f9ef1da"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5UCmmN",
          "commit": {
            "abbreviatedOid": "aecefda"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-02T22:27:54Z",
          "updatedAt": "2023-05-02T22:27:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5UCmnm",
          "commit": {
            "abbreviatedOid": "aecefda"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-02T22:28:00Z",
          "updatedAt": "2023-05-02T22:28:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 123,
      "id": "PR_kwDOCvK98s5QJK5c",
      "title": "Tweak how HTTP/3 error codes are presented for use",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/123",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This change is editorial. It is not intended to redefine how the error\r\ncodes operate but instead clarify their usage and make them more\r\nconsistent with how HTTP/3 and QUIC do things.\r\n\r\nSo, we drop `H3` prefix from the error codes, because this is all about\r\nWebTransport.\r\n\r\nThen we make a single label - WEBTRANSPORT_APPLICATION_ERROR - that\r\ncovers the entire range of codes that we care about. This is similar to\r\nhow QUIC's CRYPTO_ERROR works. And in the part we talk about mapping,\r\nadd a little callout to the label similar to https://datatracker.ietf.org/doc/html/rfc9001#section-4.8\r\n\r\nFixes #117\r\n",
      "createdAt": "2023-05-10T01:40:39Z",
      "updatedAt": "2023-05-16T22:36:24Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "17e992c029d99cc6b216078ea22c976e0f9ef1da",
      "headRepository": "LPardue/draft-ietf-webtrans-http3",
      "headRefName": "error_codes",
      "headRefOid": "4ca4008f3a85fc6bc2dc280942a8b71a0e0f5984",
      "closedAt": "2023-05-16T22:36:24Z",
      "mergedAt": "2023-05-16T22:36:24Z",
      "mergedBy": "ekinnear",
      "mergeCommit": {
        "oid": "111ad84ca347edf44ab7b2e4f84072e289334611"
      },
      "comments": [
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "(Landing suggestions during editor's meeting, as the text was present before/after the changes here)",
          "createdAt": "2023-05-16T22:35:50Z",
          "updatedAt": "2023-05-16T22:35:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5Usoqw",
          "commit": {
            "abbreviatedOid": "c627f2d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-10T16:13:23Z",
          "updatedAt": "2023-05-10T16:13:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5U2DsB",
          "commit": {
            "abbreviatedOid": "c627f2d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-11T21:23:29Z",
          "updatedAt": "2023-05-11T21:23:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5VNLRA",
          "commit": {
            "abbreviatedOid": "c627f2d"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-16T22:21:14Z",
          "updatedAt": "2023-05-16T22:21:29Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nof HTTP3}}; those have to be skipped when mapping the error codes\r\n```",
              "createdAt": "2023-05-16T22:21:14Z",
              "updatedAt": "2023-05-16T22:21:29Z"
            },
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n(i.e. the two HTTP/3 error codepoints adjacent to a reserved\r\n```",
              "createdAt": "2023-05-16T22:21:21Z",
              "updatedAt": "2023-05-16T22:21:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 124,
      "id": "PR_kwDOCvK98s5QqArp",
      "title": "Bump wire version from draft-02 to draft-06",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/124",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-16T22:03:28Z",
      "updatedAt": "2023-05-24T19:08:37Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "17e992c029d99cc6b216078ea22c976e0f9ef1da",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "changes-06",
      "headRefOid": "cad46985c77211b2e91b38db156f1065fb48da9b",
      "closedAt": "2023-05-24T19:08:37Z",
      "mergedAt": "2023-05-24T19:08:37Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "477ab175b1e7c3d8b4047fbb14b4de4f17f24b2d"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I've removed the header altogether.  Please take another look.",
          "createdAt": "2023-05-18T00:20:38Z",
          "updatedAt": "2023-05-18T00:20:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5VNIeX",
          "commit": {
            "abbreviatedOid": "ff7eb4d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-16T22:07:50Z",
          "updatedAt": "2023-05-16T22:08:38Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Would it make more sense to say something like `Sec-Webtransport-Http3-DraftXX where XX is the revision number of this Internet draft`? That way if we forget to modify it again we won't risk confusion.",
              "createdAt": "2023-05-16T22:07:50Z",
              "updatedAt": "2023-05-16T22:08:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5VNHwD",
          "commit": {
            "abbreviatedOid": "ff7eb4d"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-16T22:05:51Z",
          "updatedAt": "2023-05-16T22:19:49Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nSETTINGS_WEBTRANSPORT_MAX_SESSIONS parameter.  Because of that, any\r\n```",
              "createdAt": "2023-05-16T22:05:52Z",
              "updatedAt": "2023-05-16T22:19:49Z"
            },
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nversions other than the RFC version, the client MUST send\r\n```",
              "createdAt": "2023-05-16T22:09:06Z",
              "updatedAt": "2023-05-16T22:19:49Z"
            },
            {
              "originalPosition": 45,
              "body": "`SETTINGS_ENABLE_WEBTRANSPORT` is not gone yet, but it would be nice if it were! ",
              "createdAt": "2023-05-16T22:19:39Z",
              "updatedAt": "2023-05-16T22:19:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5VNNYY",
          "commit": {
            "abbreviatedOid": "c8835e6"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T22:28:15Z",
          "updatedAt": "2023-05-16T22:28:16Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "We have to manually bump the SETTINGS codepoint either way.\r\n\r\nActually, should we just keep it at draft02?  As far as I can tell, we've not made incompatible changes between capsules used in 02 and 06.",
              "createdAt": "2023-05-16T22:28:15Z",
              "updatedAt": "2023-05-16T22:28:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5VNOi2",
          "commit": {
            "abbreviatedOid": "c8835e6"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T22:33:22Z",
          "updatedAt": "2023-05-16T22:33:23Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I think tying this to draft version is maybe less fun than tying it to \"wire format compatibility version\", although I don't feel super strongly either way. It's certainly confusing if it's the latter but named as the former.",
              "createdAt": "2023-05-16T22:33:22Z",
              "updatedAt": "2023-05-16T22:33:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5VNScj",
          "commit": {
            "abbreviatedOid": "ff7eb4d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T22:50:22Z",
          "updatedAt": "2023-05-16T22:50:22Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Keeping header to `draft02` for now.",
              "createdAt": "2023-05-16T22:50:22Z",
              "updatedAt": "2023-05-16T22:50:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5VNTjI",
          "commit": {
            "abbreviatedOid": "ff7eb4d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T22:53:42Z",
          "updatedAt": "2023-05-16T22:53:42Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Silly question: what's the purpose of this header if it's fixed at draft02?",
              "createdAt": "2023-05-16T22:53:42Z",
              "updatedAt": "2023-05-16T22:53:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5VNUdh",
          "commit": {
            "abbreviatedOid": "ff7eb4d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T22:59:17Z",
          "updatedAt": "2023-05-16T22:59:17Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "The idea was that if we make an incompatible version to capsules, we could use this as an escape hatch (since capsules are transmitted E2E, whereas settings are hop-by-hop).",
              "createdAt": "2023-05-16T22:59:17Z",
              "updatedAt": "2023-05-16T22:59:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5VNW3q",
          "commit": {
            "abbreviatedOid": "ff7eb4d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T23:12:49Z",
          "updatedAt": "2023-05-16T23:12:50Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Given that we only have a single capsule (CLOSE_WEBTRANSPORT_SESSION) I'd say this complexity isn't worth it and I'd remove the header entirely, because at this point it's very likely to cause confusion by saying draft02 when we're actually using a different version of the draft that is incompatible with draft02",
              "createdAt": "2023-05-16T23:12:49Z",
              "updatedAt": "2023-05-16T23:12:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5VNylH",
          "commit": {
            "abbreviatedOid": "ff7eb4d"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-17T02:01:42Z",
          "updatedAt": "2023-05-17T02:01:42Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "If we have a setting that changes as we revise things, I'm not sure that this provides value now.  The real tricky stuff that might change between revisions (and any ultimate RFC) seems to be captured by that setting.",
              "createdAt": "2023-05-17T02:01:42Z",
              "updatedAt": "2023-05-17T02:01:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5VWEN_",
          "commit": {
            "abbreviatedOid": "cad4698"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-18T00:26:36Z",
          "updatedAt": "2023-05-18T00:26:40Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Is this something that would apply more generally, such that removal by the RFC editor isn't necessary?  This paragraph could probably be added to Section 3.2.  (The only bit that might be strange is a note about multiple webtransport versions, but that too is reasonable as a means of planning for the eventual replacement of this protocol.  That is, we could tweak it to say \"A future specification may supersede this specification; that is, a future specification might require that this protocol be disabled if the setting for that protocol is included by both client and server.\"\r\n\r\n(Maybe a separate PR is warranted for that change though...)",
              "createdAt": "2023-05-18T00:26:36Z",
              "updatedAt": "2023-05-18T00:26:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5VWG8i",
          "commit": {
            "abbreviatedOid": "cad4698"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-18T00:49:12Z",
          "updatedAt": "2023-05-18T00:49:13Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "If we were to make this scheme permanent, we should probably have a separate issue and discuss this with the WG.",
              "createdAt": "2023-05-18T00:49:12Z",
              "updatedAt": "2023-05-18T00:49:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5VWrS4",
          "commit": {
            "abbreviatedOid": "cad4698"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-18T05:04:44Z",
          "updatedAt": "2023-05-18T05:04:44Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5VbUKZ",
          "commit": {
            "abbreviatedOid": "cad4698"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-18T18:18:40Z",
          "updatedAt": "2023-05-18T18:18:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 127,
      "id": "PR_kwDOCvK98s5ShG44",
      "title": "Assign a codepoint to the DRAIN_WEBTRANSPORT_SESSION capsule",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/127",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-08T12:54:46Z",
      "updatedAt": "2023-06-13T22:29:27Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "477ab175b1e7c3d8b4047fbb14b4de4f17f24b2d",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "drain-id",
      "headRefOid": "4eceacc1cb0f4b64e5b04abbda0086cd3484718e",
      "closedAt": "2023-06-13T22:29:26Z",
      "mergedAt": "2023-06-13T22:29:26Z",
      "mergedBy": "ekinnear",
      "mergeCommit": {
        "oid": "c19eadef2dcababe055cf21d81db8b8b53c59b8c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5Xov84",
          "commit": {
            "abbreviatedOid": "1698b51"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This LGTM but you could also plan to get a lower codepoint before shipping",
          "createdAt": "2023-06-08T16:02:08Z",
          "updatedAt": "2023-06-08T16:02:36Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\n: provisional (when this document is approved this will become permanent)\r\n```",
              "createdAt": "2023-06-08T16:02:08Z",
              "updatedAt": "2023-06-08T16:02:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5YGuK8",
          "commit": {
            "abbreviatedOid": "4eceacc"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-13T22:28:46Z",
          "updatedAt": "2023-06-13T22:28:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 128,
      "id": "PR_kwDOCvK98s5Snk8t",
      "title": "Redo the version bump",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/128",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In a previous PR, I said that I bumped a SETTINGS parameter number to indicate the new draft version.  Turns out, I accidentally changed the WEBTRANSPORT_MAX_SESSIONS codepoint instead.\r\n\r\nThis PR actually changes the correct one (ENABLE_WEBTRANSPORT). It also replaces \"draft-06\" with \"draft-07\", since draft-06 is not really implementable at this state.",
      "createdAt": "2023-06-09T12:27:06Z",
      "updatedAt": "2023-06-13T22:35:04Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "c19eadef2dcababe055cf21d81db8b8b53c59b8c",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "draft07",
      "headRefOid": "2a98b146ede7586e229c2bb69efda0c7b3096122",
      "closedAt": "2023-06-13T22:35:04Z",
      "mergedAt": "2023-06-13T22:35:04Z",
      "mergedBy": "ekinnear",
      "mergeCommit": {
        "oid": "51e3a800b4ff566c4fc3416a5ad85aba0897ae64"
      },
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Can we have this PR also resolve #125 ? Let's avoid changing settings multiple times to reduce implementation churn",
          "createdAt": "2023-06-09T16:24:28Z",
          "updatedAt": "2023-06-09T16:24:28Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can we have this PR also resolve #125 ? Let's avoid changing settings multiple times to reduce implementation churn\r\n\r\nI don't think we should block solving the easy problem (which is me screwing up and changing the wrong number) on solving a related hard problem (which is merging two settings into one).  I don't think there's implementation churn from this, since draft-06 is not really implementable (at least in backwards-compatible way) because of this problem.",
          "createdAt": "2023-06-09T18:14:28Z",
          "updatedAt": "2023-06-09T18:18:19Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought the other PR wasn't so much a mistake but rather was intentional, since we were talking about changing the setting. So to that end, I'd be tempted to just do #125 (happy to get a PR out for that shortly) and have this just update the text to point at the correct setting to look at.",
          "createdAt": "2023-06-09T20:14:57Z",
          "updatedAt": "2023-06-09T20:14:57Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Opened #129, so perhaps this would just keep the updates to the changelog and also note the change in setting name?",
          "createdAt": "2023-06-09T20:48:53Z",
          "updatedAt": "2023-06-09T20:48:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5YGvTp",
          "commit": {
            "abbreviatedOid": "2a98b14"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-13T22:34:46Z",
          "updatedAt": "2023-06-13T22:34:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 129,
      "id": "PR_kwDOCvK98s5Sp5RC",
      "title": "Replace SETTINGS_ENABLE_WEBTRANSPORT with SETTINGS_WEBTRANSPORT_MAX_SESSIONS",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/129",
      "state": "MERGED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Replace SETTINGS_ENABLE_WEBTRANSPORT with SETTINGS_WEBTRANSPORT_MAX_SESSIONS\r\n\r\nFixes #125",
      "createdAt": "2023-06-09T20:44:28Z",
      "updatedAt": "2023-06-13T22:28:08Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "477ab175b1e7c3d8b4047fbb14b4de4f17f24b2d",
      "headRepository": "ekinnear/draft-ietf-webtrans-http3",
      "headRefName": "ek/consolidate_settings",
      "headRefOid": "d58c58c633538bd9854192812fdad0953b6fb92d",
      "closedAt": "2023-06-13T22:28:05Z",
      "mergedAt": "2023-06-13T22:28:05Z",
      "mergedBy": "ekinnear",
      "mergeCommit": {
        "oid": "5f26d1066936a5407b2b2145bb7330d8a614eeea"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't believe this addresses the main reason we've not done this yet, which is the fact that SETTINGS_WEBTRANSPORT_MAX_SESSIONS is only sent from the server to the client, making it not particularly useful for version negotiation.",
          "createdAt": "2023-06-09T20:59:37Z",
          "updatedAt": "2023-06-09T20:59:37Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "> SETTINGS_WEBTRANSPORT_MAX_SESSIONS is only sent from the server to the client, making it not particularly useful for version negotiation.\r\n\r\nThe intent was that this is rectified by the new text in this PR, if that doesn't seem to be the case, then let's fix it!\r\n\r\nFor example:\r\n```\r\nWhen an HTTP/3 connection is established, both the client and server have to\r\nsend a SETTINGS_WEBTRANSPORT_MAX_SESSIONS setting in order to indicate that\r\nthey both support WebTransport over HTTP/3. \r\n```",
          "createdAt": "2023-06-09T21:03:15Z",
          "updatedAt": "2023-06-09T21:03:15Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Long term, once this has shipped as RFC and all browsers have dropped support for pre-RFC drafts, is the plan to have clients send SETTINGS_WEBTRANSPORT_MAX_SESSIONS forever or to stop sending it? If the goal is to only do this during the draft period, we should have \"to be removed by RFC editor\" notes explaining that",
          "createdAt": "2023-06-09T21:07:11Z",
          "updatedAt": "2023-06-09T21:07:11Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "> Long term, once this has shipped as RFC and all browsers have dropped support for pre-RFC drafts, is the plan to have clients send SETTINGS_WEBTRANSPORT_MAX_SESSIONS forever or to stop sending it? If the goal is to only do this during the draft period, we should have \"to be removed by RFC editor\" notes explaining that\r\n\r\nFiled #130 to discuss this",
          "createdAt": "2023-06-13T22:22:55Z",
          "updatedAt": "2023-06-13T22:22:55Z"
        },
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed in editor's meeting, moved follow-ups out to an issue and merging.",
          "createdAt": "2023-06-13T22:27:59Z",
          "updatedAt": "2023-06-13T22:27:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5XzNAh",
          "commit": {
            "abbreviatedOid": "36d915d"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Overall this PR is great, my comments apply to the preexisting text but it'd be nice to clean all this up once and for all",
          "createdAt": "2023-06-09T20:50:15Z",
          "updatedAt": "2023-06-09T20:54:01Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Unrelated to this PR, but `This process also negotiates the use of additional HTTP/3 extensions.` is no longer true now that we require negotiating each extension separately. Can we just remove that sentence?",
              "createdAt": "2023-06-09T20:50:15Z",
              "updatedAt": "2023-06-09T20:54:02Z"
            },
            {
              "originalPosition": 30,
              "body": "Should this paragraph be in a \"to be removed by RFC editor\" portion?",
              "createdAt": "2023-06-09T20:51:18Z",
              "updatedAt": "2023-06-09T20:54:02Z"
            },
            {
              "originalPosition": 49,
              "body": "`SETTINGS_ENABLE_CONNECT_PROTOCOL` is only sent by servers",
              "createdAt": "2023-06-09T20:53:10Z",
              "updatedAt": "2023-06-09T20:54:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5XzQG4",
          "commit": {
            "abbreviatedOid": "36d915d"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-09T21:02:48Z",
          "updatedAt": "2023-06-09T21:02:48Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I believe Lucas added this in the PR related to WEBTRANSPORT_STREAM, so we may want to clarify it instead of removing.",
              "createdAt": "2023-06-09T21:02:48Z",
              "updatedAt": "2023-06-09T21:02:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5YGsKT",
          "commit": {
            "abbreviatedOid": "36d915d"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-13T22:18:35Z",
          "updatedAt": "2023-06-13T22:18:36Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Makes sense, done in https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/129/commits/6b437df3129ac03d6ef429f5e1dfc8785f78ffdd",
              "createdAt": "2023-06-13T22:18:35Z",
              "updatedAt": "2023-06-13T22:18:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5YGsPF",
          "commit": {
            "abbreviatedOid": "36d915d"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-13T22:18:56Z",
          "updatedAt": "2023-06-13T22:18:56Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Good call, updated and added a note about the client's value not mattering much in https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/129/commits/0deb77283cc5599741e7dc74e218a7635deecb3a",
              "createdAt": "2023-06-13T22:18:56Z",
              "updatedAt": "2023-06-13T22:18:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5YGt3W",
          "commit": {
            "abbreviatedOid": "d58c58c"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-13T22:27:12Z",
          "updatedAt": "2023-06-13T22:27:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 131,
      "id": "PR_kwDOCvK98s5UFVW1",
      "title": "Clarify that GOAWAY signals drain for all sessions",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/131",
      "state": "CLOSED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #126",
      "createdAt": "2023-06-27T22:35:43Z",
      "updatedAt": "2023-06-28T05:13:32Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "51e3a800b4ff566c4fc3416a5ad85aba0897ae64",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "goaway-implies-drain",
      "headRefOid": "48a65c312f7b90d67a2cafdd776f441e7184928c",
      "closedAt": "2023-06-28T05:13:32Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See #132 ",
          "createdAt": "2023-06-27T22:52:08Z",
          "updatedAt": "2023-06-27T22:52:08Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "#132 seems better than this PR",
          "createdAt": "2023-06-27T23:29:05Z",
          "updatedAt": "2023-06-27T23:29:05Z"
        },
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed in favor of #132.",
          "createdAt": "2023-06-28T05:13:32Z",
          "updatedAt": "2023-06-28T05:13:32Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5ZheyD",
          "commit": {
            "abbreviatedOid": "48a65c3"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-27T22:36:17Z",
          "updatedAt": "2023-06-27T22:36:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5Zhe0v",
          "commit": {
            "abbreviatedOid": "48a65c3"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-27T22:36:23Z",
          "updatedAt": "2023-06-27T22:36:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 132,
      "id": "PR_kwDOCvK98s5UFWDn",
      "title": "Redo GOAWAY and DRAIN_...long name",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/132",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is me, racing @vasilvv...\r\n\r\nCloses #126.",
      "createdAt": "2023-06-27T22:39:56Z",
      "updatedAt": "2023-06-28T15:58:21Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "51e3a800b4ff566c4fc3416a5ad85aba0897ae64",
      "headRepository": "martinthomson/draft-ietf-webtrans-http3",
      "headRefName": "goaway-equals-drain",
      "headRefOid": "b0d8458603852709e91ddd8a3b56a5fbbcf0255a",
      "closedAt": "2023-06-28T15:58:20Z",
      "mergedAt": "2023-06-28T15:58:20Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "87fcae07d155c78927e744d783039afdec3b325e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5Zhpss",
          "commit": {
            "abbreviatedOid": "b0d8458"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-27T23:28:27Z",
          "updatedAt": "2023-06-27T23:28:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5ZiyVA",
          "commit": {
            "abbreviatedOid": "b0d8458"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-28T05:14:03Z",
          "updatedAt": "2023-06-28T05:14:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 133,
      "id": "PR_kwDOCvK98s5U7ziN",
      "title": "Capsules are not a WebTransport feature",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/133",
      "state": "MERGED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes: #119",
      "createdAt": "2023-07-07T17:06:20Z",
      "updatedAt": "2023-08-08T22:09:21Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "87fcae07d155c78927e744d783039afdec3b325e",
      "headRepository": "afrind/draft-ietf-webtrans-http3",
      "headRefName": "capsule-use",
      "headRefOid": "912c9b3e38ff7cdc912f01cc8c08c11f14c81b96",
      "closedAt": "2023-08-08T22:09:21Z",
      "mergedAt": "2023-08-08T22:09:21Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "6b8c9427cf767468858fd46fb1c313623d354eed"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5a7VF7",
          "commit": {
            "abbreviatedOid": "912c9b3"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-12T04:50:16Z",
          "updatedAt": "2023-07-12T04:50:17Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "This should probably clarify that sending/receiving new capsules by themselves is not a feature.",
              "createdAt": "2023-07-12T04:50:16Z",
              "updatedAt": "2023-07-12T04:50:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5detyU",
          "commit": {
            "abbreviatedOid": "912c9b3"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-08-08T22:07:27Z",
          "updatedAt": "2023-08-08T22:07:31Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I'm not sure that I get the relevance of saying that.\r\n\r\nYes, it would be true, but I don't see how that helps.  ",
              "createdAt": "2023-08-08T22:07:27Z",
              "updatedAt": "2023-08-08T22:07:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5deugd",
          "commit": {
            "abbreviatedOid": "912c9b3"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-08-08T22:09:11Z",
          "updatedAt": "2023-08-08T22:09:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 134,
      "id": "PR_kwDOCvK98s5V9Mtl",
      "title": "[editorial] Fix typo in Changelog",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/134",
      "state": "MERGED",
      "author": "bashi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-20T04:34:48Z",
      "updatedAt": "2023-07-20T14:28:14Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "e50ed433aaca54adab5bc56df94b8e8d2064941d",
      "headRepository": "bashi/draft-ietf-webtrans-http3",
      "headRefName": "fix-typo",
      "headRefOid": "e6326cf4a03aa5c6e8f35b893d234daa5808bef4",
      "closedAt": "2023-07-20T14:28:14Z",
      "mergedAt": "2023-07-20T14:28:14Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "cf9ceb2d6dc67874b7d175a365d3cbf8af14ed55"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5bwXB6",
          "commit": {
            "abbreviatedOid": "e6326cf"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you for the fix!",
          "createdAt": "2023-07-20T14:28:10Z",
          "updatedAt": "2023-07-20T14:28:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 144,
      "id": "PR_kwDOCvK98s5e3WcB",
      "title": "Add subprotocol negotiation",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/144",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #137",
      "createdAt": "2023-11-07T23:43:57Z",
      "updatedAt": "2023-12-12T23:15:26Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "6b8c9427cf767468858fd46fb1c313623d354eed",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "alpn",
      "headRefOid": "c1385cb1f2533fc5060f7f78c024bb050b03413f",
      "closedAt": "2023-12-12T23:15:26Z",
      "mergedAt": "2023-12-12T23:15:26Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "b133c01dd2c905031f79c40bf68fa27a25b0d51d"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed with David at the Editor's Meeting. Made server replying optional, as otherwise it is impossible to migrate the same endpoint from not using a subprotocol to using one.",
          "createdAt": "2023-12-12T23:15:03Z",
          "updatedAt": "2023-12-12T23:15:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5mgJw9",
          "commit": {
            "abbreviatedOid": "293eea9"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Overall SGTM",
          "createdAt": "2023-11-08T08:48:58Z",
          "updatedAt": "2023-11-08T08:49:58Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "What does the server put in this field?",
              "createdAt": "2023-11-08T08:48:58Z",
              "updatedAt": "2023-11-08T08:49:58Z"
            },
            {
              "originalPosition": 21,
              "body": "Are these tokens registered with IANA? We should state the answer in the draft",
              "createdAt": "2023-11-08T08:49:48Z",
              "updatedAt": "2023-11-08T08:49:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5nsQ5C",
          "commit": {
            "abbreviatedOid": "293eea9"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-20T12:02:15Z",
          "updatedAt": "2023-11-20T12:02:16Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Clarified.",
              "createdAt": "2023-11-20T12:02:15Z",
              "updatedAt": "2023-11-20T12:02:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5nsRAj",
          "commit": {
            "abbreviatedOid": "293eea9"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-20T12:02:20Z",
          "updatedAt": "2023-11-20T12:02:21Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Clarified.",
              "createdAt": "2023-11-20T12:02:21Z",
              "updatedAt": "2023-11-20T12:02:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5nu_RW",
          "commit": {
            "abbreviatedOid": "b022842"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-20T17:45:08Z",
          "updatedAt": "2023-11-20T17:46:13Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This MUST makes this feature mandatory for servers (as opposed to optional for clients). I'd suggest keeping the optionality, similar to how ALPN works. For example:\r\n```suggestion\r\nin the CONNECT request, enumerating the possible subprotocols. If the server\r\nreceives such a header, it MAY include a `WebTransport-Subprotocol` field in\r\na successful (2xx) response. If it does, the server SHALL include a single\r\nsubprotocol from the client's list in that field. Servers MAY reject the request\r\nif the client did not include a suitable subprotocol.\r\n```",
              "createdAt": "2023-11-20T17:45:08Z",
              "updatedAt": "2023-11-20T17:46:13Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nquestion, and are not registered with IANA in the way that ALPN tokens are.\r\n```",
              "createdAt": "2023-11-20T17:46:08Z",
              "updatedAt": "2023-11-20T17:46:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5nvFE7",
          "commit": {
            "abbreviatedOid": "b022842"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-20T17:59:57Z",
          "updatedAt": "2023-11-20T17:59:57Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Well, it's only mandatory if the client already expects the server to support it.",
              "createdAt": "2023-11-20T17:59:57Z",
              "updatedAt": "2023-11-20T17:59:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5nvF4X",
          "commit": {
            "abbreviatedOid": "b022842"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-20T18:02:17Z",
          "updatedAt": "2023-11-20T18:02:17Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "This is technically not true. Assume I have a Foobar Protocol, and it has subprotocols `foo` and `bar`. I can create an IANA registry for subprotocols supported by the Foobar resources, and put `foo` and `bar` into it.",
              "createdAt": "2023-11-20T18:02:17Z",
              "updatedAt": "2023-11-20T18:02:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5ojZQj",
          "commit": {
            "abbreviatedOid": "b022842"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-28T23:08:26Z",
          "updatedAt": "2023-11-28T23:08:27Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nof individual token values is determined by the WebTransport resource in\r\n```",
              "createdAt": "2023-11-28T23:08:27Z",
              "updatedAt": "2023-11-28T23:08:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5ojamQ",
          "commit": {
            "abbreviatedOid": "985897f"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-11-28T23:15:00Z",
          "updatedAt": "2023-11-28T23:15:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5oja2j",
          "commit": {
            "abbreviatedOid": "b022842"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-28T23:16:14Z",
          "updatedAt": "2023-11-28T23:16:17Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Feels like we ought to say something about the case where the client asked for \"foo, bar\" and the server says \"200\" but doesn't include the header. ",
              "createdAt": "2023-11-28T23:16:14Z",
              "updatedAt": "2023-11-28T23:16:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5qAvQ1",
          "commit": {
            "abbreviatedOid": "b022842"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-12-12T23:05:39Z",
          "updatedAt": "2023-12-12T23:05:40Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nquestion, and are not registered in IANA's \"ALPN Protocol IDs\" registry.\r\n```",
              "createdAt": "2023-12-12T23:05:39Z",
              "updatedAt": "2023-12-12T23:05:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5qAxNn",
          "commit": {
            "abbreviatedOid": "c1385cb"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-12T23:14:56Z",
          "updatedAt": "2023-12-12T23:14:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 145,
      "id": "PR_kwDOCvK98s5gnQ9b",
      "title": "Relationship between WebTransport, HTTP/3 and QUIC",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/145",
      "state": "CLOSED",
      "author": "aboba",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "aboba"
      ],
      "labels": [],
      "body": "Fix for #111\r\n\r\nDiscussion at Nov 28, 2023 editor's meeting: Include a section describing the layering of WebTransport, HTTP/3 and QUIC, based on: https://mailarchive.ietf.org/arch/msg/moq/yOnZu3d5mDZGcV1mBODJ2-MTeko/\r\n\r\n(Thanks to Lucas)",
      "createdAt": "2023-11-29T00:05:09Z",
      "updatedAt": "2023-12-12T23:17:26Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "6b8c9427cf767468858fd46fb1c313623d354eed",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "aboba-patch-1",
      "headRefOid": "7c2fce794ec2c235be1dc2e46415e2cbcf2e6821",
      "closedAt": "2023-12-12T23:17:25Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LPardue PTAL",
          "createdAt": "2023-11-29T00:13:27Z",
          "updatedAt": "2023-11-29T00:13:27Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @aboba ! You've edited my email brain dump down into content that is about the right level. \r\n\r\nWhile reviewing I collected few proposals that I think can help make this flow a little better but they add up to a substantial diff. So I found it easier to open PR #146  that builds on this so people can see how it compares ",
          "createdAt": "2023-11-29T01:15:04Z",
          "updatedAt": "2023-11-29T01:15:04Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this PR, we'll progress #146 instead",
          "createdAt": "2023-12-12T23:17:25Z",
          "updatedAt": "2023-12-12T23:17:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5ok6Lk",
          "commit": {
            "abbreviatedOid": "7c2fce7"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I'm a little leery of encouraging people to half-arse their HTTP implementation here, so I'm not 100% on this approach.",
          "createdAt": "2023-11-29T05:58:59Z",
          "updatedAt": "2023-11-29T06:13:48Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nstream head-of-line blocking avoidance, flow control, and congestion control.\r\n```\r\n\r\nUnless \"HoL\" was previously expanded.",
              "createdAt": "2023-11-29T05:58:59Z",
              "updatedAt": "2023-11-29T06:13:48Z"
            },
            {
              "originalPosition": 16,
              "body": "I think that you want to say that \"HTTP/3 is an adaptation of HTTP so that it can use QUIC, where previous HTTP versions used TCP.\"\r\n\r\nI would not talk so much about header compression or the other stuff.\r\n\r\nI would also move the second sentence from the next paragraph up to this one.",
              "createdAt": "2023-11-29T06:00:47Z",
              "updatedAt": "2023-11-29T06:13:48Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nAlthough WebTransport requires HTTP for its handshake, when HTTP/3 is in use it doesn't require\r\n```\r\n\r\nThis statement is only true if you add the conditional here.",
              "createdAt": "2023-11-29T06:02:47Z",
              "updatedAt": "2023-11-29T06:13:48Z"
            },
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nA receiver can perform some of these checks using bytestring comparisons, provided\r\nthat basic QPACK processing is performed.\r\n```",
              "createdAt": "2023-11-29T06:03:45Z",
              "updatedAt": "2023-11-29T06:13:48Z"
            },
            {
              "originalPosition": 43,
              "body": "I'm not sure about the value of this paragraph.  There are a few things that seem  a little unclear to me.\r\n\r\nYes, if you successfully establish a session, you can largely ignore the HTTP parts from that point onward, but I would not focus too heavily on that aspect of this.\r\n\r\nPerhaps:\r\n\r\n> WebTransport session establishment involves interacting at the HTTP layer with a resource.\r\n> For Web user agents, this interaction is important to ensure for security reasons, especially\r\n> to ensure that the resource is willing to use WebTransport. However, once established,\r\n> there is very use of HTTP and most of the interactions occur directly with QUIC, with\r\n> minimal interaction with HTTP components.\r\n\r\nAs you say, all streams will have an HTTP marker at the start, but I think that it is enough to use the word \"minimal\" for that at this level of abstraction.",
              "createdAt": "2023-11-29T06:10:41Z",
              "updatedAt": "2023-11-29T06:13:48Z"
            },
            {
              "originalPosition": 45,
              "body": "Consider:\r\n\r\n```suggestion\r\n~~~~~~~~~~ aasvg\r\n```",
              "createdAt": "2023-11-29T06:10:53Z",
              "updatedAt": "2023-11-29T06:13:48Z"
            },
            {
              "originalPosition": 49,
              "body": "I would draw horizontal lines to make this a real diagram.\r\n\r\nPut the HTTP parts on the left.  I would also widen the \"punch through\" part and relabel it as something like \"nearly direct\" or \"multiplexing shim only\" or something along those lines.",
              "createdAt": "2023-11-29T06:13:10Z",
              "updatedAt": "2023-11-29T06:13:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 146,
      "id": "PR_kwDOCvK98s5gngTO",
      "title": "Relationship between WebTransport, HTTP/3 and QUIC",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/146",
      "state": "MERGED",
      "author": "LPardue",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Bernards commits\r\n- Relationship between WebTransport, HTTP/3 and QUIC\r\n- Update draft-ietf-webtrans-http3.md\r\n- Update draft-ietf-webtrans-http3.md\r\n- Update draft-ietf-webtrans-http3.md\r\n\r\nMy suggestions on top\r\n  https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/146/commits/05f31d55727611c35747146d10d7b3af93b20898",
      "createdAt": "2023-11-29T01:13:17Z",
      "updatedAt": "2024-05-14T23:08:56Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "6b8c9427cf767468858fd46fb1c313623d354eed",
      "headRepository": "LPardue/draft-ietf-webtrans-http3",
      "headRefName": "lucas-quic-wt-h3-reflow",
      "headRefOid": "1a0fb089352da97841035daff06ecfc86c06f556",
      "closedAt": "2024-05-14T23:03:11Z",
      "mergedAt": "2024-05-14T23:03:11Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "5a7174ba97ef265670b9ff178e35f15561606a61"
      },
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: next step is for @LPardue to do an editorial pass based on received comments",
          "createdAt": "2023-12-12T23:18:07Z",
          "updatedAt": "2023-12-12T23:18:07Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@DavidSchinazi  I have gone ahead and merged several of the proposed changes, and where changes were made in response to comments have resolved the conversations.  There are still a few outstanding comments.",
          "createdAt": "2024-01-23T21:47:09Z",
          "updatedAt": "2024-01-23T21:47:09Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Apologies for the delay here, I will pick this up again this week.",
          "createdAt": "2024-01-23T22:00:23Z",
          "updatedAt": "2024-01-23T22:00:23Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So picking this up was harder than I imagined because I had to address comments from Martin in a different PR that addressed text that had since had some work done on them. I've tried my best to incorporated the suggestions made there, and to address Eric and Alan's questions. As a result, I needed to hammer on the text even more. But I like the result.\r\n\r\nThe one thing unaddressed is @afrind asked \"wondering if we can create a profile or setting opting out of huffman support.\". I don't want to take on that task in this PR. If the WG wants to bring that up, then a new issue is the best place for further discussion. A subsequent proposal to introduce such an extension would then need to make it's own PR to update this document accordingly.",
          "createdAt": "2024-01-26T23:19:21Z",
          "updatedAt": "2024-01-26T23:19:21Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I authorize any author to fix the nits, please make the pain stop.",
          "createdAt": "2024-05-14T23:01:50Z",
          "updatedAt": "2024-05-14T23:01:50Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, the GitHub UI completely fell over on me",
          "createdAt": "2024-05-14T23:02:31Z",
          "updatedAt": "2024-05-14T23:02:31Z"
        },
        {
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah!",
          "createdAt": "2024-05-14T23:05:46Z",
          "updatedAt": "2024-05-14T23:05:46Z"
        },
        {
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks team!",
          "createdAt": "2024-05-14T23:08:55Z",
          "updatedAt": "2024-05-14T23:08:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5ojz06",
          "commit": {
            "abbreviatedOid": "7c2fce7"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-11-29T01:15:22Z",
          "updatedAt": "2023-11-29T01:19:50Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "QPACK static header field decompression",
              "createdAt": "2023-11-29T01:15:23Z",
              "updatedAt": "2023-11-29T01:19:50Z"
            },
            {
              "originalPosition": 26,
              "body": "However and although are redundant?  Just \"Although WebTransport...\" ?",
              "createdAt": "2023-11-29T01:16:18Z",
              "updatedAt": "2023-11-29T01:19:51Z"
            },
            {
              "originalPosition": 18,
              "body": "And huffman literal decoding?  @vasilvv mentioned this was the most annoying part, wondering if we can create a profile or setting opting out of huffman support.",
              "createdAt": "2023-11-29T01:16:51Z",
              "updatedAt": "2023-11-29T01:19:51Z"
            },
            {
              "originalPosition": 35,
              "body": "maybe \"interact with QUIC features\" and \"allows direct access to them\"",
              "createdAt": "2023-11-29T01:19:04Z",
              "updatedAt": "2023-11-29T01:19:51Z"
            },
            {
              "originalPosition": 37,
              "body": "s/or/for/?",
              "createdAt": "2023-11-29T01:19:29Z",
              "updatedAt": "2023-11-29T01:19:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5ok95P",
          "commit": {
            "abbreviatedOid": "05f31d5"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "See my feedback on #145.   Most of it applies here too.",
          "createdAt": "2023-11-29T06:14:46Z",
          "updatedAt": "2023-11-29T06:14:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5ptbrv",
          "commit": {
            "abbreviatedOid": "05f31d5"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-12-09T05:44:56Z",
          "updatedAt": "2023-12-09T05:49:19Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nservice, it is unopinionated about their usage. The applicability of streams is\r\n```",
              "createdAt": "2023-12-09T05:44:56Z",
              "updatedAt": "2023-12-09T05:49:19Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nhandshake, which uses the extended CONNECT method, to perform important checks. This is\r\n```",
              "createdAt": "2023-12-09T05:46:09Z",
              "updatedAt": "2023-12-09T05:49:19Z"
            },
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nnecessary for the Web security model where same-origin and cross-origin resource\r\n```",
              "createdAt": "2023-12-09T05:46:19Z",
              "updatedAt": "2023-12-09T05:49:19Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\naccess may not be the same. Post-handshake, QUIC streams use header bytes for\r\n```\r\nOr some better way to say this",
              "createdAt": "2023-12-09T05:46:49Z",
              "updatedAt": "2023-12-09T05:49:19Z"
            },
            {
              "originalPosition": 27,
              "body": "I'm not sure I totally follow this sentence. What is it trying to say?\r\nIs this trying to say that WebTransport uses HTTP/3 to convey header bytes via a QUIC stream, but then eventually just uses the QUIC stream directly?",
              "createdAt": "2023-12-09T05:47:16Z",
              "updatedAt": "2023-12-09T05:49:19Z"
            },
            {
              "originalPosition": 29,
              "body": "```suggestion\r\nenabled to the underlying bytestream after both sides have completed the handshake.\r\n```",
              "createdAt": "2023-12-09T05:48:19Z",
              "updatedAt": "2023-12-09T05:49:19Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nWhile WebTransport requires HTTP for the handshake, it doesn't require HTTP for\r\n```",
              "createdAt": "2023-12-09T05:48:38Z",
              "updatedAt": "2023-12-09T05:49:19Z"
            },
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nanything else. HTTP/3 offers two features in addition to HTTP Semantics: QPACK\r\n```",
              "createdAt": "2023-12-09T05:48:50Z",
              "updatedAt": "2023-12-09T05:49:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5tq-4S",
          "commit": {
            "abbreviatedOid": "05f31d5"
          },
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-23T21:37:38Z",
          "updatedAt": "2024-01-23T21:37:39Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "fixed.",
              "createdAt": "2024-01-23T21:37:39Z",
              "updatedAt": "2024-01-23T21:37:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5tq_Vo",
          "commit": {
            "abbreviatedOid": "7c2fce7"
          },
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-23T21:39:05Z",
          "updatedAt": "2024-01-23T21:39:05Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "fixed.",
              "createdAt": "2024-01-23T21:39:05Z",
              "updatedAt": "2024-01-23T21:39:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5trAG9",
          "commit": {
            "abbreviatedOid": "7c2fce7"
          },
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-23T21:40:53Z",
          "updatedAt": "2024-01-23T21:40:53Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Changed to \"While WebTransport requires HTTP\" ",
              "createdAt": "2024-01-23T21:40:53Z",
              "updatedAt": "2024-01-23T21:40:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5trB1P",
          "commit": {
            "abbreviatedOid": "7c2fce7"
          },
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-23T21:45:16Z",
          "updatedAt": "2024-01-23T21:45:17Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "It now says \"WebTransport over HTTP/3 makes it possible for an application to directly access\r\nQUIC transport via an HTTP/3 connection.\". ",
              "createdAt": "2024-01-23T21:45:16Z",
              "updatedAt": "2024-01-23T21:45:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5trDKk",
          "commit": {
            "abbreviatedOid": "7c2fce7"
          },
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-23T21:49:25Z",
          "updatedAt": "2024-01-23T21:49:26Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "These comments don't appear to have been incorporated. The text now says: \"While WebTransport requires HTTP for the handshake, it doesn't require HTTP for anything else. HTTP/3 offers two features in addition to HTTP Semantics: QPACK header compression and Server Push. Neither of these can be used to the benefit\r\nof WebTransport after the handshake succeeds.\"",
              "createdAt": "2024-01-23T21:49:25Z",
              "updatedAt": "2024-01-23T21:49:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5trDyU",
          "commit": {
            "abbreviatedOid": "05f31d5"
          },
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-23T21:51:25Z",
          "updatedAt": "2024-01-23T21:51:25Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Maybe it's trying to say that WebTransport provides access to QUIC streams, other than the header bytes? ",
              "createdAt": "2024-01-23T21:51:25Z",
              "updatedAt": "2024-01-23T21:51:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5trkmb",
          "commit": {
            "abbreviatedOid": "85d6ace"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-23T23:51:29Z",
          "updatedAt": "2024-01-23T23:51:30Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Editors discussed this diagram and thought it could be improved.\r\n\r\n```suggestion\r\n~~~~~~~~~~ aasvg\r\n              __.--.\r\n .-. .-. .-. .-.   |\r\n|   |   |   |   |  |\r\n|   '   '   '   |  |\r\n|               ' /\r\n|                /\r\n `--------------'\r\n~~~~~~~~~~\r\n```\r\n\r\nApparently the prevailing sentiment is that you need to double down on the punching imagery.",
              "createdAt": "2024-01-23T23:51:29Z",
              "updatedAt": "2024-01-23T23:51:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5tsAHj",
          "commit": {
            "abbreviatedOid": "85d6ace"
          },
          "author": "LPardue",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-01-24T01:46:31Z",
          "updatedAt": "2024-01-24T01:46:32Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "![punchout](https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/assets/6571445/9ba9eaaa-4949-4eca-a443-a1c166b35e4d)\r\n",
              "createdAt": "2024-01-24T01:46:31Z",
              "updatedAt": "2024-01-24T01:46:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s56lWAp",
          "commit": {
            "abbreviatedOid": "8943ece"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-14T22:55:21Z",
          "updatedAt": "2024-05-14T22:55:22Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nHTTP/1.1 {{?RFC6455}}, where access to the underlying bytestream is enabled\r\n```",
              "createdAt": "2024-05-14T22:55:22Z",
              "updatedAt": "2024-05-14T22:55:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s56lWFu",
          "commit": {
            "abbreviatedOid": "8943ece"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-14T22:55:45Z",
          "updatedAt": "2024-05-14T22:55:45Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "```suggestion\r\nheader, and perhaps some extra headers.\r\n```",
              "createdAt": "2024-05-14T22:55:45Z",
              "updatedAt": "2024-05-14T22:55:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s56lWOS",
          "commit": {
            "abbreviatedOid": "8943ece"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-14T22:56:27Z",
          "updatedAt": "2024-05-14T22:56:27Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "```suggestion\r\ncompression, static compression, or Huffman encoding.\r\n```",
              "createdAt": "2024-05-14T22:56:27Z",
              "updatedAt": "2024-05-14T22:56:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s56lWRs",
          "commit": {
            "abbreviatedOid": "8943ece"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-14T22:56:43Z",
          "updatedAt": "2024-05-14T22:56:44Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "```suggestion\r\nstatic decompression and Huffman decoding. Senders can opt to never use dynamic\r\n```",
              "createdAt": "2024-05-14T22:56:43Z",
              "updatedAt": "2024-05-14T22:56:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s56lVlx",
          "commit": {
            "abbreviatedOid": "8943ece"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-05-14T22:53:25Z",
          "updatedAt": "2024-05-14T22:57:17Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nresponse message sequences in the form of frames and describes details\r\n```",
              "createdAt": "2024-05-14T22:53:25Z",
              "updatedAt": "2024-05-14T22:57:17Z"
            },
            {
              "originalPosition": 30,
              "body": "If I'm understanding correctly:\r\n```suggestion\r\nQUIC streams begin with a header sequence of bytes that links them to the established\r\n```",
              "createdAt": "2024-05-14T22:54:05Z",
              "updatedAt": "2024-05-14T22:57:17Z"
            },
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nsession. The remainder of the stream is the body, which carries the payload supplied by\r\n```",
              "createdAt": "2024-05-14T22:54:53Z",
              "updatedAt": "2024-05-14T23:00:01Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nHTTP/1.1 {{?RFC6455}}, where access to the underlying bytestream is enabled\r\n```",
              "createdAt": "2024-05-14T22:55:52Z",
              "updatedAt": "2024-05-14T22:57:17Z"
            },
            {
              "originalPosition": 71,
              "body": "```suggestion\r\ncompression, static compression, or Huffman encoding.\r\n```",
              "createdAt": "2024-05-14T22:56:16Z",
              "updatedAt": "2024-05-14T22:57:17Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nThe layering of QUIC, HTTP/3, and WebTransport is shown in\r\n```",
              "createdAt": "2024-05-14T22:56:29Z",
              "updatedAt": "2024-05-14T22:57:17Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\nheader, and perhaps some extra headers.\r\n```",
              "createdAt": "2024-05-14T22:57:01Z",
              "updatedAt": "2024-05-14T22:57:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s56lWc8",
          "commit": {
            "abbreviatedOid": "a75388c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-14T22:57:36Z",
          "updatedAt": "2024-05-14T22:57:37Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nHTTP/1.1 {{?ORIGIN=RFC6455}}, where access to the underlying byte stream is enabled\r\n```",
              "createdAt": "2024-05-14T22:57:36Z",
              "updatedAt": "2024-05-14T22:57:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s56lWxb",
          "commit": {
            "abbreviatedOid": "a75388c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-14T22:59:09Z",
          "updatedAt": "2024-05-14T22:59:09Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "```suggestion\r\n| HTTP Semantics |               |\r\n|      and       |               |\r\n| Session Setup  | Nearly direct |\r\n,----------------,               |\r\n```",
              "createdAt": "2024-05-14T22:59:09Z",
              "updatedAt": "2024-05-14T22:59:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 148,
      "id": "PR_kwDOCvK98s5oHymT",
      "title": "Define key exporters",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/148",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #116",
      "createdAt": "2024-02-28T03:29:54Z",
      "updatedAt": "2024-05-14T22:54:06Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "b133c01dd2c905031f79c40bf68fa27a25b0d51d",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "exporter",
      "headRefOid": "d5ed43d602107175ef659d7dc6192be5545ed6e5",
      "closedAt": "2024-05-14T22:54:06Z",
      "mergedAt": "2024-05-14T22:54:06Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "6678676db5dce82376949ca62b2f29c81cea9c31"
      },
      "comments": [
        {
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "body": "So, are those limits actually applicable?  At least in RFC8446, it looks like passes the hash of the context, and not the context itself.  I guess, we could limit ourselves to what would be allowed by TLS if we wanted them to be fully compatible.",
          "createdAt": "2024-03-17T08:07:57Z",
          "updatedAt": "2024-03-17T08:07:57Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Chair: discussed in the room at 119. No concerns from room. Plan is to give folks another week to review and then merge if there are no objections",
          "createdAt": "2024-03-18T22:26:06Z",
          "updatedAt": "2024-03-18T22:26:06Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5xj8OL",
          "commit": {
            "abbreviatedOid": "563574c"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-02-28T03:40:49Z",
          "updatedAt": "2024-02-28T03:46:21Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "32 bits is monstrously long.  TLS exporters only permit 0..255, so I would strongly suggest that you change these:\r\n\r\n```suggestion\r\n  WebTransport Application-Supplied Exporter Label Length (8),\r\n```\r\n\r\nYou might also note that there is a further limitation on the total size imposed by TLS.",
              "createdAt": "2024-02-28T03:40:49Z",
              "updatedAt": "2024-02-28T03:46:21Z"
            },
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nlabel and context, the resulting exporter SHALL be a TLS exporter as defined in\r\n```",
              "createdAt": "2024-02-28T03:41:21Z",
              "updatedAt": "2024-02-28T03:46:21Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n{{RFC8446, Section 7.5}} with the label set to \"EXPORTER-WebTransport\" and the\r\n```",
              "createdAt": "2024-02-28T03:41:40Z",
              "updatedAt": "2024-02-28T03:46:21Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nA TLS exporter API might permit the context field to be omitted. In this case,\r\nas with TLS 1.3, the WebTransport Application-Supplied Exporter Context\r\nbecomes zero-length if omitted.\r\n```",
              "createdAt": "2024-02-28T03:44:09Z",
              "updatedAt": "2024-02-28T03:46:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5yLHXe",
          "commit": {
            "abbreviatedOid": "952884b"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-04T22:58:23Z",
          "updatedAt": "2024-03-04T22:58:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5yLehb",
          "commit": {
            "abbreviatedOid": "952884b"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T00:17:28Z",
          "updatedAt": "2024-03-05T00:21:45Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\n  WebTransport Application-Supplied Exporter Context Length (8),\r\n```",
              "createdAt": "2024-03-05T00:17:29Z",
              "updatedAt": "2024-03-05T00:21:45Z"
            },
            {
              "originalPosition": 25,
              "body": "```suggestion\r\n\r\nNote that the TLS exporter API requires that labels are between 1 and 249 bytes in length and contexts are between 0 and 255 bytes.  Because this structure is included in the context field of a TLS exporter, the combined length of labels and contexts needs to be 245 bytes or shorter.\r\n\r\n```",
              "createdAt": "2024-03-05T00:21:16Z",
              "updatedAt": "2024-03-05T00:21:45Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\n  WebTransport Application-Supplied Exporter Label (8..),\r\n```\r\n\r\nIt probably makes sense to set a minimum.",
              "createdAt": "2024-03-05T00:21:30Z",
              "updatedAt": "2024-03-05T00:21:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5yLfnY",
          "commit": {
            "abbreviatedOid": "952884b"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-05T00:22:23Z",
          "updatedAt": "2024-03-05T00:22:23Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Note: it is not sufficient to just merge suggestions.",
              "createdAt": "2024-03-05T00:22:23Z",
              "updatedAt": "2024-03-05T00:22:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5zt2FI",
          "commit": {
            "abbreviatedOid": "952884b"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-17T08:01:56Z",
          "updatedAt": "2024-03-17T08:01:56Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Ah, I misread that as implying that only the label was subject to length restrictions.",
              "createdAt": "2024-03-17T08:01:56Z",
              "updatedAt": "2024-03-17T08:01:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s53fb9-",
          "commit": {
            "abbreviatedOid": "952884b"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-04-16T23:09:56Z",
          "updatedAt": "2024-04-16T23:09:56Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "As Victor notes, this limit doesn't really need to be enforced due to the hashing limit.",
              "createdAt": "2024-04-16T23:09:56Z",
              "updatedAt": "2024-04-16T23:09:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s56lSum",
          "commit": {
            "abbreviatedOid": "215acef"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-14T22:49:36Z",
          "updatedAt": "2024-05-14T22:49:36Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n{{!RFC8446, Section 7.5}} with the label set to \"EXPORTER-WebTransport\" and the\r\n```",
              "createdAt": "2024-05-14T22:49:36Z",
              "updatedAt": "2024-05-14T22:49:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s56lS7t",
          "commit": {
            "abbreviatedOid": "215acef"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-14T22:49:52Z",
          "updatedAt": "2024-05-14T22:49:53Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n{{!RFC8446, Section 7.5}} with the label set to \"EXPORTER-WebTransport\" and the\r\n```",
              "createdAt": "2024-05-14T22:49:52Z",
              "updatedAt": "2024-05-14T22:49:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s56lTGE",
          "commit": {
            "abbreviatedOid": "215acef"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-14T22:50:07Z",
          "updatedAt": "2024-05-14T22:50:07Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n{{!RFC8446, Section 7.5}}.  Since the underlying QUIC connection may be shared by multiple\r\n```",
              "createdAt": "2024-05-14T22:50:07Z",
              "updatedAt": "2024-05-14T22:50:07Z"
            }
          ]
        }
      ]
    },
    {
      "number": 149,
      "id": "PR_kwDOCvK98s5opu1o",
      "title": "Adjust SETTINGS, buffering requirements, waiting for session establishment",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/149",
      "state": "MERGED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Adjust SETTINGS, buffering requirements, waiting for session establishment\r\n\r\nAs discussed: \r\n- Client MUST wait for server settings\r\n- Endpoints MUST send SETTINGS_H3_DATAGRAM (however servers that want to validate this MUST need to take into account the fact that the request might arrive before the client's SETTINGS)\r\n- Client no longer sends the WEBTRANSPORT_MAX_SESSIONS setting\r\n- Add a \"Considerations for future versions of WebTransport\" section that explain that if a future version of WebTransport changes the syntax of the request, it'll need to change the Upgrade Token. Similarly, changes to stream formats will require changes to the Unidirectional Stream Type and Bidirectional Stream Signal Value.\r\n\r\nFixes #135, #140, #141, and #143",
      "createdAt": "2024-03-04T23:39:56Z",
      "updatedAt": "2024-03-04T23:57:38Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "b133c01dd2c905031f79c40bf68fa27a25b0d51d",
      "headRepository": "ekinnear/draft-ietf-webtrans-http3",
      "headRefName": "ek/settings-and-establishment",
      "headRefOid": "65e0e92a698e9c6f08b359a08b29cf6b4a78676d",
      "closedAt": "2024-03-04T23:57:35Z",
      "mergedAt": "2024-03-04T23:57:35Z",
      "mergedBy": "ekinnear",
      "mergeCommit": {
        "oid": "d4bb318ec8223061aefef20836da62ff54700ca7"
      },
      "comments": [
        {
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "body": "(Double checked, merging now so we can discuss in more detail at 119, happy to spin additional updates as needed!)",
          "createdAt": "2024-03-04T23:57:13Z",
          "updatedAt": "2024-03-04T23:57:13Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 151,
      "id": "PR_kwDOCvK98s5p2qDo",
      "title": "Make WebTransport resets reliable",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/151",
      "state": "MERGED",
      "author": "vasilvv",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #77",
      "createdAt": "2024-03-17T07:50:32Z",
      "updatedAt": "2024-06-11T22:31:49Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "d4bb318ec8223061aefef20836da62ff54700ca7",
      "headRepository": "vasilvv/draft-ietf-webtrans-http3",
      "headRefName": "reliable-reset",
      "headRefOid": "d8605ac18c5f9fe34a6eef86ee597f009e821db7",
      "closedAt": "2024-06-11T22:31:49Z",
      "mergedAt": "2024-06-11T22:31:49Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "0b2c7644e736a4e02f764bb5442b8eb6d06e07db"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s5zvEWF",
          "commit": {
            "abbreviatedOid": "0f11fb9"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-03-18T01:12:47Z",
          "updatedAt": "2024-03-18T01:18:04Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nboth the client and the server MUST enable the extension as described in {{Section 3 of RESET-STREAM-AT}}.\r\n```",
              "createdAt": "2024-03-18T01:12:47Z",
              "updatedAt": "2024-03-18T01:18:04Z"
            },
            {
              "originalPosition": 24,
              "body": "Suggestion (GitHub doesn't allow me to mark this a suggestion since it covers unchanged lines):\r\n> WebTransport data streams are associated with sessions through a header at the\r\nbeginning of the stream; resetting a stream might result in that data being\r\ndiscarded when using a RESET_STREAM frame.\r\n> To prevent this, WebTransport implementations MUST use the RESET_STREAM_AT frame {{RESET-STREAM-AT}} with a Reliable Size set to at least the size of the header when resetting WebTransport data. This ensure that the stream header containing the associated WebTransport session ID is always delivered.",
              "createdAt": "2024-03-18T01:18:01Z",
              "updatedAt": "2024-03-18T01:18:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s56lR0i",
          "commit": {
            "abbreviatedOid": "0f11fb9"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-05-14T22:46:34Z",
          "updatedAt": "2024-05-14T22:46:35Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "'MUST use' ... how?",
              "createdAt": "2024-05-14T22:46:34Z",
              "updatedAt": "2024-05-14T22:46:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s56lSOe",
          "commit": {
            "abbreviatedOid": "0f11fb9"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Take Marten's suggestions first, but I think that you need to elevate rst-str-at to the same level as h3-dg. ",
          "createdAt": "2024-05-14T22:48:41Z",
          "updatedAt": "2024-05-14T22:48:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s5929Ai",
          "commit": {
            "abbreviatedOid": "0f11fb9"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-11T22:27:16Z",
          "updatedAt": "2024-06-11T22:27:16Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Thanks! Adopted this with a few modifications.",
              "createdAt": "2024-06-11T22:27:16Z",
              "updatedAt": "2024-06-11T22:27:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5929_J",
          "commit": {
            "abbreviatedOid": "c64d995"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-11T22:30:47Z",
          "updatedAt": "2024-06-11T22:30:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s592-FX",
          "commit": {
            "abbreviatedOid": "c64d995"
          },
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-11T22:31:13Z",
          "updatedAt": "2024-06-11T22:31:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s592-K4",
          "commit": {
            "abbreviatedOid": "c64d995"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-11T22:31:35Z",
          "updatedAt": "2024-06-11T22:31:36Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nboth the client and the server MUST enable the extension as described \r\nin {{Section 3 of RESET-STREAM-AT}}.\r\n```",
              "createdAt": "2024-06-11T22:31:36Z",
              "updatedAt": "2024-06-11T22:31:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 154,
      "id": "PR_kwDOCvK98s5qlADl",
      "title": "don't require the client to send SETTINGS_ENABLE_CONNECT_PROTOCOL",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/154",
      "state": "MERGED",
      "author": "marten-seemann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #153.",
      "createdAt": "2024-03-24T07:20:04Z",
      "updatedAt": "2024-04-16T22:26:06Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "d4bb318ec8223061aefef20836da62ff54700ca7",
      "headRepository": "marten-seemann/draft-ietf-webtrans-http3",
      "headRefName": "patch-1",
      "headRefOid": "1f95274e7416da20b9000336d0f454bd2f5983b9",
      "closedAt": "2024-04-16T22:26:06Z",
      "mergedAt": "2024-04-16T22:26:06Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "e71fd28585adde7a9d5db1e0fdc09614b2eb0cc9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s50nbtY",
          "commit": {
            "abbreviatedOid": "1f95274"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-03-24T07:30:51Z",
          "updatedAt": "2024-03-24T07:30:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s53fSeM",
          "commit": {
            "abbreviatedOid": "1f95274"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-04-16T22:25:55Z",
          "updatedAt": "2024-04-16T22:25:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s53fSek",
          "commit": {
            "abbreviatedOid": "1f95274"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2024-04-16T22:25:56Z",
          "updatedAt": "2024-04-16T22:25:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 160,
      "id": "PR_kwDOCvK98s5s2oOv",
      "title": "A close can be followed by a close or reset",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/160",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It's true that you might not be able to close the stream in response (particularly if the close might indicate success where there was no actual response).  So allow either.\r\n\r\nCloses #156.",
      "createdAt": "2024-04-16T22:30:03Z",
      "updatedAt": "2024-04-17T00:46:44Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "e71fd28585adde7a9d5db1e0fdc09614b2eb0cc9",
      "headRepository": "martinthomson/draft-ietf-webtrans-http3",
      "headRefName": "issue156",
      "headRefOid": "1341e8cea1ec2a04b12c6752e7071c0499548fc2",
      "closedAt": "2024-04-16T22:31:01Z",
      "mergedAt": "2024-04-16T22:31:01Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "caf2ab63bb7aa31704ef63c8b2bbb517dfa444cb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s53fTdn",
          "commit": {
            "abbreviatedOid": "1341e8c"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-04-16T22:30:22Z",
          "updatedAt": "2024-04-16T22:30:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s53fTh1",
          "commit": {
            "abbreviatedOid": "1341e8c"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-04-16T22:30:39Z",
          "updatedAt": "2024-04-16T22:30:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 161,
      "id": "PR_kwDOCvK98s5w0JtA",
      "title": "Don't rely on ACKs for session closure",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/161",
      "state": "MERGED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #147",
      "createdAt": "2024-05-28T22:03:33Z",
      "updatedAt": "2024-06-11T22:14:22Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "5a7174ba97ef265670b9ff178e35f15561606a61",
      "headRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "headRefName": "no-acks-during-close",
      "headRefOid": "646b5d8bfd765fbadc736a5b4cd225e8efcee720",
      "closedAt": "2024-06-11T22:14:22Z",
      "mergedAt": "2024-06-11T22:14:22Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "e487c6d7674f7ead5bcb03f62309539f2db69dbf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s59247l",
          "commit": {
            "abbreviatedOid": "646b5d8"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-11T22:10:34Z",
          "updatedAt": "2024-06-11T22:10:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s59253L",
          "commit": {
            "abbreviatedOid": "646b5d8"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-11T22:13:47Z",
          "updatedAt": "2024-06-11T22:13:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s59254x",
          "commit": {
            "abbreviatedOid": "646b5d8"
          },
          "author": "aboba",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-11T22:13:52Z",
          "updatedAt": "2024-06-11T22:13:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 162,
      "id": "PR_kwDOCvK98s5yKiEk",
      "title": "Changes to subprotocol negotiation",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/162",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "1. The names of these fields was too much for poor little me.\r\n2. Say that -Options is in preference order.\r\n3. Remove a comma.\r\n\r\nCloses #159.",
      "createdAt": "2024-06-11T22:17:58Z",
      "updatedAt": "2024-08-20T22:35:36Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "e487c6d7674f7ead5bcb03f62309539f2db69dbf",
      "headRepository": "martinthomson/draft-ietf-webtrans-http3",
      "headRefName": "wt-protocol-options",
      "headRefOid": "3779666cd3646a7c9a9e749f1700c98c92e1dc3f",
      "closedAt": "2024-08-20T22:12:07Z",
      "mergedAt": "2024-08-20T22:12:07Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "b2dce6ac103b83ae28e6164bf251ad841a6cbe43"
      },
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#168 fixes the build error.",
          "createdAt": "2024-07-09T22:13:18Z",
          "updatedAt": "2024-07-09T22:13:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s592-Yo",
          "commit": {
            "abbreviatedOid": "f9b2834"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-11T22:32:41Z",
          "updatedAt": "2024-06-11T22:32:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s6GD9SA",
          "commit": {
            "abbreviatedOid": "3779666"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-20T22:10:18Z",
          "updatedAt": "2024-08-20T22:10:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOCvK98s6GD9y2",
          "commit": {
            "abbreviatedOid": "3779666"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-20T22:11:25Z",
          "updatedAt": "2024-08-20T22:11:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 163,
      "id": "PR_kwDOCvK98s5yKj5t",
      "title": "Reliable reset",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/163",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is an expanded version of @marten-seemann's suggestion on https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/151.\r\n\r\nCloses https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/151.\r\nCloses https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/issues/77.",
      "createdAt": "2024-06-11T22:26:24Z",
      "updatedAt": "2024-06-11T22:32:05Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "e487c6d7674f7ead5bcb03f62309539f2db69dbf",
      "headRepository": "martinthomson/draft-ietf-webtrans-http3",
      "headRefName": "reliable-reset",
      "headRefOid": "bb79f41347de5457824239ea02ba404e4ffa719e",
      "closedAt": "2024-06-11T22:32:05Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #151",
          "createdAt": "2024-06-11T22:32:05Z",
          "updatedAt": "2024-06-11T22:32:05Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s59289Q",
          "commit": {
            "abbreviatedOid": "3bee97c"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-11T22:27:04Z",
          "updatedAt": "2024-06-11T22:27:04Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nboth the client and the server MUST enable the extension as described\r\nin {{Section 3 of RESET-STREAM-AT}}.\r\n```",
              "createdAt": "2024-06-11T22:27:04Z",
              "updatedAt": "2024-06-11T22:27:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s5929OS",
          "commit": {
            "abbreviatedOid": "3bee97c"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-06-11T22:27:56Z",
          "updatedAt": "2024-06-11T22:27:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 165,
      "id": "PR_kwDOCvK98s5yKojk",
      "title": "WebTransport requests are malformed if the settings are wrong",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/165",
      "state": "MERGED",
      "author": "afrind",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes: #155",
      "createdAt": "2024-06-11T22:48:48Z",
      "updatedAt": "2024-08-20T22:19:20Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "0b2c7644e736a4e02f764bb5442b8eb6d06e07db",
      "headRepository": "afrind/draft-ietf-webtrans-http3",
      "headRefName": "datagram-setting",
      "headRefOid": "429a0ac05337da228af86455b1251aff479b49dc",
      "closedAt": "2024-08-20T22:19:20Z",
      "mergedAt": "2024-08-20T22:19:20Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "6e509fd87a632494310e8a67ffe3dac89a7c20ef"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s594Ohc",
          "commit": {
            "abbreviatedOid": "512b1c5"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-12T03:46:58Z",
          "updatedAt": "2024-06-12T03:46:59Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Does this mean the server should send a 400 or a H3_MESSAGE_ERROR?",
              "createdAt": "2024-06-12T03:46:58Z",
              "updatedAt": "2024-06-12T03:46:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s59-C4K",
          "commit": {
            "abbreviatedOid": "512b1c5"
          },
          "author": "afrind",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-06-12T15:38:28Z",
          "updatedAt": "2024-06-12T15:38:28Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Here's what 9114 says:\r\n\r\n> Malformed requests or responses that are detected MUST be treated as a [stream error](https://datatracker.ietf.org/doc/html/rfc9114#errors) of type [H3_MESSAGE_ERROR](https://datatracker.ietf.org/doc/html/rfc9114#H3_MESSAGE_ERROR).\r\n\r\n> For malformed requests, a server MAY send an HTTP response indicating the error prior to closing or resetting the stream.\r\n\r\nSo MUST reset and MAY send a response first (hope it's a reliable reset!).  I like this since it handles the case where the server might have already assumed the settings would be correct, and sent a 200, and detected malformed-ness later.\r\n",
              "createdAt": "2024-06-12T15:38:28Z",
              "updatedAt": "2024-06-12T15:38:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s6GD-4t",
          "commit": {
            "abbreviatedOid": "512b1c5"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-20T22:13:48Z",
          "updatedAt": "2024-08-20T22:13:48Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I like this.  Could you add a direct citation into the spec text?",
              "createdAt": "2024-08-20T22:13:48Z",
              "updatedAt": "2024-08-20T22:13:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s6GD_wN",
          "commit": {
            "abbreviatedOid": "512b1c5"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-20T22:16:11Z",
          "updatedAt": "2024-08-20T22:16:12Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\ndatagrams MUST be treated as malformed by the server,\r\nas defined in {{Section 4.1.2 of HTTP3}}.\r\n```",
              "createdAt": "2024-08-20T22:16:12Z",
              "updatedAt": "2024-08-20T22:16:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s6GEAMS",
          "commit": {
            "abbreviatedOid": "7deb2d8"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-20T22:17:30Z",
          "updatedAt": "2024-08-20T22:17:31Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nas described in {{Section 4.1.2 of HTTP3}}.\r\n```",
              "createdAt": "2024-08-20T22:17:31Z",
              "updatedAt": "2024-08-20T22:17:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s6GEAhc",
          "commit": {
            "abbreviatedOid": "7deb2d8"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-20T22:18:24Z",
          "updatedAt": "2024-08-20T22:18:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 166,
      "id": "PR_kwDOCvK98s5zIi6m",
      "title": "Add initial flow control text and capsules from HTTP/2",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/166",
      "state": "OPEN",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add initial flow control text and capsules from HTTP/2 and draft-thomson-webtrans-session-limit-01. Happy to re-re-arrange sections as necessary.\r\n\r\nNegotiation of flow control is coming under the separate issue to make things a little easier to keep track of and review.\r\n\r\nCloses #85.",
      "createdAt": "2024-06-21T02:14:05Z",
      "updatedAt": "2024-07-25T07:16:28Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "0b2c7644e736a4e02f764bb5442b8eb6d06e07db",
      "headRepository": "ekinnear/draft-ietf-webtrans-http3",
      "headRefName": "ek/flow_control",
      "headRefOid": "90d85633e14ce23bb1bbee31671cc08800bd5917",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s6BNekn",
          "commit": {
            "abbreviatedOid": "6bdf7d6"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for doing the heavy lifting @ekinnear.  I don't have any major comments.  You got the main ones, like intermediary responsibilities.",
          "createdAt": "2024-07-10T01:24:04Z",
          "updatedAt": "2024-07-10T01:37:55Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "```suggestion\r\nstatus defined in {{HTTP3}}.\r\n```\r\n\r\nAs a general rule, I recommend {{}} over [] because the latter will silently fail whereas the former does not.",
              "createdAt": "2024-07-10T01:24:04Z",
              "updatedAt": "2024-07-10T01:37:55Z"
            },
            {
              "originalPosition": 111,
              "body": "```suggestion\r\nThe WT_STREAMS_BLOCKED capsule ({{WT_STREAMS_BLOCKED}}) can be sent to indicate that\r\n```",
              "createdAt": "2024-07-10T01:25:18Z",
              "updatedAt": "2024-07-10T01:37:55Z"
            },
            {
              "originalPosition": 129,
              "body": "```suggestion\r\nThe WT_DATA_BLOCKED capsule ({{WT_DATA_BLOCKED}}) can be sent to indicate that an\r\n```",
              "createdAt": "2024-07-10T01:28:01Z",
              "updatedAt": "2024-07-10T01:37:55Z"
            },
            {
              "originalPosition": 127,
              "body": "Is it worth highlighting this as a difference?  With HTTP/2 you don't need this, but HTTP/3 means that you are creating streams all over and using final size.  We might also note that this is independent of any RESET_STREAM_AT functionality.",
              "createdAt": "2024-07-10T01:29:59Z",
              "updatedAt": "2024-07-10T01:37:55Z"
            },
            {
              "originalPosition": 162,
              "body": "```suggestion\r\ncannot be immediately sent on its translated connection can ensure that it\r\n```",
              "createdAt": "2024-07-10T01:31:55Z",
              "updatedAt": "2024-07-10T01:37:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s6DCosY",
          "commit": {
            "abbreviatedOid": "6bdf7d6"
          },
          "author": "ekinnear",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-25T07:16:03Z",
          "updatedAt": "2024-07-25T07:16:03Z",
          "comments": [
            {
              "originalPosition": 127,
              "body": "When you say highlighting this as a difference, what're you thinking? Like adding additional text to describe how this works here as opposed to H2? (I'd imagine we'd add that to H2 where we refer to this capsule?)",
              "createdAt": "2024-07-25T07:16:03Z",
              "updatedAt": "2024-07-25T07:16:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 168,
      "id": "PR_kwDOCvK98s505CC_",
      "title": "Trailing whitespace",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/168",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-07-09T22:13:00Z",
      "updatedAt": "2024-07-09T22:19:03Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "0b2c7644e736a4e02f764bb5442b8eb6d06e07db",
      "headRepository": "martinthomson/draft-ietf-webtrans-http3",
      "headRefName": "whitespace",
      "headRefOid": "86e0852f4c9fe72b7d1ff474f5d67535291b5b94",
      "closedAt": "2024-07-09T22:19:03Z",
      "mergedAt": "2024-07-09T22:19:03Z",
      "mergedBy": "vasilvv",
      "mergeCommit": {
        "oid": "97f4db12ec7b6d22d2ad7fc19b689d1c1c36b20b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s6BMwcl",
          "commit": {
            "abbreviatedOid": "86e0852"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-07-09T22:18:42Z",
          "updatedAt": "2024-07-09T22:18:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 169,
      "id": "PR_kwDOCvK98s51ulue",
      "title": "Fix some typos",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/169",
      "state": "MERGED",
      "author": "MarcoPolo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm not 100% sure about the change from:\r\n\r\n\"If at any point a session ID is received that cannot a valid ID for a\"\r\nto\r\n\"If at any point a session ID is received that cannot be a valid ID for a\"\r\n\r\nSo please double check that logic. I went with the smallest hamming distance.",
      "createdAt": "2024-07-18T05:46:39Z",
      "updatedAt": "2024-08-20T22:06:39Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "97f4db12ec7b6d22d2ad7fc19b689d1c1c36b20b",
      "headRepository": "MarcoPolo/draft-ietf-webtrans-http3",
      "headRefName": "typos",
      "headRefOid": "06ff8db387457039a0206f3c2d20a472edde35d6",
      "closedAt": "2024-08-20T22:06:39Z",
      "mergedAt": "2024-08-20T22:06:39Z",
      "mergedBy": "DavidSchinazi",
      "mergeCommit": {
        "oid": "379d681a45be35c3d4486ac8acf13ebe95611618"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s6COnG9",
          "commit": {
            "abbreviatedOid": "9bb4324"
          },
          "author": "marten-seemann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "The other changes lgtm.",
          "createdAt": "2024-07-18T06:46:15Z",
          "updatedAt": "2024-07-18T06:46:56Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "The length is measured in bits, not bytes.",
              "createdAt": "2024-07-18T06:46:15Z",
              "updatedAt": "2024-07-18T06:46:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCvK98s6GD7Ta",
          "commit": {
            "abbreviatedOid": "06ff8db"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-08-20T22:06:24Z",
          "updatedAt": "2024-08-20T22:06:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 174,
      "id": "PR_kwDOCvK98s58UUrk",
      "title": "Finish rename of subprotocol -> protocol",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/174",
      "state": "MERGED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Finish rename of subprotocol -> protocol\r\n\r\nUpdating to be consistent everywhere with terminology, this now matches across HTTP/3, HTTP/2, and the overview document.\r\n\r\nCloses #173.",
      "createdAt": "2024-09-23T06:15:56Z",
      "updatedAt": "2024-10-21T21:53:19Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "0fa9349ad937ea32daa1532ee322d8a326c07abf",
      "headRepository": "ekinnear/draft-ietf-webtrans-http3",
      "headRefName": "ek/rename_subprotocols",
      "headRefOid": "b6ad018302c7bcfb69a49312bdd2d1e47547bf50",
      "closedAt": "2024-10-21T21:53:16Z",
      "mergedAt": "2024-10-21T21:53:16Z",
      "mergedBy": "ekinnear",
      "mergeCommit": {
        "oid": "f69b27a9c31532ef840f576c509d4414a4adb7b5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCvK98s6KgtpL",
          "commit": {
            "abbreviatedOid": "b6ad018"
          },
          "author": "vasilvv",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-09-24T01:48:53Z",
          "updatedAt": "2024-10-21T21:50:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 175,
      "id": "PR_kwDOCvK98s5_YMDz",
      "title": "Update upload-artifact actions",
      "url": "https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/pull/175",
      "state": "MERGED",
      "author": "ekinnear",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Update upload-artifact actions",
      "createdAt": "2024-10-21T21:31:53Z",
      "updatedAt": "2024-10-21T21:49:49Z",
      "baseRepository": "ietf-wg-webtrans/draft-ietf-webtrans-http3",
      "baseRefName": "main",
      "baseRefOid": "6e509fd87a632494310e8a67ffe3dac89a7c20ef",
      "headRepository": "ekinnear/draft-ietf-webtrans-http3",
      "headRefName": "ek/update_actions",
      "headRefOid": "b5b0a1f3a63cebc6871c753a312b89fc78550054",
      "closedAt": "2024-10-21T21:49:46Z",
      "mergedAt": "2024-10-21T21:49:46Z",
      "mergedBy": "ekinnear",
      "mergeCommit": {
        "oid": "0fa9349ad937ea32daa1532ee322d8a326c07abf"
      },
      "comments": [],
      "reviews": []
    }
  ]
}